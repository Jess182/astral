// These bindings are auto-generated by ./_tools/generate/mod.ts
// Last generated at 2023-07-25T21:40:39.407Z
// deno-lint-ignore-file no-explicit-any

export const PROTOCOL_VERSION = "1.3";

// ----------------- Accessibility -----------------

/**
 * Unique accessibility node identifier.
 */
export type Accessibility_AXNodeId = string;

/**
 * Enum of possible property types.
 */
export type Accessibility_AXValueType =
  | "boolean"
  | "tristate"
  | "booleanOrUndefined"
  | "idref"
  | "idrefList"
  | "integer"
  | "node"
  | "nodeList"
  | "number"
  | "string"
  | "computedString"
  | "token"
  | "tokenList"
  | "domRelation"
  | "role"
  | "internalRole"
  | "valueUndefined";

/**
 * Enum of possible property sources.
 */
export type Accessibility_AXValueSourceType =
  | "attribute"
  | "implicit"
  | "style"
  | "contents"
  | "placeholder"
  | "relatedElement";

/**
 * Enum of possible native property sources (as a subtype of a particular AXValueSourceType).
 */
export type Accessibility_AXValueNativeSourceType =
  | "description"
  | "figcaption"
  | "label"
  | "labelfor"
  | "labelwrapped"
  | "legend"
  | "rubyannotation"
  | "tablecaption"
  | "title"
  | "other";

/**
 * A single source for a computed AX property.
 */
export type Accessibility_AXValueSource = {
  /**
   * What type of source this is.
   */
  type: Accessibility_AXValueSourceType;
  /**
   * The value of this property source.
   */
  value?: Accessibility_AXValue;
  /**
   * The name of the relevant attribute, if any.
   */
  attribute?: string;
  /**
   * The value of the relevant attribute, if any.
   */
  attributeValue?: Accessibility_AXValue;
  /**
   * Whether this source is superseded by a higher priority source.
   */
  superseded?: boolean;
  /**
   * The native markup source for this value, e.g. a `<label>` element.
   */
  nativeSource?: Accessibility_AXValueNativeSourceType;
  /**
   * The value, such as a node or node list, of the native source.
   */
  nativeSourceValue?: Accessibility_AXValue;
  /**
   * Whether the value for this property is invalid.
   */
  invalid?: boolean;
  /**
   * Reason for the value being invalid, if it is.
   */
  invalidReason?: string;
};

export type Accessibility_AXRelatedNode = {
  /**
   * The BackendNodeId of the related DOM node.
   */
  backendDOMNodeId: DOM_BackendNodeId;
  /**
   * The IDRef value provided, if any.
   */
  idref?: string;
  /**
   * The text alternative of this node in the current context.
   */
  text?: string;
};

export type Accessibility_AXProperty = {
  /**
   * The name of this property.
   */
  name: Accessibility_AXPropertyName;
  /**
   * The value of this property.
   */
  value: Accessibility_AXValue;
};

/**
 * A single computed AX property.
 */
export type Accessibility_AXValue = {
  /**
   * The type of this value.
   */
  type: Accessibility_AXValueType;
  /**
   * The computed value of this property.
   */
  value?: any;
  /**
   * One or more related nodes, if applicable.
   */
  relatedNodes?: Accessibility_AXRelatedNode[];
  /**
   * The sources which contributed to the computation of this property.
   */
  sources?: Accessibility_AXValueSource[];
};

/**
 * Values of AXProperty name:
 * - from 'busy' to 'roledescription': states which apply to every AX node
 * - from 'live' to 'root': attributes which apply to nodes in live regions
 * - from 'autocomplete' to 'valuetext': attributes which apply to widgets
 * - from 'checked' to 'selected': states which apply to widgets
 * - from 'activedescendant' to 'owns' - relationships between elements other than parent/child/sibling.
 */
export type Accessibility_AXPropertyName =
  | "busy"
  | "disabled"
  | "editable"
  | "focusable"
  | "focused"
  | "hidden"
  | "hiddenRoot"
  | "invalid"
  | "keyshortcuts"
  | "settable"
  | "roledescription"
  | "live"
  | "atomic"
  | "relevant"
  | "root"
  | "autocomplete"
  | "hasPopup"
  | "level"
  | "multiselectable"
  | "orientation"
  | "multiline"
  | "readonly"
  | "required"
  | "valuemin"
  | "valuemax"
  | "valuetext"
  | "checked"
  | "expanded"
  | "modal"
  | "pressed"
  | "selected"
  | "activedescendant"
  | "controls"
  | "describedby"
  | "details"
  | "errormessage"
  | "flowto"
  | "labelledby"
  | "owns";

/**
 * A node in the accessibility tree.
 */
export type Accessibility_AXNode = {
  /**
   * Unique identifier for this node.
   */
  nodeId: Accessibility_AXNodeId;
  /**
   * Whether this node is ignored for accessibility
   */
  ignored: boolean;
  /**
   * Collection of reasons why this node is hidden.
   */
  ignoredReasons?: Accessibility_AXProperty[];
  /**
   * This `Node`'s role, whether explicit or implicit.
   */
  role?: Accessibility_AXValue;
  /**
   * This `Node`'s Chrome raw role.
   */
  chromeRole?: Accessibility_AXValue;
  /**
   * The accessible name for this `Node`.
   */
  name?: Accessibility_AXValue;
  /**
   * The accessible description for this `Node`.
   */
  description?: Accessibility_AXValue;
  /**
   * The value for this `Node`.
   */
  value?: Accessibility_AXValue;
  /**
   * All other properties
   */
  properties?: Accessibility_AXProperty[];
  /**
   * ID for this node's parent.
   */
  parentId?: Accessibility_AXNodeId;
  /**
   * IDs for each of this node's child nodes.
   */
  childIds?: Accessibility_AXNodeId[];
  /**
   * The backend ID for the associated DOM node, if any.
   */
  backendDOMNodeId?: DOM_BackendNodeId;
  /**
   * The frame ID for the frame associated with this nodes document.
   */
  frameId?: Page_FrameId;
};

// ----------------- Animation -----------------

/**
 * Animation instance.
 */
export type Animation_Animation = {
  /**
   * `Animation`'s id.
   */
  id: string;
  /**
   * `Animation`'s name.
   */
  name: string;
  /**
   * `Animation`'s internal paused state.
   */
  pausedState: boolean;
  /**
   * `Animation`'s play state.
   */
  playState: string;
  /**
   * `Animation`'s playback rate.
   */
  playbackRate: number;
  /**
   * `Animation`'s start time.
   */
  startTime: number;
  /**
   * `Animation`'s current time.
   */
  currentTime: number;
  /**
   * Animation type of `Animation`.
   */
  type: "CSSTransition" | "CSSAnimation" | "WebAnimation";
  /**
   * `Animation`'s source animation node.
   */
  source?: Animation_AnimationEffect;
  /**
   * A unique ID for `Animation` representing the sources that triggered this CSS
   * animation/transition.
   */
  cssId?: string;
};

/**
 * AnimationEffect instance
 */
export type Animation_AnimationEffect = {
  /**
   * `AnimationEffect`'s delay.
   */
  delay: number;
  /**
   * `AnimationEffect`'s end delay.
   */
  endDelay: number;
  /**
   * `AnimationEffect`'s iteration start.
   */
  iterationStart: number;
  /**
   * `AnimationEffect`'s iterations.
   */
  iterations: number;
  /**
   * `AnimationEffect`'s iteration duration.
   */
  duration: number;
  /**
   * `AnimationEffect`'s playback direction.
   */
  direction: string;
  /**
   * `AnimationEffect`'s fill mode.
   */
  fill: string;
  /**
   * `AnimationEffect`'s target node.
   */
  backendNodeId?: DOM_BackendNodeId;
  /**
   * `AnimationEffect`'s keyframes.
   */
  keyframesRule?: Animation_KeyframesRule;
  /**
   * `AnimationEffect`'s timing function.
   */
  easing: string;
};

/**
 * Keyframes Rule
 */
export type Animation_KeyframesRule = {
  /**
   * CSS keyframed animation's name.
   */
  name?: string;
  /**
   * List of animation keyframes.
   */
  keyframes: Animation_KeyframeStyle[];
};

/**
 * Keyframe Style
 */
export type Animation_KeyframeStyle = {
  /**
   * Keyframe's time offset.
   */
  offset: string;
  /**
   * `AnimationEffect`'s timing function.
   */
  easing: string;
};

// ----------------- Audits -----------------

/**
 * Information about a cookie that is affected by an inspector issue.
 */
export type Audits_AffectedCookie = {
  /**
   * The following three properties uniquely identify a cookie
   */
  name: string;
  path: string;
  domain: string;
};

/**
 * Information about a request that is affected by an inspector issue.
 */
export type Audits_AffectedRequest = {
  /**
   * The unique request id.
   */
  requestId: Network_RequestId;
  url?: string;
};

/**
 * Information about the frame affected by an inspector issue.
 */
export type Audits_AffectedFrame = {
  frameId: Page_FrameId;
};

export type Audits_CookieExclusionReason =
  | "ExcludeSameSiteUnspecifiedTreatedAsLax"
  | "ExcludeSameSiteNoneInsecure"
  | "ExcludeSameSiteLax"
  | "ExcludeSameSiteStrict"
  | "ExcludeInvalidSameParty"
  | "ExcludeSamePartyCrossPartyContext"
  | "ExcludeDomainNonASCII"
  | "ExcludeThirdPartyCookieBlockedInFirstPartySet";

export type Audits_CookieWarningReason =
  | "WarnSameSiteUnspecifiedCrossSiteContext"
  | "WarnSameSiteNoneInsecure"
  | "WarnSameSiteUnspecifiedLaxAllowUnsafe"
  | "WarnSameSiteStrictLaxDowngradeStrict"
  | "WarnSameSiteStrictCrossDowngradeStrict"
  | "WarnSameSiteStrictCrossDowngradeLax"
  | "WarnSameSiteLaxCrossDowngradeStrict"
  | "WarnSameSiteLaxCrossDowngradeLax"
  | "WarnAttributeValueExceedsMaxSize"
  | "WarnDomainNonASCII"
  | "WarnThirdPartyPhaseout";

export type Audits_CookieOperation = "SetCookie" | "ReadCookie";

/**
 * This information is currently necessary, as the front-end has a difficult
 * time finding a specific cookie. With this, we can convey specific error
 * information without the cookie.
 */
export type Audits_CookieIssueDetails = {
  /**
   * If AffectedCookie is not set then rawCookieLine contains the raw
   * Set-Cookie header string. This hints at a problem where the
   * cookie line is syntactically or semantically malformed in a way
   * that no valid cookie could be created.
   */
  cookie?: Audits_AffectedCookie;
  rawCookieLine?: string;
  cookieWarningReasons: Audits_CookieWarningReason[];
  cookieExclusionReasons: Audits_CookieExclusionReason[];
  /**
   * Optionally identifies the site-for-cookies and the cookie url, which
   * may be used by the front-end as additional context.
   */
  operation: Audits_CookieOperation;
  siteForCookies?: string;
  cookieUrl?: string;
  request?: Audits_AffectedRequest;
};

export type Audits_MixedContentResolutionStatus =
  | "MixedContentBlocked"
  | "MixedContentAutomaticallyUpgraded"
  | "MixedContentWarning";

export type Audits_MixedContentResourceType =
  | "AttributionSrc"
  | "Audio"
  | "Beacon"
  | "CSPReport"
  | "Download"
  | "EventSource"
  | "Favicon"
  | "Font"
  | "Form"
  | "Frame"
  | "Image"
  | "Import"
  | "Manifest"
  | "Ping"
  | "PluginData"
  | "PluginResource"
  | "Prefetch"
  | "Resource"
  | "Script"
  | "ServiceWorker"
  | "SharedWorker"
  | "Stylesheet"
  | "Track"
  | "Video"
  | "Worker"
  | "XMLHttpRequest"
  | "XSLT";

export type Audits_MixedContentIssueDetails = {
  /**
   * The type of resource causing the mixed content issue (css, js, iframe,
   * form,...). Marked as optional because it is mapped to from
   * blink::mojom::RequestContextType, which will be replaced
   * by network::mojom::RequestDestination
   */
  resourceType?: Audits_MixedContentResourceType;
  /**
   * The way the mixed content issue is being resolved.
   */
  resolutionStatus: Audits_MixedContentResolutionStatus;
  /**
   * The unsafe http url causing the mixed content issue.
   */
  insecureURL: string;
  /**
   * The url responsible for the call to an unsafe url.
   */
  mainResourceURL: string;
  /**
   * The mixed content request.
   * Does not always exist (e.g. for unsafe form submission urls).
   */
  request?: Audits_AffectedRequest;
  /**
   * Optional because not every mixed content issue is necessarily linked to a frame.
   */
  frame?: Audits_AffectedFrame;
};

/**
 * Enum indicating the reason a response has been blocked. These reasons are
 * refinements of the net error BLOCKED_BY_RESPONSE.
 */
export type Audits_BlockedByResponseReason =
  | "CoepFrameResourceNeedsCoepHeader"
  | "CoopSandboxedIFrameCannotNavigateToCoopPage"
  | "CorpNotSameOrigin"
  | "CorpNotSameOriginAfterDefaultedToSameOriginByCoep"
  | "CorpNotSameSite";

/**
 * Details for a request that has been blocked with the BLOCKED_BY_RESPONSE
 * code. Currently only used for COEP/COOP, but may be extended to include
 * some CSP errors in the future.
 */
export type Audits_BlockedByResponseIssueDetails = {
  request: Audits_AffectedRequest;
  parentFrame?: Audits_AffectedFrame;
  blockedFrame?: Audits_AffectedFrame;
  reason: Audits_BlockedByResponseReason;
};

export type Audits_HeavyAdResolutionStatus =
  | "HeavyAdBlocked"
  | "HeavyAdWarning";

export type Audits_HeavyAdReason =
  | "NetworkTotalLimit"
  | "CpuTotalLimit"
  | "CpuPeakLimit";

export type Audits_HeavyAdIssueDetails = {
  /**
   * The resolution status, either blocking the content or warning.
   */
  resolution: Audits_HeavyAdResolutionStatus;
  /**
   * The reason the ad was blocked, total network or cpu or peak cpu.
   */
  reason: Audits_HeavyAdReason;
  /**
   * The frame that was blocked.
   */
  frame: Audits_AffectedFrame;
};

export type Audits_ContentSecurityPolicyViolationType =
  | "kInlineViolation"
  | "kEvalViolation"
  | "kURLViolation"
  | "kTrustedTypesSinkViolation"
  | "kTrustedTypesPolicyViolation"
  | "kWasmEvalViolation";

export type Audits_SourceCodeLocation = {
  scriptId?: Runtime_ScriptId;
  url: string;
  lineNumber: number;
  columnNumber: number;
};

export type Audits_ContentSecurityPolicyIssueDetails = {
  /**
   * The url not included in allowed sources.
   */
  blockedURL?: string;
  /**
   * Specific directive that is violated, causing the CSP issue.
   */
  violatedDirective: string;
  isReportOnly: boolean;
  contentSecurityPolicyViolationType: Audits_ContentSecurityPolicyViolationType;
  frameAncestor?: Audits_AffectedFrame;
  sourceCodeLocation?: Audits_SourceCodeLocation;
  violatingNodeId?: DOM_BackendNodeId;
};

export type Audits_SharedArrayBufferIssueType =
  | "TransferIssue"
  | "CreationIssue";

/**
 * Details for a issue arising from an SAB being instantiated in, or
 * transferred to a context that is not cross-origin isolated.
 */
export type Audits_SharedArrayBufferIssueDetails = {
  sourceCodeLocation: Audits_SourceCodeLocation;
  isWarning: boolean;
  type: Audits_SharedArrayBufferIssueType;
};

export type Audits_LowTextContrastIssueDetails = {
  violatingNodeId: DOM_BackendNodeId;
  violatingNodeSelector: string;
  contrastRatio: number;
  thresholdAA: number;
  thresholdAAA: number;
  fontSize: string;
  fontWeight: string;
};

/**
 * Details for a CORS related issue, e.g. a warning or error related to
 * CORS RFC1918 enforcement.
 */
export type Audits_CorsIssueDetails = {
  corsErrorStatus: Network_CorsErrorStatus;
  isWarning: boolean;
  request: Audits_AffectedRequest;
  location?: Audits_SourceCodeLocation;
  initiatorOrigin?: string;
  resourceIPAddressSpace?: Network_IPAddressSpace;
  clientSecurityState?: Network_ClientSecurityState;
};

export type Audits_AttributionReportingIssueType =
  | "PermissionPolicyDisabled"
  | "UntrustworthyReportingOrigin"
  | "InsecureContext"
  | "InvalidHeader"
  | "InvalidRegisterTriggerHeader"
  | "SourceAndTriggerHeaders"
  | "SourceIgnored"
  | "TriggerIgnored"
  | "OsSourceIgnored"
  | "OsTriggerIgnored"
  | "InvalidRegisterOsSourceHeader"
  | "InvalidRegisterOsTriggerHeader"
  | "WebAndOsHeaders"
  | "NoWebOrOsSupport"
  | "NavigationRegistrationWithoutTransientUserActivation";

/**
 * Details for issues around "Attribution Reporting API" usage.
 * Explainer: https://github.com/WICG/attribution-reporting-api
 */
export type Audits_AttributionReportingIssueDetails = {
  violationType: Audits_AttributionReportingIssueType;
  request?: Audits_AffectedRequest;
  violatingNodeId?: DOM_BackendNodeId;
  invalidParameter?: string;
};

/**
 * Details for issues about documents in Quirks Mode
 * or Limited Quirks Mode that affects page layouting.
 */
export type Audits_QuirksModeIssueDetails = {
  /**
   * If false, it means the document's mode is "quirks"
   * instead of "limited-quirks".
   */
  isLimitedQuirksMode: boolean;
  documentNodeId: DOM_BackendNodeId;
  url: string;
  frameId: Page_FrameId;
  loaderId: Network_LoaderId;
};

/**
 * @deprecated
 */
export type Audits_NavigatorUserAgentIssueDetails = {
  url: string;
  location?: Audits_SourceCodeLocation;
};

export type Audits_GenericIssueErrorType =
  | "CrossOriginPortalPostMessageError"
  | "FormLabelForNameError"
  | "FormDuplicateIdForInputError"
  | "FormInputWithNoLabelError"
  | "FormAutocompleteAttributeEmptyError"
  | "FormEmptyIdAndNameAttributesForInputError"
  | "FormAriaLabelledByToNonExistingId"
  | "FormInputAssignedAutocompleteValueToIdOrNameAttributeError"
  | "FormLabelHasNeitherForNorNestedInput"
  | "FormLabelForMatchesNonExistingIdError"
  | "FormInputHasWrongButWellIntendedAutocompleteValueError"
  | "ResponseWasBlockedByORB";

/**
 * Depending on the concrete errorType, different properties are set.
 */
export type Audits_GenericIssueDetails = {
  /**
   * Issues with the same errorType are aggregated in the frontend.
   */
  errorType: Audits_GenericIssueErrorType;
  frameId?: Page_FrameId;
  violatingNodeId?: DOM_BackendNodeId;
  violatingNodeAttribute?: string;
  request?: Audits_AffectedRequest;
};

/**
 * This issue tracks information needed to print a deprecation message.
 * https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/frame/third_party/blink/renderer/core/frame/deprecation/README.md
 */
export type Audits_DeprecationIssueDetails = {
  affectedFrame?: Audits_AffectedFrame;
  sourceCodeLocation: Audits_SourceCodeLocation;
  /**
   * One of the deprecation names from third_party/blink/renderer/core/frame/deprecation/deprecation.json5
   */
  type: string;
};

/**
 * This issue warns about sites in the redirect chain of a finished navigation
 * that may be flagged as trackers and have their state cleared if they don't
 * receive a user interaction. Note that in this context 'site' means eTLD+1.
 * For example, if the URL `https://example.test:80/bounce` was in the
 * redirect chain, the site reported would be `example.test`.
 */
export type Audits_BounceTrackingIssueDetails = {
  trackingSites: string[];
};

export type Audits_ClientHintIssueReason =
  | "MetaTagAllowListInvalidOrigin"
  | "MetaTagModifiedHTML";

export type Audits_FederatedAuthRequestIssueDetails = {
  federatedAuthRequestIssueReason: Audits_FederatedAuthRequestIssueReason;
};

/**
 * Represents the failure reason when a federated authentication reason fails.
 * Should be updated alongside RequestIdTokenStatus in
 * third_party/blink/public/mojom/devtools/inspector_issue.mojom to include
 * all cases except for success.
 */
export type Audits_FederatedAuthRequestIssueReason =
  | "ShouldEmbargo"
  | "TooManyRequests"
  | "WellKnownHttpNotFound"
  | "WellKnownNoResponse"
  | "WellKnownInvalidResponse"
  | "WellKnownListEmpty"
  | "WellKnownInvalidContentType"
  | "ConfigNotInWellKnown"
  | "WellKnownTooBig"
  | "ConfigHttpNotFound"
  | "ConfigNoResponse"
  | "ConfigInvalidResponse"
  | "ConfigInvalidContentType"
  | "ClientMetadataHttpNotFound"
  | "ClientMetadataNoResponse"
  | "ClientMetadataInvalidResponse"
  | "ClientMetadataInvalidContentType"
  | "DisabledInSettings"
  | "ErrorFetchingSignin"
  | "InvalidSigninResponse"
  | "AccountsHttpNotFound"
  | "AccountsNoResponse"
  | "AccountsInvalidResponse"
  | "AccountsListEmpty"
  | "AccountsInvalidContentType"
  | "IdTokenHttpNotFound"
  | "IdTokenNoResponse"
  | "IdTokenInvalidResponse"
  | "IdTokenInvalidRequest"
  | "IdTokenInvalidContentType"
  | "ErrorIdToken"
  | "Canceled"
  | "RpPageNotVisible"
  | "SilentMediationFailure"
  | "ThirdPartyCookiesBlocked";

export type Audits_FederatedAuthUserInfoRequestIssueDetails = {
  federatedAuthUserInfoRequestIssueReason:
    Audits_FederatedAuthUserInfoRequestIssueReason;
};

/**
 * Represents the failure reason when a getUserInfo() call fails.
 * Should be updated alongside FederatedAuthUserInfoRequestResult in
 * third_party/blink/public/mojom/devtools/inspector_issue.mojom.
 */
export type Audits_FederatedAuthUserInfoRequestIssueReason =
  | "NotSameOrigin"
  | "NotIframe"
  | "NotPotentiallyTrustworthy"
  | "NoApiPermission"
  | "NotSignedInWithIdp"
  | "NoAccountSharingPermission"
  | "InvalidConfigOrWellKnown"
  | "InvalidAccountsResponse"
  | "NoReturningUserFromFetchedAccounts";

/**
 * This issue tracks client hints related issues. It's used to deprecate old
 * features, encourage the use of new ones, and provide general guidance.
 */
export type Audits_ClientHintIssueDetails = {
  sourceCodeLocation: Audits_SourceCodeLocation;
  clientHintIssueReason: Audits_ClientHintIssueReason;
};

export type Audits_FailedRequestInfo = {
  /**
   * The URL that failed to load.
   */
  url: string;
  /**
   * The failure message for the failed request.
   */
  failureMessage: string;
  requestId?: Network_RequestId;
};

export type Audits_StyleSheetLoadingIssueReason =
  | "LateImportRule"
  | "RequestFailed";

/**
 * This issue warns when a referenced stylesheet couldn't be loaded.
 */
export type Audits_StylesheetLoadingIssueDetails = {
  /**
   * Source code position that referenced the failing stylesheet.
   */
  sourceCodeLocation: Audits_SourceCodeLocation;
  /**
   * Reason why the stylesheet couldn't be loaded.
   */
  styleSheetLoadingIssueReason: Audits_StyleSheetLoadingIssueReason;
  /**
   * Contains additional info when the failure was due to a request.
   */
  failedRequestInfo?: Audits_FailedRequestInfo;
};

/**
 * A unique identifier for the type of issue. Each type may use one of the
 * optional fields in InspectorIssueDetails to convey more specific
 * information about the kind of issue.
 */
export type Audits_InspectorIssueCode =
  | "CookieIssue"
  | "MixedContentIssue"
  | "BlockedByResponseIssue"
  | "HeavyAdIssue"
  | "ContentSecurityPolicyIssue"
  | "SharedArrayBufferIssue"
  | "LowTextContrastIssue"
  | "CorsIssue"
  | "AttributionReportingIssue"
  | "QuirksModeIssue"
  | "NavigatorUserAgentIssue"
  | "GenericIssue"
  | "DeprecationIssue"
  | "ClientHintIssue"
  | "FederatedAuthRequestIssue"
  | "BounceTrackingIssue"
  | "StylesheetLoadingIssue"
  | "FederatedAuthUserInfoRequestIssue";

/**
 * This struct holds a list of optional fields with additional information
 * specific to the kind of issue. When adding a new issue code, please also
 * add a new optional field to this type.
 */
export type Audits_InspectorIssueDetails = {
  cookieIssueDetails?: Audits_CookieIssueDetails;
  mixedContentIssueDetails?: Audits_MixedContentIssueDetails;
  blockedByResponseIssueDetails?: Audits_BlockedByResponseIssueDetails;
  heavyAdIssueDetails?: Audits_HeavyAdIssueDetails;
  contentSecurityPolicyIssueDetails?: Audits_ContentSecurityPolicyIssueDetails;
  sharedArrayBufferIssueDetails?: Audits_SharedArrayBufferIssueDetails;
  lowTextContrastIssueDetails?: Audits_LowTextContrastIssueDetails;
  corsIssueDetails?: Audits_CorsIssueDetails;
  attributionReportingIssueDetails?: Audits_AttributionReportingIssueDetails;
  quirksModeIssueDetails?: Audits_QuirksModeIssueDetails;
  /**
   * @deprecated
   */
  navigatorUserAgentIssueDetails?: Audits_NavigatorUserAgentIssueDetails;
  genericIssueDetails?: Audits_GenericIssueDetails;
  deprecationIssueDetails?: Audits_DeprecationIssueDetails;
  clientHintIssueDetails?: Audits_ClientHintIssueDetails;
  federatedAuthRequestIssueDetails?: Audits_FederatedAuthRequestIssueDetails;
  bounceTrackingIssueDetails?: Audits_BounceTrackingIssueDetails;
  stylesheetLoadingIssueDetails?: Audits_StylesheetLoadingIssueDetails;
  federatedAuthUserInfoRequestIssueDetails?:
    Audits_FederatedAuthUserInfoRequestIssueDetails;
};

/**
 * A unique id for a DevTools inspector issue. Allows other entities (e.g.
 * exceptions, CDP message, console messages, etc.) to reference an issue.
 */
export type Audits_IssueId = string;

/**
 * An inspector issue reported from the back-end.
 */
export type Audits_InspectorIssue = {
  code: Audits_InspectorIssueCode;
  details: Audits_InspectorIssueDetails;
  /**
   * A unique id for this issue. May be omitted if no other entity (e.g.
   * exception, CDP message, etc.) is referencing this issue.
   */
  issueId?: Audits_IssueId;
};

// ----------------- Autofill -----------------

export type Autofill_CreditCard = {
  /**
   * 16-digit credit card number.
   */
  number: string;
  /**
   * Name of the credit card owner.
   */
  name: string;
  /**
   * 2-digit expiry month.
   */
  expiryMonth: string;
  /**
   * 4-digit expiry year.
   */
  expiryYear: string;
  /**
   * 3-digit card verification code.
   */
  cvc: string;
};

export type Autofill_AddressField = {
  /**
   * address field name, for example GIVEN_NAME.
   */
  name: string;
  /**
   * address field name, for example Jon Doe.
   */
  value: string;
};

export type Autofill_Address = {
  /**
   * fields and values defining a test address.
   */
  fields: Autofill_AddressField[];
};

// ----------------- BackgroundService -----------------

/**
 * The Background Service that will be associated with the commands/events.
 * Every Background Service operates independently, but they share the same
 * API.
 */
export type BackgroundService_ServiceName =
  | "backgroundFetch"
  | "backgroundSync"
  | "pushMessaging"
  | "notifications"
  | "paymentHandler"
  | "periodicBackgroundSync";

/**
 * A key-value pair for additional event information to pass along.
 */
export type BackgroundService_EventMetadata = {
  key: string;
  value: string;
};

export type BackgroundService_BackgroundServiceEvent = {
  /**
   * Timestamp of the event (in seconds).
   */
  timestamp: Network_TimeSinceEpoch;
  /**
   * The origin this event belongs to.
   */
  origin: string;
  /**
   * The Service Worker ID that initiated the event.
   */
  serviceWorkerRegistrationId: ServiceWorker_RegistrationID;
  /**
   * The Background Service this event belongs to.
   */
  service: BackgroundService_ServiceName;
  /**
   * A description of the event.
   */
  eventName: string;
  /**
   * An identifier that groups related events together.
   */
  instanceId: string;
  /**
   * A list of event-specific information.
   */
  eventMetadata: BackgroundService_EventMetadata[];
  /**
   * Storage key this event belongs to.
   */
  storageKey: string;
};

// ----------------- Browser -----------------

/**
 * @experimental
 */
export type Browser_BrowserContextID = string;

/**
 * @experimental
 */
export type Browser_WindowID = number;

/**
 * @experimental
 * The state of the browser window.
 */
export type Browser_WindowState =
  | "normal"
  | "minimized"
  | "maximized"
  | "fullscreen";

/**
 * @experimental
 * Browser window bounds information
 */
export type Browser_Bounds = {
  /**
   * The offset from the left edge of the screen to the window in pixels.
   */
  left?: number;
  /**
   * The offset from the top edge of the screen to the window in pixels.
   */
  top?: number;
  /**
   * The window width in pixels.
   */
  width?: number;
  /**
   * The window height in pixels.
   */
  height?: number;
  /**
   * The window state. Default to normal.
   */
  windowState?: Browser_WindowState;
};

/**
 * @experimental
 */
export type Browser_PermissionType =
  | "accessibilityEvents"
  | "audioCapture"
  | "backgroundSync"
  | "backgroundFetch"
  | "clipboardReadWrite"
  | "clipboardSanitizedWrite"
  | "displayCapture"
  | "durableStorage"
  | "flash"
  | "geolocation"
  | "idleDetection"
  | "localFonts"
  | "midi"
  | "midiSysex"
  | "nfc"
  | "notifications"
  | "paymentHandler"
  | "periodicBackgroundSync"
  | "protectedMediaIdentifier"
  | "sensors"
  | "storageAccess"
  | "topLevelStorageAccess"
  | "videoCapture"
  | "videoCapturePanTiltZoom"
  | "wakeLockScreen"
  | "wakeLockSystem"
  | "windowManagement";

/**
 * @experimental
 */
export type Browser_PermissionSetting = "granted" | "denied" | "prompt";

/**
 * @experimental
 * Definition of PermissionDescriptor defined in the Permissions API:
 * https://w3c.github.io/permissions/#dictdef-permissiondescriptor.
 */
export type Browser_PermissionDescriptor = {
  /**
   * Name of permission.
   * See https://cs.chromium.org/chromium/src/third_party/blink/renderer/modules/permissions/permission_descriptor.idl for valid permission names.
   */
  name: string;
  /**
   * For "midi" permission, may also specify sysex control.
   */
  sysex?: boolean;
  /**
   * For "push" permission, may specify userVisibleOnly.
   * Note that userVisibleOnly = true is the only currently supported type.
   */
  userVisibleOnly?: boolean;
  /**
   * For "clipboard" permission, may specify allowWithoutSanitization.
   */
  allowWithoutSanitization?: boolean;
  /**
   * For "camera" permission, may specify panTiltZoom.
   */
  panTiltZoom?: boolean;
};

/**
 * @experimental
 * Browser command ids used by executeBrowserCommand.
 */
export type Browser_BrowserCommandId = "openTabSearch" | "closeTabSearch";

/**
 * @experimental
 * Chrome histogram bucket.
 */
export type Browser_Bucket = {
  /**
   * Minimum value (inclusive).
   */
  low: number;
  /**
   * Maximum value (exclusive).
   */
  high: number;
  /**
   * Number of samples.
   */
  count: number;
};

/**
 * @experimental
 * Chrome histogram.
 */
export type Browser_Histogram = {
  /**
   * Name.
   */
  name: string;
  /**
   * Sum of sample values.
   */
  sum: number;
  /**
   * Total number of samples.
   */
  count: number;
  /**
   * Buckets.
   */
  buckets: Browser_Bucket[];
};

// ----------------- CSS -----------------

export type CSS_StyleSheetId = string;

/**
 * Stylesheet type: "injected" for stylesheets injected via extension, "user-agent" for user-agent
 * stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via
 * inspector" rules), "regular" for regular stylesheets.
 */
export type CSS_StyleSheetOrigin =
  | "injected"
  | "user-agent"
  | "inspector"
  | "regular";

/**
 * CSS rule collection for a single pseudo style.
 */
export type CSS_PseudoElementMatches = {
  /**
   * Pseudo element type.
   */
  pseudoType: DOM_PseudoType;
  /**
   * Pseudo element custom ident.
   */
  pseudoIdentifier?: string;
  /**
   * Matches of CSS rules applicable to the pseudo style.
   */
  matches: CSS_RuleMatch[];
};

/**
 * Inherited CSS rule collection from ancestor node.
 */
export type CSS_InheritedStyleEntry = {
  /**
   * The ancestor node's inline style, if any, in the style inheritance chain.
   */
  inlineStyle?: CSS_CSSStyle;
  /**
   * Matches of CSS rules matching the ancestor node in the style inheritance chain.
   */
  matchedCSSRules: CSS_RuleMatch[];
};

/**
 * Inherited pseudo element matches from pseudos of an ancestor node.
 */
export type CSS_InheritedPseudoElementMatches = {
  /**
   * Matches of pseudo styles from the pseudos of an ancestor node.
   */
  pseudoElements: CSS_PseudoElementMatches[];
};

/**
 * Match data for a CSS rule.
 */
export type CSS_RuleMatch = {
  /**
   * CSS rule in the match.
   */
  rule: CSS_CSSRule;
  /**
   * Matching selector indices in the rule's selectorList selectors (0-based).
   */
  matchingSelectors: number[];
};

/**
 * Data for a simple selector (these are delimited by commas in a selector list).
 */
export type CSS_Value = {
  /**
   * Value text.
   */
  text: string;
  /**
   * Value range in the underlying resource (if available).
   */
  range?: CSS_SourceRange;
  /**
   * @experimental
   * Specificity of the selector.
   */
  specificity?: CSS_Specificity;
};

/**
 * @experimental
 * Specificity:
 * https://drafts.csswg.org/selectors/#specificity-rules
 */
export type CSS_Specificity = {
  /**
   * The a component, which represents the number of ID selectors.
   */
  a: number;
  /**
   * The b component, which represents the number of class selectors, attributes selectors, and
   * pseudo-classes.
   */
  b: number;
  /**
   * The c component, which represents the number of type selectors and pseudo-elements.
   */
  c: number;
};

/**
 * Selector list data.
 */
export type CSS_SelectorList = {
  /**
   * Selectors in the list.
   */
  selectors: CSS_Value[];
  /**
   * Rule selector text.
   */
  text: string;
};

/**
 * CSS stylesheet metainformation.
 */
export type CSS_CSSStyleSheetHeader = {
  /**
   * The stylesheet identifier.
   */
  styleSheetId: CSS_StyleSheetId;
  /**
   * Owner frame identifier.
   */
  frameId: Page_FrameId;
  /**
   * Stylesheet resource URL. Empty if this is a constructed stylesheet created using
   * new CSSStyleSheet() (but non-empty if this is a constructed sylesheet imported
   * as a CSS module script).
   */
  sourceURL: string;
  /**
   * URL of source map associated with the stylesheet (if any).
   */
  sourceMapURL?: string;
  /**
   * Stylesheet origin.
   */
  origin: CSS_StyleSheetOrigin;
  /**
   * Stylesheet title.
   */
  title: string;
  /**
   * The backend id for the owner node of the stylesheet.
   */
  ownerNode?: DOM_BackendNodeId;
  /**
   * Denotes whether the stylesheet is disabled.
   */
  disabled: boolean;
  /**
   * Whether the sourceURL field value comes from the sourceURL comment.
   */
  hasSourceURL?: boolean;
  /**
   * Whether this stylesheet is created for STYLE tag by parser. This flag is not set for
   * document.written STYLE tags.
   */
  isInline: boolean;
  /**
   * Whether this stylesheet is mutable. Inline stylesheets become mutable
   * after they have been modified via CSSOM API.
   * `<link>` element's stylesheets become mutable only if DevTools modifies them.
   * Constructed stylesheets (new CSSStyleSheet()) are mutable immediately after creation.
   */
  isMutable: boolean;
  /**
   * True if this stylesheet is created through new CSSStyleSheet() or imported as a
   * CSS module script.
   */
  isConstructed: boolean;
  /**
   * Line offset of the stylesheet within the resource (zero based).
   */
  startLine: number;
  /**
   * Column offset of the stylesheet within the resource (zero based).
   */
  startColumn: number;
  /**
   * Size of the content (in characters).
   */
  length: number;
  /**
   * Line offset of the end of the stylesheet within the resource (zero based).
   */
  endLine: number;
  /**
   * Column offset of the end of the stylesheet within the resource (zero based).
   */
  endColumn: number;
  /**
   * @experimental
   * If the style sheet was loaded from a network resource, this indicates when the resource failed to load
   */
  loadingFailed?: boolean;
};

/**
 * CSS rule representation.
 */
export type CSS_CSSRule = {
  /**
   * The css style sheet identifier (absent for user agent stylesheet and user-specified
   * stylesheet rules) this rule came from.
   */
  styleSheetId?: CSS_StyleSheetId;
  /**
   * Rule selector data.
   */
  selectorList: CSS_SelectorList;
  /**
   * @experimental
   * Array of selectors from ancestor style rules, sorted by distance from the current rule.
   */
  nestingSelectors?: string[];
  /**
   * Parent stylesheet's origin.
   */
  origin: CSS_StyleSheetOrigin;
  /**
   * Associated style declaration.
   */
  style: CSS_CSSStyle;
  /**
   * Media list array (for rules involving media queries). The array enumerates media queries
   * starting with the innermost one, going outwards.
   */
  media?: CSS_CSSMedia[];
  /**
   * @experimental
   * Container query list array (for rules involving container queries).
   * The array enumerates container queries starting with the innermost one, going outwards.
   */
  containerQueries?: CSS_CSSContainerQuery[];
  /**
   * @experimental
   * @supports CSS at-rule array.
   * The array enumerates @supports at-rules starting with the innermost one, going outwards.
   */
  supports?: CSS_CSSSupports[];
  /**
   * @experimental
   * Cascade layer array. Contains the layer hierarchy that this rule belongs to starting
   * with the innermost layer and going outwards.
   */
  layers?: CSS_CSSLayer[];
  /**
   * @experimental
   * @scope CSS at-rule array.
   * The array enumerates @scope at-rules starting with the innermost one, going outwards.
   */
  scopes?: CSS_CSSScope[];
  /**
   * @experimental
   * The array keeps the types of ancestor CSSRules from the innermost going outwards.
   */
  ruleTypes?: CSS_CSSRuleType[];
};

/**
 * @experimental
 * Enum indicating the type of a CSS rule, used to represent the order of a style rule's ancestors.
 * This list only contains rule types that are collected during the ancestor rule collection.
 */
export type CSS_CSSRuleType =
  | "MediaRule"
  | "SupportsRule"
  | "ContainerRule"
  | "LayerRule"
  | "ScopeRule"
  | "StyleRule";

/**
 * CSS coverage information.
 */
export type CSS_RuleUsage = {
  /**
   * The css style sheet identifier (absent for user agent stylesheet and user-specified
   * stylesheet rules) this rule came from.
   */
  styleSheetId: CSS_StyleSheetId;
  /**
   * Offset of the start of the rule (including selector) from the beginning of the stylesheet.
   */
  startOffset: number;
  /**
   * Offset of the end of the rule body from the beginning of the stylesheet.
   */
  endOffset: number;
  /**
   * Indicates whether the rule was actually used by some element in the page.
   */
  used: boolean;
};

/**
 * Text range within a resource. All numbers are zero-based.
 */
export type CSS_SourceRange = {
  /**
   * Start line of range.
   */
  startLine: number;
  /**
   * Start column of range (inclusive).
   */
  startColumn: number;
  /**
   * End line of range
   */
  endLine: number;
  /**
   * End column of range (exclusive).
   */
  endColumn: number;
};

export type CSS_ShorthandEntry = {
  /**
   * Shorthand name.
   */
  name: string;
  /**
   * Shorthand value.
   */
  value: string;
  /**
   * Whether the property has "!important" annotation (implies `false` if absent).
   */
  important?: boolean;
};

export type CSS_CSSComputedStyleProperty = {
  /**
   * Computed style property name.
   */
  name: string;
  /**
   * Computed style property value.
   */
  value: string;
};

/**
 * CSS style representation.
 */
export type CSS_CSSStyle = {
  /**
   * The css style sheet identifier (absent for user agent stylesheet and user-specified
   * stylesheet rules) this rule came from.
   */
  styleSheetId?: CSS_StyleSheetId;
  /**
   * CSS properties in the style.
   */
  cssProperties: CSS_CSSProperty[];
  /**
   * Computed values for all shorthands found in the style.
   */
  shorthandEntries: CSS_ShorthandEntry[];
  /**
   * Style declaration text (if available).
   */
  cssText?: string;
  /**
   * Style declaration range in the enclosing stylesheet (if available).
   */
  range?: CSS_SourceRange;
};

/**
 * CSS property declaration data.
 */
export type CSS_CSSProperty = {
  /**
   * The property name.
   */
  name: string;
  /**
   * The property value.
   */
  value: string;
  /**
   * Whether the property has "!important" annotation (implies `false` if absent).
   */
  important?: boolean;
  /**
   * Whether the property is implicit (implies `false` if absent).
   */
  implicit?: boolean;
  /**
   * The full property text as specified in the style.
   */
  text?: string;
  /**
   * Whether the property is understood by the browser (implies `true` if absent).
   */
  parsedOk?: boolean;
  /**
   * Whether the property is disabled by the user (present for source-based properties only).
   */
  disabled?: boolean;
  /**
   * The entire property range in the enclosing style declaration (if available).
   */
  range?: CSS_SourceRange;
  /**
   * @experimental
   * Parsed longhand components of this property if it is a shorthand.
   * This field will be empty if the given property is not a shorthand.
   */
  longhandProperties?: CSS_CSSProperty[];
};

/**
 * CSS media rule descriptor.
 */
export type CSS_CSSMedia = {
  /**
   * Media query text.
   */
  text: string;
  /**
   * Source of the media query: "mediaRule" if specified by a @media rule, "importRule" if
   * specified by an @import rule, "linkedSheet" if specified by a "media" attribute in a linked
   * stylesheet's LINK tag, "inlineSheet" if specified by a "media" attribute in an inline
   * stylesheet's STYLE tag.
   */
  source: "mediaRule" | "importRule" | "linkedSheet" | "inlineSheet";
  /**
   * URL of the document containing the media query description.
   */
  sourceURL?: string;
  /**
   * The associated rule (@media or @import) header range in the enclosing stylesheet (if
   * available).
   */
  range?: CSS_SourceRange;
  /**
   * Identifier of the stylesheet containing this object (if exists).
   */
  styleSheetId?: CSS_StyleSheetId;
  /**
   * Array of media queries.
   */
  mediaList?: CSS_MediaQuery[];
};

/**
 * Media query descriptor.
 */
export type CSS_MediaQuery = {
  /**
   * Array of media query expressions.
   */
  expressions: CSS_MediaQueryExpression[];
  /**
   * Whether the media query condition is satisfied.
   */
  active: boolean;
};

/**
 * Media query expression descriptor.
 */
export type CSS_MediaQueryExpression = {
  /**
   * Media query expression value.
   */
  value: number;
  /**
   * Media query expression units.
   */
  unit: string;
  /**
   * Media query expression feature.
   */
  feature: string;
  /**
   * The associated range of the value text in the enclosing stylesheet (if available).
   */
  valueRange?: CSS_SourceRange;
  /**
   * Computed length of media query expression (if applicable).
   */
  computedLength?: number;
};

/**
 * @experimental
 * CSS container query rule descriptor.
 */
export type CSS_CSSContainerQuery = {
  /**
   * Container query text.
   */
  text: string;
  /**
   * The associated rule header range in the enclosing stylesheet (if
   * available).
   */
  range?: CSS_SourceRange;
  /**
   * Identifier of the stylesheet containing this object (if exists).
   */
  styleSheetId?: CSS_StyleSheetId;
  /**
   * Optional name for the container.
   */
  name?: string;
  /**
   * Optional physical axes queried for the container.
   */
  physicalAxes?: DOM_PhysicalAxes;
  /**
   * Optional logical axes queried for the container.
   */
  logicalAxes?: DOM_LogicalAxes;
};

/**
 * @experimental
 * CSS Supports at-rule descriptor.
 */
export type CSS_CSSSupports = {
  /**
   * Supports rule text.
   */
  text: string;
  /**
   * Whether the supports condition is satisfied.
   */
  active: boolean;
  /**
   * The associated rule header range in the enclosing stylesheet (if
   * available).
   */
  range?: CSS_SourceRange;
  /**
   * Identifier of the stylesheet containing this object (if exists).
   */
  styleSheetId?: CSS_StyleSheetId;
};

/**
 * @experimental
 * CSS Scope at-rule descriptor.
 */
export type CSS_CSSScope = {
  /**
   * Scope rule text.
   */
  text: string;
  /**
   * The associated rule header range in the enclosing stylesheet (if
   * available).
   */
  range?: CSS_SourceRange;
  /**
   * Identifier of the stylesheet containing this object (if exists).
   */
  styleSheetId?: CSS_StyleSheetId;
};

/**
 * @experimental
 * CSS Layer at-rule descriptor.
 */
export type CSS_CSSLayer = {
  /**
   * Layer name.
   */
  text: string;
  /**
   * The associated rule header range in the enclosing stylesheet (if
   * available).
   */
  range?: CSS_SourceRange;
  /**
   * Identifier of the stylesheet containing this object (if exists).
   */
  styleSheetId?: CSS_StyleSheetId;
};

/**
 * @experimental
 * CSS Layer data.
 */
export type CSS_CSSLayerData = {
  /**
   * Layer name.
   */
  name: string;
  /**
   * Direct sub-layers
   */
  subLayers?: CSS_CSSLayerData[];
  /**
   * Layer order. The order determines the order of the layer in the cascade order.
   * A higher number has higher priority in the cascade order.
   */
  order: number;
};

/**
 * Information about amount of glyphs that were rendered with given font.
 */
export type CSS_PlatformFontUsage = {
  /**
   * Font's family name reported by platform.
   */
  familyName: string;
  /**
   * Indicates if the font was downloaded or resolved locally.
   */
  isCustomFont: boolean;
  /**
   * Amount of glyphs that were rendered with this font.
   */
  glyphCount: number;
};

/**
 * Information about font variation axes for variable fonts
 */
export type CSS_FontVariationAxis = {
  /**
   * The font-variation-setting tag (a.k.a. "axis tag").
   */
  tag: string;
  /**
   * Human-readable variation name in the default language (normally, "en").
   */
  name: string;
  /**
   * The minimum value (inclusive) the font supports for this tag.
   */
  minValue: number;
  /**
   * The maximum value (inclusive) the font supports for this tag.
   */
  maxValue: number;
  /**
   * The default value.
   */
  defaultValue: number;
};

/**
 * Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions
 * and additional information such as platformFontFamily and fontVariationAxes.
 */
export type CSS_FontFace = {
  /**
   * The font-family.
   */
  fontFamily: string;
  /**
   * The font-style.
   */
  fontStyle: string;
  /**
   * The font-variant.
   */
  fontVariant: string;
  /**
   * The font-weight.
   */
  fontWeight: string;
  /**
   * The font-stretch.
   */
  fontStretch: string;
  /**
   * The font-display.
   */
  fontDisplay: string;
  /**
   * The unicode-range.
   */
  unicodeRange: string;
  /**
   * The src.
   */
  src: string;
  /**
   * The resolved platform font family
   */
  platformFontFamily: string;
  /**
   * Available variation settings (a.k.a. "axes").
   */
  fontVariationAxes?: CSS_FontVariationAxis[];
};

/**
 * CSS try rule representation.
 */
export type CSS_CSSTryRule = {
  /**
   * The css style sheet identifier (absent for user agent stylesheet and user-specified
   * stylesheet rules) this rule came from.
   */
  styleSheetId?: CSS_StyleSheetId;
  /**
   * Parent stylesheet's origin.
   */
  origin: CSS_StyleSheetOrigin;
  /**
   * Associated style declaration.
   */
  style: CSS_CSSStyle;
};

/**
 * CSS position-fallback rule representation.
 */
export type CSS_CSSPositionFallbackRule = {
  name: CSS_Value;
  /**
   * List of keyframes.
   */
  tryRules: CSS_CSSTryRule[];
};

/**
 * CSS keyframes rule representation.
 */
export type CSS_CSSKeyframesRule = {
  /**
   * Animation name.
   */
  animationName: CSS_Value;
  /**
   * List of keyframes.
   */
  keyframes: CSS_CSSKeyframeRule[];
};

/**
 * CSS keyframe rule representation.
 */
export type CSS_CSSKeyframeRule = {
  /**
   * The css style sheet identifier (absent for user agent stylesheet and user-specified
   * stylesheet rules) this rule came from.
   */
  styleSheetId?: CSS_StyleSheetId;
  /**
   * Parent stylesheet's origin.
   */
  origin: CSS_StyleSheetOrigin;
  /**
   * Associated key text.
   */
  keyText: CSS_Value;
  /**
   * Associated style declaration.
   */
  style: CSS_CSSStyle;
};

/**
 * A descriptor of operation to mutate style declaration text.
 */
export type CSS_StyleDeclarationEdit = {
  /**
   * The css style sheet identifier.
   */
  styleSheetId: CSS_StyleSheetId;
  /**
   * The range of the style text in the enclosing stylesheet.
   */
  range: CSS_SourceRange;
  /**
   * New style text.
   */
  text: string;
};

// ----------------- CacheStorage -----------------

/**
 * Unique identifier of the Cache object.
 */
export type CacheStorage_CacheId = string;

/**
 * type of HTTP response cached
 */
export type CacheStorage_CachedResponseType =
  | "basic"
  | "cors"
  | "default"
  | "error"
  | "opaqueResponse"
  | "opaqueRedirect";

/**
 * Data entry.
 */
export type CacheStorage_DataEntry = {
  /**
   * Request URL.
   */
  requestURL: string;
  /**
   * Request method.
   */
  requestMethod: string;
  /**
   * Request headers
   */
  requestHeaders: CacheStorage_Header[];
  /**
   * Number of seconds since epoch.
   */
  responseTime: number;
  /**
   * HTTP response status code.
   */
  responseStatus: number;
  /**
   * HTTP response status text.
   */
  responseStatusText: string;
  /**
   * HTTP response type
   */
  responseType: CacheStorage_CachedResponseType;
  /**
   * Response headers
   */
  responseHeaders: CacheStorage_Header[];
};

/**
 * Cache identifier.
 */
export type CacheStorage_Cache = {
  /**
   * An opaque unique id of the cache.
   */
  cacheId: CacheStorage_CacheId;
  /**
   * Security origin of the cache.
   */
  securityOrigin: string;
  /**
   * Storage key of the cache.
   */
  storageKey: string;
  /**
   * Storage bucket of the cache.
   */
  storageBucket?: Storage_StorageBucket;
  /**
   * The name of the cache.
   */
  cacheName: string;
};

export type CacheStorage_Header = {
  name: string;
  value: string;
};

/**
 * Cached response
 */
export type CacheStorage_CachedResponse = {
  /**
   * Entry content, base64-encoded.
   */
  body: string;
};

// ----------------- Cast -----------------

export type Cast_Sink = {
  name: string;
  id: string;
  /**
   * Text describing the current session. Present only if there is an active
   * session on the sink.
   */
  session?: string;
};

// ----------------- DOM -----------------

/**
 * Unique DOM node identifier.
 */
export type DOM_NodeId = number;

/**
 * Unique DOM node identifier used to reference a node that may not have been pushed to the
 * front-end.
 */
export type DOM_BackendNodeId = number;

/**
 * Backend node with a friendly name.
 */
export type DOM_BackendNode = {
  /**
   * `Node`'s nodeType.
   */
  nodeType: number;
  /**
   * `Node`'s nodeName.
   */
  nodeName: string;
  backendNodeId: DOM_BackendNodeId;
};

/**
 * Pseudo element type.
 */
export type DOM_PseudoType =
  | "first-line"
  | "first-letter"
  | "before"
  | "after"
  | "marker"
  | "backdrop"
  | "selection"
  | "target-text"
  | "spelling-error"
  | "grammar-error"
  | "highlight"
  | "first-line-inherited"
  | "scrollbar"
  | "scrollbar-thumb"
  | "scrollbar-button"
  | "scrollbar-track"
  | "scrollbar-track-piece"
  | "scrollbar-corner"
  | "resizer"
  | "input-list-button"
  | "view-transition"
  | "view-transition-group"
  | "view-transition-image-pair"
  | "view-transition-old"
  | "view-transition-new";

/**
 * Shadow root type.
 */
export type DOM_ShadowRootType = "user-agent" | "open" | "closed";

/**
 * Document compatibility mode.
 */
export type DOM_CompatibilityMode =
  | "QuirksMode"
  | "LimitedQuirksMode"
  | "NoQuirksMode";

/**
 * ContainerSelector physical axes
 */
export type DOM_PhysicalAxes = "Horizontal" | "Vertical" | "Both";

/**
 * ContainerSelector logical axes
 */
export type DOM_LogicalAxes = "Inline" | "Block" | "Both";

/**
 * DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.
 * DOMNode is a base node mirror type.
 */
export type DOM_Node = {
  /**
   * Node identifier that is passed into the rest of the DOM messages as the `nodeId`. Backend
   * will only push node with given `id` once. It is aware of all requested nodes and will only
   * fire DOM events for nodes known to the client.
   */
  nodeId: DOM_NodeId;
  /**
   * The id of the parent node if any.
   */
  parentId?: DOM_NodeId;
  /**
   * The BackendNodeId for this node.
   */
  backendNodeId: DOM_BackendNodeId;
  /**
   * `Node`'s nodeType.
   */
  nodeType: number;
  /**
   * `Node`'s nodeName.
   */
  nodeName: string;
  /**
   * `Node`'s localName.
   */
  localName: string;
  /**
   * `Node`'s nodeValue.
   */
  nodeValue: string;
  /**
   * Child count for `Container` nodes.
   */
  childNodeCount?: number;
  /**
   * Child nodes of this node when requested with children.
   */
  children?: DOM_Node[];
  /**
   * Attributes of the `Element` node in the form of flat array `[name1, value1, name2, value2]`.
   */
  attributes?: string[];
  /**
   * Document URL that `Document` or `FrameOwner` node points to.
   */
  documentURL?: string;
  /**
   * Base URL that `Document` or `FrameOwner` node uses for URL completion.
   */
  baseURL?: string;
  /**
   * `DocumentType`'s publicId.
   */
  publicId?: string;
  /**
   * `DocumentType`'s systemId.
   */
  systemId?: string;
  /**
   * `DocumentType`'s internalSubset.
   */
  internalSubset?: string;
  /**
   * `Document`'s XML version in case of XML documents.
   */
  xmlVersion?: string;
  /**
   * `Attr`'s name.
   */
  name?: string;
  /**
   * `Attr`'s value.
   */
  value?: string;
  /**
   * Pseudo element type for this node.
   */
  pseudoType?: DOM_PseudoType;
  /**
   * Pseudo element identifier for this node. Only present if there is a
   * valid pseudoType.
   */
  pseudoIdentifier?: string;
  /**
   * Shadow root type.
   */
  shadowRootType?: DOM_ShadowRootType;
  /**
   * Frame ID for frame owner elements.
   */
  frameId?: Page_FrameId;
  /**
   * Content document for frame owner elements.
   */
  contentDocument?: DOM_Node;
  /**
   * Shadow root list for given element host.
   */
  shadowRoots?: DOM_Node[];
  /**
   * Content document fragment for template elements.
   */
  templateContent?: DOM_Node;
  /**
   * Pseudo elements associated with this node.
   */
  pseudoElements?: DOM_Node[];
  /**
   * @deprecated
   * Deprecated, as the HTML Imports API has been removed (crbug.com/937746).
   * This property used to return the imported document for the HTMLImport links.
   * The property is always undefined now.
   */
  importedDocument?: DOM_Node;
  /**
   * Distributed nodes for given insertion point.
   */
  distributedNodes?: DOM_BackendNode[];
  /**
   * Whether the node is SVG.
   */
  isSVG?: boolean;
  compatibilityMode?: DOM_CompatibilityMode;
  assignedSlot?: DOM_BackendNode;
};

/**
 * A structure holding an RGBA color.
 */
export type DOM_RGBA = {
  /**
   * The red component, in the [0-255] range.
   */
  r: number;
  /**
   * The green component, in the [0-255] range.
   */
  g: number;
  /**
   * The blue component, in the [0-255] range.
   */
  b: number;
  /**
   * The alpha component, in the [0-1] range (default: 1).
   */
  a?: number;
};

/**
 * An array of quad vertices, x immediately followed by y for each point, points clock-wise.
 */
export type DOM_Quad = number[];

/**
 * Box model.
 */
export type DOM_BoxModel = {
  /**
   * Content box
   */
  content: DOM_Quad;
  /**
   * Padding box
   */
  padding: DOM_Quad;
  /**
   * Border box
   */
  border: DOM_Quad;
  /**
   * Margin box
   */
  margin: DOM_Quad;
  /**
   * Node width
   */
  width: number;
  /**
   * Node height
   */
  height: number;
  /**
   * Shape outside coordinates
   */
  shapeOutside?: DOM_ShapeOutsideInfo;
};

/**
 * CSS Shape Outside details.
 */
export type DOM_ShapeOutsideInfo = {
  /**
   * Shape bounds
   */
  bounds: DOM_Quad;
  /**
   * Shape coordinate details
   */
  shape: any[];
  /**
   * Margin shape bounds
   */
  marginShape: any[];
};

/**
 * Rectangle.
 */
export type DOM_Rect = {
  /**
   * X coordinate
   */
  x: number;
  /**
   * Y coordinate
   */
  y: number;
  /**
   * Rectangle width
   */
  width: number;
  /**
   * Rectangle height
   */
  height: number;
};

export type DOM_CSSComputedStyleProperty = {
  /**
   * Computed style property name.
   */
  name: string;
  /**
   * Computed style property value.
   */
  value: string;
};

// ----------------- DOMDebugger -----------------

/**
 * DOM breakpoint type.
 */
export type DOMDebugger_DOMBreakpointType =
  | "subtree-modified"
  | "attribute-modified"
  | "node-removed";

/**
 * @experimental
 * CSP Violation type.
 */
export type DOMDebugger_CSPViolationType =
  | "trustedtype-sink-violation"
  | "trustedtype-policy-violation";

/**
 * Object event listener.
 */
export type DOMDebugger_EventListener = {
  /**
   * `EventListener`'s type.
   */
  type: string;
  /**
   * `EventListener`'s useCapture.
   */
  useCapture: boolean;
  /**
   * `EventListener`'s passive flag.
   */
  passive: boolean;
  /**
   * `EventListener`'s once flag.
   */
  once: boolean;
  /**
   * Script id of the handler code.
   */
  scriptId: Runtime_ScriptId;
  /**
   * Line number in the script (0-based).
   */
  lineNumber: number;
  /**
   * Column number in the script (0-based).
   */
  columnNumber: number;
  /**
   * Event handler function value.
   */
  handler?: Runtime_RemoteObject;
  /**
   * Event original handler function value.
   */
  originalHandler?: Runtime_RemoteObject;
  /**
   * Node the listener is added to (if any).
   */
  backendNodeId?: DOM_BackendNodeId;
};

// ----------------- EventBreakpoints -----------------

// ----------------- DOMSnapshot -----------------

/**
 * A Node in the DOM tree.
 */
export type DOMSnapshot_DOMNode = {
  /**
   * `Node`'s nodeType.
   */
  nodeType: number;
  /**
   * `Node`'s nodeName.
   */
  nodeName: string;
  /**
   * `Node`'s nodeValue.
   */
  nodeValue: string;
  /**
   * Only set for textarea elements, contains the text value.
   */
  textValue?: string;
  /**
   * Only set for input elements, contains the input's associated text value.
   */
  inputValue?: string;
  /**
   * Only set for radio and checkbox input elements, indicates if the element has been checked
   */
  inputChecked?: boolean;
  /**
   * Only set for option elements, indicates if the element has been selected
   */
  optionSelected?: boolean;
  /**
   * `Node`'s id, corresponds to DOM.Node.backendNodeId.
   */
  backendNodeId: DOM_BackendNodeId;
  /**
   * The indexes of the node's child nodes in the `domNodes` array returned by `getSnapshot`, if
   * any.
   */
  childNodeIndexes?: number[];
  /**
   * Attributes of an `Element` node.
   */
  attributes?: DOMSnapshot_NameValue[];
  /**
   * Indexes of pseudo elements associated with this node in the `domNodes` array returned by
   * `getSnapshot`, if any.
   */
  pseudoElementIndexes?: number[];
  /**
   * The index of the node's related layout tree node in the `layoutTreeNodes` array returned by
   * `getSnapshot`, if any.
   */
  layoutNodeIndex?: number;
  /**
   * Document URL that `Document` or `FrameOwner` node points to.
   */
  documentURL?: string;
  /**
   * Base URL that `Document` or `FrameOwner` node uses for URL completion.
   */
  baseURL?: string;
  /**
   * Only set for documents, contains the document's content language.
   */
  contentLanguage?: string;
  /**
   * Only set for documents, contains the document's character set encoding.
   */
  documentEncoding?: string;
  /**
   * `DocumentType` node's publicId.
   */
  publicId?: string;
  /**
   * `DocumentType` node's systemId.
   */
  systemId?: string;
  /**
   * Frame ID for frame owner elements and also for the document node.
   */
  frameId?: Page_FrameId;
  /**
   * The index of a frame owner element's content document in the `domNodes` array returned by
   * `getSnapshot`, if any.
   */
  contentDocumentIndex?: number;
  /**
   * Type of a pseudo element node.
   */
  pseudoType?: DOM_PseudoType;
  /**
   * Shadow root type.
   */
  shadowRootType?: DOM_ShadowRootType;
  /**
   * Whether this DOM node responds to mouse clicks. This includes nodes that have had click
   * event listeners attached via JavaScript as well as anchor tags that naturally navigate when
   * clicked.
   */
  isClickable?: boolean;
  /**
   * Details of the node's event listeners, if any.
   */
  eventListeners?: DOMDebugger_EventListener[];
  /**
   * The selected url for nodes with a srcset attribute.
   */
  currentSourceURL?: string;
  /**
   * The url of the script (if any) that generates this node.
   */
  originURL?: string;
  /**
   * Scroll offsets, set when this node is a Document.
   */
  scrollOffsetX?: number;
  scrollOffsetY?: number;
};

/**
 * Details of post layout rendered text positions. The exact layout should not be regarded as
 * stable and may change between versions.
 */
export type DOMSnapshot_InlineTextBox = {
  /**
   * The bounding box in document coordinates. Note that scroll offset of the document is ignored.
   */
  boundingBox: DOM_Rect;
  /**
   * The starting index in characters, for this post layout textbox substring. Characters that
   * would be represented as a surrogate pair in UTF-16 have length 2.
   */
  startCharacterIndex: number;
  /**
   * The number of characters in this post layout textbox substring. Characters that would be
   * represented as a surrogate pair in UTF-16 have length 2.
   */
  numCharacters: number;
};

/**
 * Details of an element in the DOM tree with a LayoutObject.
 */
export type DOMSnapshot_LayoutTreeNode = {
  /**
   * The index of the related DOM node in the `domNodes` array returned by `getSnapshot`.
   */
  domNodeIndex: number;
  /**
   * The bounding box in document coordinates. Note that scroll offset of the document is ignored.
   */
  boundingBox: DOM_Rect;
  /**
   * Contents of the LayoutText, if any.
   */
  layoutText?: string;
  /**
   * The post-layout inline text nodes, if any.
   */
  inlineTextNodes?: DOMSnapshot_InlineTextBox[];
  /**
   * Index into the `computedStyles` array returned by `getSnapshot`.
   */
  styleIndex?: number;
  /**
   * Global paint order index, which is determined by the stacking order of the nodes. Nodes
   * that are painted together will have the same index. Only provided if includePaintOrder in
   * getSnapshot was true.
   */
  paintOrder?: number;
  /**
   * Set to true to indicate the element begins a new stacking context.
   */
  isStackingContext?: boolean;
};

/**
 * A subset of the full ComputedStyle as defined by the request whitelist.
 */
export type DOMSnapshot_ComputedStyle = {
  /**
   * Name/value pairs of computed style properties.
   */
  properties: DOMSnapshot_NameValue[];
};

/**
 * A name/value pair.
 */
export type DOMSnapshot_NameValue = {
  /**
   * Attribute/property name.
   */
  name: string;
  /**
   * Attribute/property value.
   */
  value: string;
};

/**
 * Index of the string in the strings table.
 */
export type DOMSnapshot_StringIndex = number;

/**
 * Index of the string in the strings table.
 */
export type DOMSnapshot_ArrayOfStrings = DOMSnapshot_StringIndex[];

/**
 * Data that is only present on rare nodes.
 */
export type DOMSnapshot_RareStringData = {
  index: number[];
  value: DOMSnapshot_StringIndex[];
};

export type DOMSnapshot_RareBooleanData = {
  index: number[];
};

export type DOMSnapshot_RareIntegerData = {
  index: number[];
  value: number[];
};

export type DOMSnapshot_Rectangle = number[];

/**
 * Document snapshot.
 */
export type DOMSnapshot_DocumentSnapshot = {
  /**
   * Document URL that `Document` or `FrameOwner` node points to.
   */
  documentURL: DOMSnapshot_StringIndex;
  /**
   * Document title.
   */
  title: DOMSnapshot_StringIndex;
  /**
   * Base URL that `Document` or `FrameOwner` node uses for URL completion.
   */
  baseURL: DOMSnapshot_StringIndex;
  /**
   * Contains the document's content language.
   */
  contentLanguage: DOMSnapshot_StringIndex;
  /**
   * Contains the document's character set encoding.
   */
  encodingName: DOMSnapshot_StringIndex;
  /**
   * `DocumentType` node's publicId.
   */
  publicId: DOMSnapshot_StringIndex;
  /**
   * `DocumentType` node's systemId.
   */
  systemId: DOMSnapshot_StringIndex;
  /**
   * Frame ID for frame owner elements and also for the document node.
   */
  frameId: DOMSnapshot_StringIndex;
  /**
   * A table with dom nodes.
   */
  nodes: DOMSnapshot_NodeTreeSnapshot;
  /**
   * The nodes in the layout tree.
   */
  layout: DOMSnapshot_LayoutTreeSnapshot;
  /**
   * The post-layout inline text nodes.
   */
  textBoxes: DOMSnapshot_TextBoxSnapshot;
  /**
   * Horizontal scroll offset.
   */
  scrollOffsetX?: number;
  /**
   * Vertical scroll offset.
   */
  scrollOffsetY?: number;
  /**
   * Document content width.
   */
  contentWidth?: number;
  /**
   * Document content height.
   */
  contentHeight?: number;
};

/**
 * Table containing nodes.
 */
export type DOMSnapshot_NodeTreeSnapshot = {
  /**
   * Parent node index.
   */
  parentIndex?: number[];
  /**
   * `Node`'s nodeType.
   */
  nodeType?: number[];
  /**
   * Type of the shadow root the `Node` is in. String values are equal to the `ShadowRootType` enum.
   */
  shadowRootType?: DOMSnapshot_RareStringData;
  /**
   * `Node`'s nodeName.
   */
  nodeName?: DOMSnapshot_StringIndex[];
  /**
   * `Node`'s nodeValue.
   */
  nodeValue?: DOMSnapshot_StringIndex[];
  /**
   * `Node`'s id, corresponds to DOM.Node.backendNodeId.
   */
  backendNodeId?: DOM_BackendNodeId[];
  /**
   * Attributes of an `Element` node. Flatten name, value pairs.
   */
  attributes?: DOMSnapshot_ArrayOfStrings[];
  /**
   * Only set for textarea elements, contains the text value.
   */
  textValue?: DOMSnapshot_RareStringData;
  /**
   * Only set for input elements, contains the input's associated text value.
   */
  inputValue?: DOMSnapshot_RareStringData;
  /**
   * Only set for radio and checkbox input elements, indicates if the element has been checked
   */
  inputChecked?: DOMSnapshot_RareBooleanData;
  /**
   * Only set for option elements, indicates if the element has been selected
   */
  optionSelected?: DOMSnapshot_RareBooleanData;
  /**
   * The index of the document in the list of the snapshot documents.
   */
  contentDocumentIndex?: DOMSnapshot_RareIntegerData;
  /**
   * Type of a pseudo element node.
   */
  pseudoType?: DOMSnapshot_RareStringData;
  /**
   * Pseudo element identifier for this node. Only present if there is a
   * valid pseudoType.
   */
  pseudoIdentifier?: DOMSnapshot_RareStringData;
  /**
   * Whether this DOM node responds to mouse clicks. This includes nodes that have had click
   * event listeners attached via JavaScript as well as anchor tags that naturally navigate when
   * clicked.
   */
  isClickable?: DOMSnapshot_RareBooleanData;
  /**
   * The selected url for nodes with a srcset attribute.
   */
  currentSourceURL?: DOMSnapshot_RareStringData;
  /**
   * The url of the script (if any) that generates this node.
   */
  originURL?: DOMSnapshot_RareStringData;
};

/**
 * Table of details of an element in the DOM tree with a LayoutObject.
 */
export type DOMSnapshot_LayoutTreeSnapshot = {
  /**
   * Index of the corresponding node in the `NodeTreeSnapshot` array returned by `captureSnapshot`.
   */
  nodeIndex: number[];
  /**
   * Array of indexes specifying computed style strings, filtered according to the `computedStyles` parameter passed to `captureSnapshot`.
   */
  styles: DOMSnapshot_ArrayOfStrings[];
  /**
   * The absolute position bounding box.
   */
  bounds: DOMSnapshot_Rectangle[];
  /**
   * Contents of the LayoutText, if any.
   */
  text: DOMSnapshot_StringIndex[];
  /**
   * Stacking context information.
   */
  stackingContexts: DOMSnapshot_RareBooleanData;
  /**
   * Global paint order index, which is determined by the stacking order of the nodes. Nodes
   * that are painted together will have the same index. Only provided if includePaintOrder in
   * captureSnapshot was true.
   */
  paintOrders?: number[];
  /**
   * The offset rect of nodes. Only available when includeDOMRects is set to true
   */
  offsetRects?: DOMSnapshot_Rectangle[];
  /**
   * The scroll rect of nodes. Only available when includeDOMRects is set to true
   */
  scrollRects?: DOMSnapshot_Rectangle[];
  /**
   * The client rect of nodes. Only available when includeDOMRects is set to true
   */
  clientRects?: DOMSnapshot_Rectangle[];
  /**
   * @experimental
   * The list of background colors that are blended with colors of overlapping elements.
   */
  blendedBackgroundColors?: DOMSnapshot_StringIndex[];
  /**
   * @experimental
   * The list of computed text opacities.
   */
  textColorOpacities?: number[];
};

/**
 * Table of details of the post layout rendered text positions. The exact layout should not be regarded as
 * stable and may change between versions.
 */
export type DOMSnapshot_TextBoxSnapshot = {
  /**
   * Index of the layout tree node that owns this box collection.
   */
  layoutIndex: number[];
  /**
   * The absolute position bounding box.
   */
  bounds: DOMSnapshot_Rectangle[];
  /**
   * The starting index in characters, for this post layout textbox substring. Characters that
   * would be represented as a surrogate pair in UTF-16 have length 2.
   */
  start: number[];
  /**
   * The number of characters in this post layout textbox substring. Characters that would be
   * represented as a surrogate pair in UTF-16 have length 2.
   */
  length: number[];
};

// ----------------- DOMStorage -----------------

export type DOMStorage_SerializedStorageKey = string;

/**
 * DOM Storage identifier.
 */
export type DOMStorage_StorageId = {
  /**
   * Security origin for the storage.
   */
  securityOrigin?: string;
  /**
   * Represents a key by which DOM Storage keys its CachedStorageAreas
   */
  storageKey?: DOMStorage_SerializedStorageKey;
  /**
   * Whether the storage is local storage (not session storage).
   */
  isLocalStorage: boolean;
};

/**
 * DOM Storage item.
 */
export type DOMStorage_Item = string[];

// ----------------- Database -----------------

/**
 * Unique identifier of Database object.
 */
export type Database_DatabaseId = string;

/**
 * Database object.
 */
export type Database_Database = {
  /**
   * Database ID.
   */
  id: Database_DatabaseId;
  /**
   * Database domain.
   */
  domain: string;
  /**
   * Database name.
   */
  name: string;
  /**
   * Database version.
   */
  version: string;
};

/**
 * Database error.
 */
export type Database_Error = {
  /**
   * Error message.
   */
  message: string;
  /**
   * Error code.
   */
  code: number;
};

// ----------------- DeviceOrientation -----------------

// ----------------- Emulation -----------------

/**
 * Screen orientation.
 */
export type Emulation_ScreenOrientation = {
  /**
   * Orientation type.
   */
  type:
    | "portraitPrimary"
    | "portraitSecondary"
    | "landscapePrimary"
    | "landscapeSecondary";
  /**
   * Orientation angle.
   */
  angle: number;
};

export type Emulation_DisplayFeature = {
  /**
   * Orientation of a display feature in relation to screen
   */
  orientation: "vertical" | "horizontal";
  /**
   * The offset from the screen origin in either the x (for vertical
   * orientation) or y (for horizontal orientation) direction.
   */
  offset: number;
  /**
   * A display feature may mask content such that it is not physically
   * displayed - this length along with the offset describes this area.
   * A display feature that only splits content will have a 0 mask_length.
   */
  maskLength: number;
};

export type Emulation_MediaFeature = {
  name: string;
  value: string;
};

/**
 * @experimental
 * advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to
 * allow the next delayed task (if any) to run; pause: The virtual time base may not advance;
 * pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending
 * resource fetches.
 */
export type Emulation_VirtualTimePolicy =
  | "advance"
  | "pause"
  | "pauseIfNetworkFetchesPending";

/**
 * @experimental
 * Used to specify User Agent Cient Hints to emulate. See https://wicg.github.io/ua-client-hints
 */
export type Emulation_UserAgentBrandVersion = {
  brand: string;
  version: string;
};

/**
 * @experimental
 * Used to specify User Agent Cient Hints to emulate. See https://wicg.github.io/ua-client-hints
 * Missing optional values will be filled in by the target with what it would normally use.
 */
export type Emulation_UserAgentMetadata = {
  /**
   * Brands appearing in Sec-CH-UA.
   */
  brands?: Emulation_UserAgentBrandVersion[];
  /**
   * Brands appearing in Sec-CH-UA-Full-Version-List.
   */
  fullVersionList?: Emulation_UserAgentBrandVersion[];
  /**
   * @deprecated
   */
  fullVersion?: string;
  platform: string;
  platformVersion: string;
  architecture: string;
  model: string;
  mobile: boolean;
  bitness?: string;
  wow64?: boolean;
};

/**
 * @experimental
 * Enum of image types that can be disabled.
 */
export type Emulation_DisabledImageType = "avif" | "webp";

// ----------------- HeadlessExperimental -----------------

/**
 * Encoding options for a screenshot.
 */
export type HeadlessExperimental_ScreenshotParams = {
  /**
   * Image compression format (defaults to png).
   */
  format?: "jpeg" | "png" | "webp";
  /**
   * Compression quality from range [0..100] (jpeg and webp only).
   */
  quality?: number;
  /**
   * Optimize image encoding for speed, not for resulting size (defaults to false)
   */
  optimizeForSpeed?: boolean;
};

// ----------------- IO -----------------

/**
 * This is either obtained from another method or specified as `blob:<uuid>` where
 * `<uuid>` is an UUID of a Blob.
 */
export type IO_StreamHandle = string;

// ----------------- IndexedDB -----------------

/**
 * Database with an array of object stores.
 */
export type IndexedDB_DatabaseWithObjectStores = {
  /**
   * Database name.
   */
  name: string;
  /**
   * Database version (type is not 'integer', as the standard
   * requires the version number to be 'unsigned long long')
   */
  version: number;
  /**
   * Object stores in this database.
   */
  objectStores: IndexedDB_ObjectStore[];
};

/**
 * Object store.
 */
export type IndexedDB_ObjectStore = {
  /**
   * Object store name.
   */
  name: string;
  /**
   * Object store key path.
   */
  keyPath: IndexedDB_KeyPath;
  /**
   * If true, object store has auto increment flag set.
   */
  autoIncrement: boolean;
  /**
   * Indexes in this object store.
   */
  indexes: IndexedDB_ObjectStoreIndex[];
};

/**
 * Object store index.
 */
export type IndexedDB_ObjectStoreIndex = {
  /**
   * Index name.
   */
  name: string;
  /**
   * Index key path.
   */
  keyPath: IndexedDB_KeyPath;
  /**
   * If true, index is unique.
   */
  unique: boolean;
  /**
   * If true, index allows multiple entries for a key.
   */
  multiEntry: boolean;
};

/**
 * Key.
 */
export type IndexedDB_Key = {
  /**
   * Key type.
   */
  type: "number" | "string" | "date" | "array";
  /**
   * Number value.
   */
  number?: number;
  /**
   * String value.
   */
  string?: string;
  /**
   * Date value.
   */
  date?: number;
  /**
   * Array value.
   */
  array?: IndexedDB_Key[];
};

/**
 * Key range.
 */
export type IndexedDB_KeyRange = {
  /**
   * Lower bound.
   */
  lower?: IndexedDB_Key;
  /**
   * Upper bound.
   */
  upper?: IndexedDB_Key;
  /**
   * If true lower bound is open.
   */
  lowerOpen: boolean;
  /**
   * If true upper bound is open.
   */
  upperOpen: boolean;
};

/**
 * Data entry.
 */
export type IndexedDB_DataEntry = {
  /**
   * Key object.
   */
  key: Runtime_RemoteObject;
  /**
   * Primary key object.
   */
  primaryKey: Runtime_RemoteObject;
  /**
   * Value object.
   */
  value: Runtime_RemoteObject;
};

/**
 * Key path.
 */
export type IndexedDB_KeyPath = {
  /**
   * Key path type.
   */
  type: "null" | "string" | "array";
  /**
   * String value.
   */
  string?: string;
  /**
   * Array value.
   */
  array?: string[];
};

// ----------------- Input -----------------

export type Input_TouchPoint = {
  /**
   * X coordinate of the event relative to the main frame's viewport in CSS pixels.
   */
  x: number;
  /**
   * Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
   * the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
   */
  y: number;
  /**
   * X radius of the touch area (default: 1.0).
   */
  radiusX?: number;
  /**
   * Y radius of the touch area (default: 1.0).
   */
  radiusY?: number;
  /**
   * Rotation angle (default: 0.0).
   */
  rotationAngle?: number;
  /**
   * Force (default: 1.0).
   */
  force?: number;
  /**
   * @experimental
   * The normalized tangential pressure, which has a range of [-1,1] (default: 0).
   */
  tangentialPressure?: number;
  /**
   * @experimental
   * The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0)
   */
  tiltX?: number;
  /**
   * @experimental
   * The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
   */
  tiltY?: number;
  /**
   * @experimental
   * The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
   */
  twist?: number;
  /**
   * Identifier used to track touch sources between events, must be unique within an event.
   */
  id?: number;
};

/**
 * @experimental
 */
export type Input_GestureSourceType = "default" | "touch" | "mouse";

export type Input_MouseButton =
  | "none"
  | "left"
  | "middle"
  | "right"
  | "back"
  | "forward";

/**
 * UTC time in seconds, counted from January 1, 1970.
 */
export type Input_TimeSinceEpoch = number;

/**
 * @experimental
 */
export type Input_DragDataItem = {
  /**
   * Mime type of the dragged data.
   */
  mimeType: string;
  /**
   * Depending of the value of `mimeType`, it contains the dragged link,
   * text, HTML markup or any other data.
   */
  data: string;
  /**
   * Title associated with a link. Only valid when `mimeType` == "text/uri-list".
   */
  title?: string;
  /**
   * Stores the base URL for the contained markup. Only valid when `mimeType`
   * == "text/html".
   */
  baseURL?: string;
};

/**
 * @experimental
 */
export type Input_DragData = {
  items: Input_DragDataItem[];
  /**
   * List of filenames that should be included when dropping
   */
  files?: string[];
  /**
   * Bit field representing allowed drag operations. Copy = 1, Link = 2, Move = 16
   */
  dragOperationsMask: number;
};

// ----------------- Inspector -----------------

// ----------------- LayerTree -----------------

/**
 * Unique Layer identifier.
 */
export type LayerTree_LayerId = string;

/**
 * Unique snapshot identifier.
 */
export type LayerTree_SnapshotId = string;

/**
 * Rectangle where scrolling happens on the main thread.
 */
export type LayerTree_ScrollRect = {
  /**
   * Rectangle itself.
   */
  rect: DOM_Rect;
  /**
   * Reason for rectangle to force scrolling on the main thread
   */
  type: "RepaintsOnScroll" | "TouchEventHandler" | "WheelEventHandler";
};

/**
 * Sticky position constraints.
 */
export type LayerTree_StickyPositionConstraint = {
  /**
   * Layout rectangle of the sticky element before being shifted
   */
  stickyBoxRect: DOM_Rect;
  /**
   * Layout rectangle of the containing block of the sticky element
   */
  containingBlockRect: DOM_Rect;
  /**
   * The nearest sticky layer that shifts the sticky box
   */
  nearestLayerShiftingStickyBox?: LayerTree_LayerId;
  /**
   * The nearest sticky layer that shifts the containing block
   */
  nearestLayerShiftingContainingBlock?: LayerTree_LayerId;
};

/**
 * Serialized fragment of layer picture along with its offset within the layer.
 */
export type LayerTree_PictureTile = {
  /**
   * Offset from owning layer left boundary
   */
  x: number;
  /**
   * Offset from owning layer top boundary
   */
  y: number;
  /**
   * Base64-encoded snapshot data.
   */
  picture: string;
};

/**
 * Information about a compositing layer.
 */
export type LayerTree_Layer = {
  /**
   * The unique id for this layer.
   */
  layerId: LayerTree_LayerId;
  /**
   * The id of parent (not present for root).
   */
  parentLayerId?: LayerTree_LayerId;
  /**
   * The backend id for the node associated with this layer.
   */
  backendNodeId?: DOM_BackendNodeId;
  /**
   * Offset from parent layer, X coordinate.
   */
  offsetX: number;
  /**
   * Offset from parent layer, Y coordinate.
   */
  offsetY: number;
  /**
   * Layer width.
   */
  width: number;
  /**
   * Layer height.
   */
  height: number;
  /**
   * Transformation matrix for layer, default is identity matrix
   */
  transform?: number[];
  /**
   * Transform anchor point X, absent if no transform specified
   */
  anchorX?: number;
  /**
   * Transform anchor point Y, absent if no transform specified
   */
  anchorY?: number;
  /**
   * Transform anchor point Z, absent if no transform specified
   */
  anchorZ?: number;
  /**
   * Indicates how many time this layer has painted.
   */
  paintCount: number;
  /**
   * Indicates whether this layer hosts any content, rather than being used for
   * transform/scrolling purposes only.
   */
  drawsContent: boolean;
  /**
   * Set if layer is not visible.
   */
  invisible?: boolean;
  /**
   * Rectangles scrolling on main thread only.
   */
  scrollRects?: LayerTree_ScrollRect[];
  /**
   * Sticky position constraint information
   */
  stickyPositionConstraint?: LayerTree_StickyPositionConstraint;
};

/**
 * Array of timings, one per paint step.
 */
export type LayerTree_PaintProfile = number[];

// ----------------- Log -----------------

/**
 * Log entry.
 */
export type Log_LogEntry = {
  /**
   * Log entry source.
   */
  source:
    | "xml"
    | "javascript"
    | "network"
    | "storage"
    | "appcache"
    | "rendering"
    | "security"
    | "deprecation"
    | "worker"
    | "violation"
    | "intervention"
    | "recommendation"
    | "other";
  /**
   * Log entry severity.
   */
  level: "verbose" | "info" | "warning" | "error";
  /**
   * Logged text.
   */
  text: string;
  category?: "cors";
  /**
   * Timestamp when this entry was added.
   */
  timestamp: Runtime_Timestamp;
  /**
   * URL of the resource if known.
   */
  url?: string;
  /**
   * Line number in the resource.
   */
  lineNumber?: number;
  /**
   * JavaScript stack trace.
   */
  stackTrace?: Runtime_StackTrace;
  /**
   * Identifier of the network request associated with this entry.
   */
  networkRequestId?: Network_RequestId;
  /**
   * Identifier of the worker associated with this entry.
   */
  workerId?: string;
  /**
   * Call arguments.
   */
  args?: Runtime_RemoteObject[];
};

/**
 * Violation configuration setting.
 */
export type Log_ViolationSetting = {
  /**
   * Violation type.
   */
  name:
    | "longTask"
    | "longLayout"
    | "blockedEvent"
    | "blockedParser"
    | "discouragedAPIUse"
    | "handler"
    | "recurringHandler";
  /**
   * Time threshold to trigger upon.
   */
  threshold: number;
};

// ----------------- Memory -----------------

/**
 * Memory pressure level.
 */
export type Memory_PressureLevel = "moderate" | "critical";

/**
 * Heap profile sample.
 */
export type Memory_SamplingProfileNode = {
  /**
   * Size of the sampled allocation.
   */
  size: number;
  /**
   * Total bytes attributed to this sample.
   */
  total: number;
  /**
   * Execution stack at the point of allocation.
   */
  stack: string[];
};

/**
 * Array of heap profile samples.
 */
export type Memory_SamplingProfile = {
  samples: Memory_SamplingProfileNode[];
  modules: Memory_Module[];
};

/**
 * Executable module information
 */
export type Memory_Module = {
  /**
   * Name of the module.
   */
  name: string;
  /**
   * UUID of the module.
   */
  uuid: string;
  /**
   * Base address where the module is loaded into memory. Encoded as a decimal
   * or hexadecimal (0x prefixed) string.
   */
  baseAddress: string;
  /**
   * Size of the module in bytes.
   */
  size: number;
};

// ----------------- Network -----------------

/**
 * Resource type as it was perceived by the rendering engine.
 */
export type Network_ResourceType =
  | "Document"
  | "Stylesheet"
  | "Image"
  | "Media"
  | "Font"
  | "Script"
  | "TextTrack"
  | "XHR"
  | "Fetch"
  | "Prefetch"
  | "EventSource"
  | "WebSocket"
  | "Manifest"
  | "SignedExchange"
  | "Ping"
  | "CSPViolationReport"
  | "Preflight"
  | "Other";

/**
 * Unique loader identifier.
 */
export type Network_LoaderId = string;

/**
 * Unique request identifier.
 */
export type Network_RequestId = string;

/**
 * Unique intercepted request identifier.
 */
export type Network_InterceptionId = string;

/**
 * Network level fetch failure reason.
 */
export type Network_ErrorReason =
  | "Failed"
  | "Aborted"
  | "TimedOut"
  | "AccessDenied"
  | "ConnectionClosed"
  | "ConnectionReset"
  | "ConnectionRefused"
  | "ConnectionAborted"
  | "ConnectionFailed"
  | "NameNotResolved"
  | "InternetDisconnected"
  | "AddressUnreachable"
  | "BlockedByClient"
  | "BlockedByResponse";

/**
 * UTC time in seconds, counted from January 1, 1970.
 */
export type Network_TimeSinceEpoch = number;

/**
 * Monotonically increasing time in seconds since an arbitrary point in the past.
 */
export type Network_MonotonicTime = number;

/**
 * Request / response headers as keys / values of JSON object.
 */
export type Network_Headers = object;

/**
 * The underlying connection technology that the browser is supposedly using.
 */
export type Network_ConnectionType =
  | "none"
  | "cellular2g"
  | "cellular3g"
  | "cellular4g"
  | "bluetooth"
  | "ethernet"
  | "wifi"
  | "wimax"
  | "other";

/**
 * Represents the cookie's 'SameSite' status:
 * https://tools.ietf.org/html/draft-west-first-party-cookies
 */
export type Network_CookieSameSite = "Strict" | "Lax" | "None";

/**
 * @experimental
 * Represents the cookie's 'Priority' status:
 * https://tools.ietf.org/html/draft-west-cookie-priority-00
 */
export type Network_CookiePriority = "Low" | "Medium" | "High";

/**
 * @experimental
 * Represents the source scheme of the origin that originally set the cookie.
 * A value of "Unset" allows protocol clients to emulate legacy cookie scope for the scheme.
 * This is a temporary ability and it will be removed in the future.
 */
export type Network_CookieSourceScheme = "Unset" | "NonSecure" | "Secure";

/**
 * Timing information for the request.
 */
export type Network_ResourceTiming = {
  /**
   * Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
   * milliseconds relatively to this requestTime.
   */
  requestTime: number;
  /**
   * Started resolving proxy.
   */
  proxyStart: number;
  /**
   * Finished resolving proxy.
   */
  proxyEnd: number;
  /**
   * Started DNS address resolve.
   */
  dnsStart: number;
  /**
   * Finished DNS address resolve.
   */
  dnsEnd: number;
  /**
   * Started connecting to the remote host.
   */
  connectStart: number;
  /**
   * Connected to the remote host.
   */
  connectEnd: number;
  /**
   * Started SSL handshake.
   */
  sslStart: number;
  /**
   * Finished SSL handshake.
   */
  sslEnd: number;
  /**
   * @experimental
   * Started running ServiceWorker.
   */
  workerStart: number;
  /**
   * @experimental
   * Finished Starting ServiceWorker.
   */
  workerReady: number;
  /**
   * @experimental
   * Started fetch event.
   */
  workerFetchStart: number;
  /**
   * @experimental
   * Settled fetch event respondWith promise.
   */
  workerRespondWithSettled: number;
  /**
   * Started sending request.
   */
  sendStart: number;
  /**
   * Finished sending request.
   */
  sendEnd: number;
  /**
   * @experimental
   * Time the server started pushing request.
   */
  pushStart: number;
  /**
   * @experimental
   * Time the server finished pushing request.
   */
  pushEnd: number;
  /**
   * @experimental
   * Started receiving response headers.
   */
  receiveHeadersStart: number;
  /**
   * Finished receiving response headers.
   */
  receiveHeadersEnd: number;
};

/**
 * Loading priority of a resource request.
 */
export type Network_ResourcePriority =
  | "VeryLow"
  | "Low"
  | "Medium"
  | "High"
  | "VeryHigh";

/**
 * Post data entry for HTTP request
 */
export type Network_PostDataEntry = {
  bytes?: string;
};

/**
 * HTTP request data.
 */
export type Network_Request = {
  /**
   * Request URL (without fragment).
   */
  url: string;
  /**
   * Fragment of the requested URL starting with hash, if present.
   */
  urlFragment?: string;
  /**
   * HTTP request method.
   */
  method: string;
  /**
   * HTTP request headers.
   */
  headers: Network_Headers;
  /**
   * HTTP POST request data.
   */
  postData?: string;
  /**
   * True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.
   */
  hasPostData?: boolean;
  /**
   * @experimental
   * Request body elements. This will be converted from base64 to binary
   */
  postDataEntries?: Network_PostDataEntry[];
  /**
   * The mixed content type of the request.
   */
  mixedContentType?: Security_MixedContentType;
  /**
   * Priority of the resource request at the time request is sent.
   */
  initialPriority: Network_ResourcePriority;
  /**
   * The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/
   */
  referrerPolicy:
    | "unsafe-url"
    | "no-referrer-when-downgrade"
    | "no-referrer"
    | "origin"
    | "origin-when-cross-origin"
    | "same-origin"
    | "strict-origin"
    | "strict-origin-when-cross-origin";
  /**
   * Whether is loaded via link preload.
   */
  isLinkPreload?: boolean;
  /**
   * @experimental
   * Set for requests when the TrustToken API is used. Contains the parameters
   * passed by the developer (e.g. via "fetch") as understood by the backend.
   */
  trustTokenParams?: Network_TrustTokenParams;
  /**
   * @experimental
   * True if this resource request is considered to be the 'same site' as the
   * request correspondinfg to the main frame.
   */
  isSameSite?: boolean;
};

/**
 * Details of a signed certificate timestamp (SCT).
 */
export type Network_SignedCertificateTimestamp = {
  /**
   * Validation status.
   */
  status: string;
  /**
   * Origin.
   */
  origin: string;
  /**
   * Log name / description.
   */
  logDescription: string;
  /**
   * Log ID.
   */
  logId: string;
  /**
   * Issuance date. Unlike TimeSinceEpoch, this contains the number of
   * milliseconds since January 1, 1970, UTC, not the number of seconds.
   */
  timestamp: number;
  /**
   * Hash algorithm.
   */
  hashAlgorithm: string;
  /**
   * Signature algorithm.
   */
  signatureAlgorithm: string;
  /**
   * Signature data.
   */
  signatureData: string;
};

/**
 * Security details about a request.
 */
export type Network_SecurityDetails = {
  /**
   * Protocol name (e.g. "TLS 1.2" or "QUIC").
   */
  protocol: string;
  /**
   * Key Exchange used by the connection, or the empty string if not applicable.
   */
  keyExchange: string;
  /**
   * (EC)DH group used by the connection, if applicable.
   */
  keyExchangeGroup?: string;
  /**
   * Cipher name.
   */
  cipher: string;
  /**
   * TLS MAC. Note that AEAD ciphers do not have separate MACs.
   */
  mac?: string;
  /**
   * Certificate ID value.
   */
  certificateId: Security_CertificateId;
  /**
   * Certificate subject name.
   */
  subjectName: string;
  /**
   * Subject Alternative Name (SAN) DNS names and IP addresses.
   */
  sanList: string[];
  /**
   * Name of the issuing CA.
   */
  issuer: string;
  /**
   * Certificate valid from date.
   */
  validFrom: Network_TimeSinceEpoch;
  /**
   * Certificate valid to (expiration) date
   */
  validTo: Network_TimeSinceEpoch;
  /**
   * List of signed certificate timestamps (SCTs).
   */
  signedCertificateTimestampList: Network_SignedCertificateTimestamp[];
  /**
   * Whether the request complied with Certificate Transparency policy
   */
  certificateTransparencyCompliance: Network_CertificateTransparencyCompliance;
  /**
   * The signature algorithm used by the server in the TLS server signature,
   * represented as a TLS SignatureScheme code point. Omitted if not
   * applicable or not known.
   */
  serverSignatureAlgorithm?: number;
  /**
   * Whether the connection used Encrypted ClientHello
   */
  encryptedClientHello: boolean;
};

/**
 * Whether the request complied with Certificate Transparency policy.
 */
export type Network_CertificateTransparencyCompliance =
  | "unknown"
  | "not-compliant"
  | "compliant";

/**
 * The reason why request was blocked.
 */
export type Network_BlockedReason =
  | "other"
  | "csp"
  | "mixed-content"
  | "origin"
  | "inspector"
  | "subresource-filter"
  | "content-type"
  | "coep-frame-resource-needs-coep-header"
  | "coop-sandboxed-iframe-cannot-navigate-to-coop-page"
  | "corp-not-same-origin"
  | "corp-not-same-origin-after-defaulted-to-same-origin-by-coep"
  | "corp-not-same-site";

/**
 * The reason why request was blocked.
 */
export type Network_CorsError =
  | "DisallowedByMode"
  | "InvalidResponse"
  | "WildcardOriginNotAllowed"
  | "MissingAllowOriginHeader"
  | "MultipleAllowOriginValues"
  | "InvalidAllowOriginValue"
  | "AllowOriginMismatch"
  | "InvalidAllowCredentials"
  | "CorsDisabledScheme"
  | "PreflightInvalidStatus"
  | "PreflightDisallowedRedirect"
  | "PreflightWildcardOriginNotAllowed"
  | "PreflightMissingAllowOriginHeader"
  | "PreflightMultipleAllowOriginValues"
  | "PreflightInvalidAllowOriginValue"
  | "PreflightAllowOriginMismatch"
  | "PreflightInvalidAllowCredentials"
  | "PreflightMissingAllowExternal"
  | "PreflightInvalidAllowExternal"
  | "PreflightMissingAllowPrivateNetwork"
  | "PreflightInvalidAllowPrivateNetwork"
  | "InvalidAllowMethodsPreflightResponse"
  | "InvalidAllowHeadersPreflightResponse"
  | "MethodDisallowedByPreflightResponse"
  | "HeaderDisallowedByPreflightResponse"
  | "RedirectContainsCredentials"
  | "InsecurePrivateNetwork"
  | "InvalidPrivateNetworkAccess"
  | "UnexpectedPrivateNetworkAccess"
  | "NoCorsRedirectModeNotFollow"
  | "PreflightMissingPrivateNetworkAccessId"
  | "PreflightMissingPrivateNetworkAccessName"
  | "PrivateNetworkAccessPermissionUnavailable"
  | "PrivateNetworkAccessPermissionDenied";

export type Network_CorsErrorStatus = {
  corsError: Network_CorsError;
  failedParameter: string;
};

/**
 * Source of serviceworker response.
 */
export type Network_ServiceWorkerResponseSource =
  | "cache-storage"
  | "http-cache"
  | "fallback-code"
  | "network";

/**
 * @experimental
 * Determines what type of Trust Token operation is executed and
 * depending on the type, some additional parameters. The values
 * are specified in third_party/blink/renderer/core/fetch/trust_token.idl.
 */
export type Network_TrustTokenParams = {
  operation: Network_TrustTokenOperationType;
  /**
   * Only set for "token-redemption" operation and determine whether
   * to request a fresh SRR or use a still valid cached SRR.
   */
  refreshPolicy: "UseCached" | "Refresh";
  /**
   * Origins of issuers from whom to request tokens or redemption
   * records.
   */
  issuers?: string[];
};

/**
 * @experimental
 */
export type Network_TrustTokenOperationType =
  | "Issuance"
  | "Redemption"
  | "Signing";

/**
 * @experimental
 * The reason why Chrome uses a specific transport protocol for HTTP semantics.
 */
export type Network_AlternateProtocolUsage =
  | "alternativeJobWonWithoutRace"
  | "alternativeJobWonRace"
  | "mainJobWonRace"
  | "mappingMissing"
  | "broken"
  | "dnsAlpnH3JobWonWithoutRace"
  | "dnsAlpnH3JobWonRace"
  | "unspecifiedReason";

/**
 * HTTP response data.
 */
export type Network_Response = {
  /**
   * Response URL. This URL can be different from CachedResource.url in case of redirect.
   */
  url: string;
  /**
   * HTTP response status code.
   */
  status: number;
  /**
   * HTTP response status text.
   */
  statusText: string;
  /**
   * HTTP response headers.
   */
  headers: Network_Headers;
  /**
   * @deprecated
   * HTTP response headers text. This has been replaced by the headers in Network.responseReceivedExtraInfo.
   */
  headersText?: string;
  /**
   * Resource mimeType as determined by the browser.
   */
  mimeType: string;
  /**
   * Refined HTTP request headers that were actually transmitted over the network.
   */
  requestHeaders?: Network_Headers;
  /**
   * @deprecated
   * HTTP request headers text. This has been replaced by the headers in Network.requestWillBeSentExtraInfo.
   */
  requestHeadersText?: string;
  /**
   * Specifies whether physical connection was actually reused for this request.
   */
  connectionReused: boolean;
  /**
   * Physical connection id that was actually used for this request.
   */
  connectionId: number;
  /**
   * Remote IP address.
   */
  remoteIPAddress?: string;
  /**
   * Remote port.
   */
  remotePort?: number;
  /**
   * Specifies that the request was served from the disk cache.
   */
  fromDiskCache?: boolean;
  /**
   * Specifies that the request was served from the ServiceWorker.
   */
  fromServiceWorker?: boolean;
  /**
   * Specifies that the request was served from the prefetch cache.
   */
  fromPrefetchCache?: boolean;
  /**
   * Total number of bytes received for this request so far.
   */
  encodedDataLength: number;
  /**
   * Timing information for the given request.
   */
  timing?: Network_ResourceTiming;
  /**
   * Response source of response from ServiceWorker.
   */
  serviceWorkerResponseSource?: Network_ServiceWorkerResponseSource;
  /**
   * The time at which the returned response was generated.
   */
  responseTime?: Network_TimeSinceEpoch;
  /**
   * Cache Storage Cache Name.
   */
  cacheStorageCacheName?: string;
  /**
   * Protocol used to fetch this request.
   */
  protocol?: string;
  /**
   * @experimental
   * The reason why Chrome uses a specific transport protocol for HTTP semantics.
   */
  alternateProtocolUsage?: Network_AlternateProtocolUsage;
  /**
   * Security state of the request resource.
   */
  securityState: Security_SecurityState;
  /**
   * Security details for the request.
   */
  securityDetails?: Network_SecurityDetails;
};

/**
 * WebSocket request data.
 */
export type Network_WebSocketRequest = {
  /**
   * HTTP request headers.
   */
  headers: Network_Headers;
};

/**
 * WebSocket response data.
 */
export type Network_WebSocketResponse = {
  /**
   * HTTP response status code.
   */
  status: number;
  /**
   * HTTP response status text.
   */
  statusText: string;
  /**
   * HTTP response headers.
   */
  headers: Network_Headers;
  /**
   * HTTP response headers text.
   */
  headersText?: string;
  /**
   * HTTP request headers.
   */
  requestHeaders?: Network_Headers;
  /**
   * HTTP request headers text.
   */
  requestHeadersText?: string;
};

/**
 * WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.
 */
export type Network_WebSocketFrame = {
  /**
   * WebSocket message opcode.
   */
  opcode: number;
  /**
   * WebSocket message mask.
   */
  mask: boolean;
  /**
   * WebSocket message payload data.
   * If the opcode is 1, this is a text message and payloadData is a UTF-8 string.
   * If the opcode isn't 1, then payloadData is a base64 encoded string representing binary data.
   */
  payloadData: string;
};

/**
 * Information about the cached resource.
 */
export type Network_CachedResource = {
  /**
   * Resource URL. This is the url of the original network request.
   */
  url: string;
  /**
   * Type of this resource.
   */
  type: Network_ResourceType;
  /**
   * Cached response data.
   */
  response?: Network_Response;
  /**
   * Cached response body size.
   */
  bodySize: number;
};

/**
 * Information about the request initiator.
 */
export type Network_Initiator = {
  /**
   * Type of this initiator.
   */
  type:
    | "parser"
    | "script"
    | "preload"
    | "SignedExchange"
    | "preflight"
    | "other";
  /**
   * Initiator JavaScript stack trace, set for Script only.
   */
  stack?: Runtime_StackTrace;
  /**
   * Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.
   */
  url?: string;
  /**
   * Initiator line number, set for Parser type or for Script type (when script is importing
   * module) (0-based).
   */
  lineNumber?: number;
  /**
   * Initiator column number, set for Parser type or for Script type (when script is importing
   * module) (0-based).
   */
  columnNumber?: number;
  /**
   * Set if another request triggered this request (e.g. preflight).
   */
  requestId?: Network_RequestId;
};

/**
 * Cookie object
 */
export type Network_Cookie = {
  /**
   * Cookie name.
   */
  name: string;
  /**
   * Cookie value.
   */
  value: string;
  /**
   * Cookie domain.
   */
  domain: string;
  /**
   * Cookie path.
   */
  path: string;
  /**
   * Cookie expiration date as the number of seconds since the UNIX epoch.
   */
  expires: number;
  /**
   * Cookie size.
   */
  size: number;
  /**
   * True if cookie is http-only.
   */
  httpOnly: boolean;
  /**
   * True if cookie is secure.
   */
  secure: boolean;
  /**
   * True in case of session cookie.
   */
  session: boolean;
  /**
   * Cookie SameSite type.
   */
  sameSite?: Network_CookieSameSite;
  /**
   * @experimental
   * Cookie Priority
   */
  priority: Network_CookiePriority;
  /**
   * @experimental
   * True if cookie is SameParty.
   */
  sameParty: boolean;
  /**
   * @experimental
   * Cookie source scheme type.
   */
  sourceScheme: Network_CookieSourceScheme;
  /**
   * @experimental
   * Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
   * An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
   * This is a temporary ability and it will be removed in the future.
   */
  sourcePort: number;
  /**
   * @experimental
   * Cookie partition key. The site of the top-level URL the browser was visiting at the start
   * of the request to the endpoint that set the cookie.
   */
  partitionKey?: string;
  /**
   * @experimental
   * True if cookie partition key is opaque.
   */
  partitionKeyOpaque?: boolean;
};

/**
 * @experimental
 * Types of reasons why a cookie may not be stored from a response.
 */
export type Network_SetCookieBlockedReason =
  | "SecureOnly"
  | "SameSiteStrict"
  | "SameSiteLax"
  | "SameSiteUnspecifiedTreatedAsLax"
  | "SameSiteNoneInsecure"
  | "UserPreferences"
  | "ThirdPartyBlockedInFirstPartySet"
  | "SyntaxError"
  | "SchemeNotSupported"
  | "OverwriteSecure"
  | "InvalidDomain"
  | "InvalidPrefix"
  | "UnknownError"
  | "SchemefulSameSiteStrict"
  | "SchemefulSameSiteLax"
  | "SchemefulSameSiteUnspecifiedTreatedAsLax"
  | "SamePartyFromCrossPartyContext"
  | "SamePartyConflictsWithOtherAttributes"
  | "NameValuePairExceedsMaxSize";

/**
 * @experimental
 * Types of reasons why a cookie may not be sent with a request.
 */
export type Network_CookieBlockedReason =
  | "SecureOnly"
  | "NotOnPath"
  | "DomainMismatch"
  | "SameSiteStrict"
  | "SameSiteLax"
  | "SameSiteUnspecifiedTreatedAsLax"
  | "SameSiteNoneInsecure"
  | "UserPreferences"
  | "ThirdPartyBlockedInFirstPartySet"
  | "UnknownError"
  | "SchemefulSameSiteStrict"
  | "SchemefulSameSiteLax"
  | "SchemefulSameSiteUnspecifiedTreatedAsLax"
  | "SamePartyFromCrossPartyContext"
  | "NameValuePairExceedsMaxSize";

/**
 * @experimental
 * A cookie which was not stored from a response with the corresponding reason.
 */
export type Network_BlockedSetCookieWithReason = {
  /**
   * The reason(s) this cookie was blocked.
   */
  blockedReasons: Network_SetCookieBlockedReason[];
  /**
   * The string representing this individual cookie as it would appear in the header.
   * This is not the entire "cookie" or "set-cookie" header which could have multiple cookies.
   */
  cookieLine: string;
  /**
   * The cookie object which represents the cookie which was not stored. It is optional because
   * sometimes complete cookie information is not available, such as in the case of parsing
   * errors.
   */
  cookie?: Network_Cookie;
};

/**
 * @experimental
 * A cookie with was not sent with a request with the corresponding reason.
 */
export type Network_BlockedCookieWithReason = {
  /**
   * The reason(s) the cookie was blocked.
   */
  blockedReasons: Network_CookieBlockedReason[];
  /**
   * The cookie object representing the cookie which was not sent.
   */
  cookie: Network_Cookie;
};

/**
 * Cookie parameter object
 */
export type Network_CookieParam = {
  /**
   * Cookie name.
   */
  name: string;
  /**
   * Cookie value.
   */
  value: string;
  /**
   * The request-URI to associate with the setting of the cookie. This value can affect the
   * default domain, path, source port, and source scheme values of the created cookie.
   */
  url?: string;
  /**
   * Cookie domain.
   */
  domain?: string;
  /**
   * Cookie path.
   */
  path?: string;
  /**
   * True if cookie is secure.
   */
  secure?: boolean;
  /**
   * True if cookie is http-only.
   */
  httpOnly?: boolean;
  /**
   * Cookie SameSite type.
   */
  sameSite?: Network_CookieSameSite;
  /**
   * Cookie expiration date, session cookie if not set
   */
  expires?: Network_TimeSinceEpoch;
  /**
   * @experimental
   * Cookie Priority.
   */
  priority?: Network_CookiePriority;
  /**
   * @experimental
   * True if cookie is SameParty.
   */
  sameParty?: boolean;
  /**
   * @experimental
   * Cookie source scheme type.
   */
  sourceScheme?: Network_CookieSourceScheme;
  /**
   * @experimental
   * Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
   * An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
   * This is a temporary ability and it will be removed in the future.
   */
  sourcePort?: number;
  /**
   * @experimental
   * Cookie partition key. The site of the top-level URL the browser was visiting at the start
   * of the request to the endpoint that set the cookie.
   * If not set, the cookie will be set as not partitioned.
   */
  partitionKey?: string;
};

/**
 * @experimental
 * Authorization challenge for HTTP status code 401 or 407.
 */
export type Network_AuthChallenge = {
  /**
   * Source of the authentication challenge.
   */
  source?: "Server" | "Proxy";
  /**
   * Origin of the challenger.
   */
  origin: string;
  /**
   * The authentication scheme used, such as basic or digest
   */
  scheme: string;
  /**
   * The realm of the challenge. May be empty.
   */
  realm: string;
};

/**
 * @experimental
 * Response to an AuthChallenge.
 */
export type Network_AuthChallengeResponse = {
  /**
   * The decision on what to do in response to the authorization challenge.  Default means
   * deferring to the default behavior of the net stack, which will likely either the Cancel
   * authentication or display a popup dialog box.
   */
  response: "Default" | "CancelAuth" | "ProvideCredentials";
  /**
   * The username to provide, possibly empty. Should only be set if response is
   * ProvideCredentials.
   */
  username?: string;
  /**
   * The password to provide, possibly empty. Should only be set if response is
   * ProvideCredentials.
   */
  password?: string;
};

/**
 * @experimental
 * Stages of the interception to begin intercepting. Request will intercept before the request is
 * sent. Response will intercept after the response is received.
 */
export type Network_InterceptionStage = "Request" | "HeadersReceived";

/**
 * @experimental
 * Request pattern for interception.
 */
export type Network_RequestPattern = {
  /**
   * Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is
   * backslash. Omitting is equivalent to `"*"`.
   */
  urlPattern?: string;
  /**
   * If set, only requests for matching resource types will be intercepted.
   */
  resourceType?: Network_ResourceType;
  /**
   * Stage at which to begin intercepting requests. Default is Request.
   */
  interceptionStage?: Network_InterceptionStage;
};

/**
 * @experimental
 * Information about a signed exchange signature.
 * https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1
 */
export type Network_SignedExchangeSignature = {
  /**
   * Signed exchange signature label.
   */
  label: string;
  /**
   * The hex string of signed exchange signature.
   */
  signature: string;
  /**
   * Signed exchange signature integrity.
   */
  integrity: string;
  /**
   * Signed exchange signature cert Url.
   */
  certUrl?: string;
  /**
   * The hex string of signed exchange signature cert sha256.
   */
  certSha256?: string;
  /**
   * Signed exchange signature validity Url.
   */
  validityUrl: string;
  /**
   * Signed exchange signature date.
   */
  date: number;
  /**
   * Signed exchange signature expires.
   */
  expires: number;
  /**
   * The encoded certificates.
   */
  certificates?: string[];
};

/**
 * @experimental
 * Information about a signed exchange header.
 * https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation
 */
export type Network_SignedExchangeHeader = {
  /**
   * Signed exchange request URL.
   */
  requestUrl: string;
  /**
   * Signed exchange response code.
   */
  responseCode: number;
  /**
   * Signed exchange response headers.
   */
  responseHeaders: Network_Headers;
  /**
   * Signed exchange response signature.
   */
  signatures: Network_SignedExchangeSignature[];
  /**
   * Signed exchange header integrity hash in the form of `sha256-<base64-hash-value>`.
   */
  headerIntegrity: string;
};

/**
 * @experimental
 * Field type for a signed exchange related error.
 */
export type Network_SignedExchangeErrorField =
  | "signatureSig"
  | "signatureIntegrity"
  | "signatureCertUrl"
  | "signatureCertSha256"
  | "signatureValidityUrl"
  | "signatureTimestamps";

/**
 * @experimental
 * Information about a signed exchange response.
 */
export type Network_SignedExchangeError = {
  /**
   * Error message.
   */
  message: string;
  /**
   * The index of the signature which caused the error.
   */
  signatureIndex?: number;
  /**
   * The field which caused the error.
   */
  errorField?: Network_SignedExchangeErrorField;
};

/**
 * @experimental
 * Information about a signed exchange response.
 */
export type Network_SignedExchangeInfo = {
  /**
   * The outer response of signed HTTP exchange which was received from network.
   */
  outerResponse: Network_Response;
  /**
   * Information about the signed exchange header.
   */
  header?: Network_SignedExchangeHeader;
  /**
   * Security details for the signed exchange header.
   */
  securityDetails?: Network_SecurityDetails;
  /**
   * Errors occurred while handling the signed exchagne.
   */
  errors?: Network_SignedExchangeError[];
};

/**
 * @experimental
 * List of content encodings supported by the backend.
 */
export type Network_ContentEncoding = "deflate" | "gzip" | "br" | "zstd";

/**
 * @experimental
 */
export type Network_PrivateNetworkRequestPolicy =
  | "Allow"
  | "BlockFromInsecureToMorePrivate"
  | "WarnFromInsecureToMorePrivate"
  | "PreflightBlock"
  | "PreflightWarn";

/**
 * @experimental
 */
export type Network_IPAddressSpace = "Local" | "Private" | "Public" | "Unknown";

/**
 * @experimental
 */
export type Network_ConnectTiming = {
  /**
   * Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
   * milliseconds relatively to this requestTime. Matches ResourceTiming's requestTime for
   * the same request (but not for redirected requests).
   */
  requestTime: number;
};

/**
 * @experimental
 */
export type Network_ClientSecurityState = {
  initiatorIsSecureContext: boolean;
  initiatorIPAddressSpace: Network_IPAddressSpace;
  privateNetworkRequestPolicy: Network_PrivateNetworkRequestPolicy;
};

/**
 * @experimental
 */
export type Network_CrossOriginOpenerPolicyValue =
  | "SameOrigin"
  | "SameOriginAllowPopups"
  | "RestrictProperties"
  | "UnsafeNone"
  | "SameOriginPlusCoep"
  | "RestrictPropertiesPlusCoep";

/**
 * @experimental
 */
export type Network_CrossOriginOpenerPolicyStatus = {
  value: Network_CrossOriginOpenerPolicyValue;
  reportOnlyValue: Network_CrossOriginOpenerPolicyValue;
  reportingEndpoint?: string;
  reportOnlyReportingEndpoint?: string;
};

/**
 * @experimental
 */
export type Network_CrossOriginEmbedderPolicyValue =
  | "None"
  | "Credentialless"
  | "RequireCorp";

/**
 * @experimental
 */
export type Network_CrossOriginEmbedderPolicyStatus = {
  value: Network_CrossOriginEmbedderPolicyValue;
  reportOnlyValue: Network_CrossOriginEmbedderPolicyValue;
  reportingEndpoint?: string;
  reportOnlyReportingEndpoint?: string;
};

/**
 * @experimental
 */
export type Network_ContentSecurityPolicySource = "HTTP" | "Meta";

/**
 * @experimental
 */
export type Network_ContentSecurityPolicyStatus = {
  effectiveDirectives: string;
  isEnforced: boolean;
  source: Network_ContentSecurityPolicySource;
};

/**
 * @experimental
 */
export type Network_SecurityIsolationStatus = {
  coop?: Network_CrossOriginOpenerPolicyStatus;
  coep?: Network_CrossOriginEmbedderPolicyStatus;
  csp?: Network_ContentSecurityPolicyStatus[];
};

/**
 * @experimental
 * The status of a Reporting API report.
 */
export type Network_ReportStatus =
  | "Queued"
  | "Pending"
  | "MarkedForRemoval"
  | "Success";

/**
 * @experimental
 */
export type Network_ReportId = string;

/**
 * @experimental
 * An object representing a report generated by the Reporting API.
 */
export type Network_ReportingApiReport = {
  id: Network_ReportId;
  /**
   * The URL of the document that triggered the report.
   */
  initiatorUrl: string;
  /**
   * The name of the endpoint group that should be used to deliver the report.
   */
  destination: string;
  /**
   * The type of the report (specifies the set of data that is contained in the report body).
   */
  type: string;
  /**
   * When the report was generated.
   */
  timestamp: Network_TimeSinceEpoch;
  /**
   * How many uploads deep the related request was.
   */
  depth: number;
  /**
   * The number of delivery attempts made so far, not including an active attempt.
   */
  completedAttempts: number;
  body: object;
  status: Network_ReportStatus;
};

/**
 * @experimental
 */
export type Network_ReportingApiEndpoint = {
  /**
   * The URL of the endpoint to which reports may be delivered.
   */
  url: string;
  /**
   * Name of the endpoint group.
   */
  groupName: string;
};

/**
 * @experimental
 * An object providing the result of a network resource load.
 */
export type Network_LoadNetworkResourcePageResult = {
  success: boolean;
  /**
   * Optional values used for error reporting.
   */
  netError?: number;
  netErrorName?: string;
  httpStatusCode?: number;
  /**
   * If successful, one of the following two fields holds the result.
   */
  stream?: IO_StreamHandle;
  /**
   * Response headers.
   */
  headers?: Network_Headers;
};

/**
 * @experimental
 * An options object that may be extended later to better support CORS,
 * CORB and streaming.
 */
export type Network_LoadNetworkResourceOptions = {
  disableCache: boolean;
  includeCredentials: boolean;
};

// ----------------- Overlay -----------------

/**
 * Configuration data for drawing the source order of an elements children.
 */
export type Overlay_SourceOrderConfig = {
  /**
   * the color to outline the givent element in.
   */
  parentOutlineColor: DOM_RGBA;
  /**
   * the color to outline the child elements in.
   */
  childOutlineColor: DOM_RGBA;
};

/**
 * Configuration data for the highlighting of Grid elements.
 */
export type Overlay_GridHighlightConfig = {
  /**
   * Whether the extension lines from grid cells to the rulers should be shown (default: false).
   */
  showGridExtensionLines?: boolean;
  /**
   * Show Positive line number labels (default: false).
   */
  showPositiveLineNumbers?: boolean;
  /**
   * Show Negative line number labels (default: false).
   */
  showNegativeLineNumbers?: boolean;
  /**
   * Show area name labels (default: false).
   */
  showAreaNames?: boolean;
  /**
   * Show line name labels (default: false).
   */
  showLineNames?: boolean;
  /**
   * Show track size labels (default: false).
   */
  showTrackSizes?: boolean;
  /**
   * The grid container border highlight color (default: transparent).
   */
  gridBorderColor?: DOM_RGBA;
  /**
   * @deprecated
   * The cell border color (default: transparent). Deprecated, please use rowLineColor and columnLineColor instead.
   */
  cellBorderColor?: DOM_RGBA;
  /**
   * The row line color (default: transparent).
   */
  rowLineColor?: DOM_RGBA;
  /**
   * The column line color (default: transparent).
   */
  columnLineColor?: DOM_RGBA;
  /**
   * Whether the grid border is dashed (default: false).
   */
  gridBorderDash?: boolean;
  /**
   * @deprecated
   * Whether the cell border is dashed (default: false). Deprecated, please us rowLineDash and columnLineDash instead.
   */
  cellBorderDash?: boolean;
  /**
   * Whether row lines are dashed (default: false).
   */
  rowLineDash?: boolean;
  /**
   * Whether column lines are dashed (default: false).
   */
  columnLineDash?: boolean;
  /**
   * The row gap highlight fill color (default: transparent).
   */
  rowGapColor?: DOM_RGBA;
  /**
   * The row gap hatching fill color (default: transparent).
   */
  rowHatchColor?: DOM_RGBA;
  /**
   * The column gap highlight fill color (default: transparent).
   */
  columnGapColor?: DOM_RGBA;
  /**
   * The column gap hatching fill color (default: transparent).
   */
  columnHatchColor?: DOM_RGBA;
  /**
   * The named grid areas border color (Default: transparent).
   */
  areaBorderColor?: DOM_RGBA;
  /**
   * The grid container background color (Default: transparent).
   */
  gridBackgroundColor?: DOM_RGBA;
};

/**
 * Configuration data for the highlighting of Flex container elements.
 */
export type Overlay_FlexContainerHighlightConfig = {
  /**
   * The style of the container border
   */
  containerBorder?: Overlay_LineStyle;
  /**
   * The style of the separator between lines
   */
  lineSeparator?: Overlay_LineStyle;
  /**
   * The style of the separator between items
   */
  itemSeparator?: Overlay_LineStyle;
  /**
   * Style of content-distribution space on the main axis (justify-content).
   */
  mainDistributedSpace?: Overlay_BoxStyle;
  /**
   * Style of content-distribution space on the cross axis (align-content).
   */
  crossDistributedSpace?: Overlay_BoxStyle;
  /**
   * Style of empty space caused by row gaps (gap/row-gap).
   */
  rowGapSpace?: Overlay_BoxStyle;
  /**
   * Style of empty space caused by columns gaps (gap/column-gap).
   */
  columnGapSpace?: Overlay_BoxStyle;
  /**
   * Style of the self-alignment line (align-items).
   */
  crossAlignment?: Overlay_LineStyle;
};

/**
 * Configuration data for the highlighting of Flex item elements.
 */
export type Overlay_FlexItemHighlightConfig = {
  /**
   * Style of the box representing the item's base size
   */
  baseSizeBox?: Overlay_BoxStyle;
  /**
   * Style of the border around the box representing the item's base size
   */
  baseSizeBorder?: Overlay_LineStyle;
  /**
   * Style of the arrow representing if the item grew or shrank
   */
  flexibilityArrow?: Overlay_LineStyle;
};

/**
 * Style information for drawing a line.
 */
export type Overlay_LineStyle = {
  /**
   * The color of the line (default: transparent)
   */
  color?: DOM_RGBA;
  /**
   * The line pattern (default: solid)
   */
  pattern?: "dashed" | "dotted";
};

/**
 * Style information for drawing a box.
 */
export type Overlay_BoxStyle = {
  /**
   * The background color for the box (default: transparent)
   */
  fillColor?: DOM_RGBA;
  /**
   * The hatching color for the box (default: transparent)
   */
  hatchColor?: DOM_RGBA;
};

export type Overlay_ContrastAlgorithm = "aa" | "aaa" | "apca";

/**
 * Configuration data for the highlighting of page elements.
 */
export type Overlay_HighlightConfig = {
  /**
   * Whether the node info tooltip should be shown (default: false).
   */
  showInfo?: boolean;
  /**
   * Whether the node styles in the tooltip (default: false).
   */
  showStyles?: boolean;
  /**
   * Whether the rulers should be shown (default: false).
   */
  showRulers?: boolean;
  /**
   * Whether the a11y info should be shown (default: true).
   */
  showAccessibilityInfo?: boolean;
  /**
   * Whether the extension lines from node to the rulers should be shown (default: false).
   */
  showExtensionLines?: boolean;
  /**
   * The content box highlight fill color (default: transparent).
   */
  contentColor?: DOM_RGBA;
  /**
   * The padding highlight fill color (default: transparent).
   */
  paddingColor?: DOM_RGBA;
  /**
   * The border highlight fill color (default: transparent).
   */
  borderColor?: DOM_RGBA;
  /**
   * The margin highlight fill color (default: transparent).
   */
  marginColor?: DOM_RGBA;
  /**
   * The event target element highlight fill color (default: transparent).
   */
  eventTargetColor?: DOM_RGBA;
  /**
   * The shape outside fill color (default: transparent).
   */
  shapeColor?: DOM_RGBA;
  /**
   * The shape margin fill color (default: transparent).
   */
  shapeMarginColor?: DOM_RGBA;
  /**
   * The grid layout color (default: transparent).
   */
  cssGridColor?: DOM_RGBA;
  /**
   * The color format used to format color styles (default: hex).
   */
  colorFormat?: Overlay_ColorFormat;
  /**
   * The grid layout highlight configuration (default: all transparent).
   */
  gridHighlightConfig?: Overlay_GridHighlightConfig;
  /**
   * The flex container highlight configuration (default: all transparent).
   */
  flexContainerHighlightConfig?: Overlay_FlexContainerHighlightConfig;
  /**
   * The flex item highlight configuration (default: all transparent).
   */
  flexItemHighlightConfig?: Overlay_FlexItemHighlightConfig;
  /**
   * The contrast algorithm to use for the contrast ratio (default: aa).
   */
  contrastAlgorithm?: Overlay_ContrastAlgorithm;
  /**
   * The container query container highlight configuration (default: all transparent).
   */
  containerQueryContainerHighlightConfig?:
    Overlay_ContainerQueryContainerHighlightConfig;
};

export type Overlay_ColorFormat = "rgb" | "hsl" | "hwb" | "hex";

/**
 * Configurations for Persistent Grid Highlight
 */
export type Overlay_GridNodeHighlightConfig = {
  /**
   * A descriptor for the highlight appearance.
   */
  gridHighlightConfig: Overlay_GridHighlightConfig;
  /**
   * Identifier of the node to highlight.
   */
  nodeId: DOM_NodeId;
};

export type Overlay_FlexNodeHighlightConfig = {
  /**
   * A descriptor for the highlight appearance of flex containers.
   */
  flexContainerHighlightConfig: Overlay_FlexContainerHighlightConfig;
  /**
   * Identifier of the node to highlight.
   */
  nodeId: DOM_NodeId;
};

export type Overlay_ScrollSnapContainerHighlightConfig = {
  /**
   * The style of the snapport border (default: transparent)
   */
  snapportBorder?: Overlay_LineStyle;
  /**
   * The style of the snap area border (default: transparent)
   */
  snapAreaBorder?: Overlay_LineStyle;
  /**
   * The margin highlight fill color (default: transparent).
   */
  scrollMarginColor?: DOM_RGBA;
  /**
   * The padding highlight fill color (default: transparent).
   */
  scrollPaddingColor?: DOM_RGBA;
};

export type Overlay_ScrollSnapHighlightConfig = {
  /**
   * A descriptor for the highlight appearance of scroll snap containers.
   */
  scrollSnapContainerHighlightConfig:
    Overlay_ScrollSnapContainerHighlightConfig;
  /**
   * Identifier of the node to highlight.
   */
  nodeId: DOM_NodeId;
};

/**
 * Configuration for dual screen hinge
 */
export type Overlay_HingeConfig = {
  /**
   * A rectangle represent hinge
   */
  rect: DOM_Rect;
  /**
   * The content box highlight fill color (default: a dark color).
   */
  contentColor?: DOM_RGBA;
  /**
   * The content box highlight outline color (default: transparent).
   */
  outlineColor?: DOM_RGBA;
};

export type Overlay_ContainerQueryHighlightConfig = {
  /**
   * A descriptor for the highlight appearance of container query containers.
   */
  containerQueryContainerHighlightConfig:
    Overlay_ContainerQueryContainerHighlightConfig;
  /**
   * Identifier of the container node to highlight.
   */
  nodeId: DOM_NodeId;
};

export type Overlay_ContainerQueryContainerHighlightConfig = {
  /**
   * The style of the container border.
   */
  containerBorder?: Overlay_LineStyle;
  /**
   * The style of the descendants' borders.
   */
  descendantBorder?: Overlay_LineStyle;
};

export type Overlay_IsolatedElementHighlightConfig = {
  /**
   * A descriptor for the highlight appearance of an element in isolation mode.
   */
  isolationModeHighlightConfig: Overlay_IsolationModeHighlightConfig;
  /**
   * Identifier of the isolated element to highlight.
   */
  nodeId: DOM_NodeId;
};

export type Overlay_IsolationModeHighlightConfig = {
  /**
   * The fill color of the resizers (default: transparent).
   */
  resizerColor?: DOM_RGBA;
  /**
   * The fill color for resizer handles (default: transparent).
   */
  resizerHandleColor?: DOM_RGBA;
  /**
   * The fill color for the mask covering non-isolated elements (default: transparent).
   */
  maskColor?: DOM_RGBA;
};

export type Overlay_InspectMode =
  | "searchForNode"
  | "searchForUAShadowDOM"
  | "captureAreaScreenshot"
  | "showDistances"
  | "none";

// ----------------- Page -----------------

/**
 * Unique frame identifier.
 */
export type Page_FrameId = string;

/**
 * @experimental
 * Indicates whether a frame has been identified as an ad.
 */
export type Page_AdFrameType = "none" | "child" | "root";

/**
 * @experimental
 */
export type Page_AdFrameExplanation =
  | "ParentIsAd"
  | "CreatedByAdScript"
  | "MatchedBlockingRule";

/**
 * @experimental
 * Indicates whether a frame has been identified as an ad and why.
 */
export type Page_AdFrameStatus = {
  adFrameType: Page_AdFrameType;
  explanations?: Page_AdFrameExplanation[];
};

/**
 * @experimental
 * Identifies the bottom-most script which caused the frame to be labelled
 * as an ad.
 */
export type Page_AdScriptId = {
  /**
   * Script Id of the bottom-most script which caused the frame to be labelled
   * as an ad.
   */
  scriptId: Runtime_ScriptId;
  /**
   * Id of adScriptId's debugger.
   */
  debuggerId: Runtime_UniqueDebuggerId;
};

/**
 * @experimental
 * Indicates whether the frame is a secure context and why it is the case.
 */
export type Page_SecureContextType =
  | "Secure"
  | "SecureLocalhost"
  | "InsecureScheme"
  | "InsecureAncestor";

/**
 * @experimental
 * Indicates whether the frame is cross-origin isolated and why it is the case.
 */
export type Page_CrossOriginIsolatedContextType =
  | "Isolated"
  | "NotIsolated"
  | "NotIsolatedFeatureDisabled";

/**
 * @experimental
 */
export type Page_GatedAPIFeatures =
  | "SharedArrayBuffers"
  | "SharedArrayBuffersTransferAllowed"
  | "PerformanceMeasureMemory"
  | "PerformanceProfile";

/**
 * @experimental
 * All Permissions Policy features. This enum should match the one defined
 * in third_party/blink/renderer/core/permissions_policy/permissions_policy_features.json5.
 */
export type Page_PermissionsPolicyFeature =
  | "accelerometer"
  | "ambient-light-sensor"
  | "attribution-reporting"
  | "autoplay"
  | "bluetooth"
  | "browsing-topics"
  | "camera"
  | "ch-dpr"
  | "ch-device-memory"
  | "ch-downlink"
  | "ch-ect"
  | "ch-prefers-color-scheme"
  | "ch-prefers-reduced-motion"
  | "ch-rtt"
  | "ch-save-data"
  | "ch-ua"
  | "ch-ua-arch"
  | "ch-ua-bitness"
  | "ch-ua-platform"
  | "ch-ua-model"
  | "ch-ua-mobile"
  | "ch-ua-form-factor"
  | "ch-ua-full-version"
  | "ch-ua-full-version-list"
  | "ch-ua-platform-version"
  | "ch-ua-wow64"
  | "ch-viewport-height"
  | "ch-viewport-width"
  | "ch-width"
  | "clipboard-read"
  | "clipboard-write"
  | "compute-pressure"
  | "cross-origin-isolated"
  | "direct-sockets"
  | "display-capture"
  | "document-domain"
  | "encrypted-media"
  | "execution-while-out-of-viewport"
  | "execution-while-not-rendered"
  | "focus-without-user-activation"
  | "fullscreen"
  | "frobulate"
  | "gamepad"
  | "geolocation"
  | "gyroscope"
  | "hid"
  | "identity-credentials-get"
  | "idle-detection"
  | "interest-cohort"
  | "join-ad-interest-group"
  | "keyboard-map"
  | "local-fonts"
  | "magnetometer"
  | "microphone"
  | "midi"
  | "otp-credentials"
  | "payment"
  | "picture-in-picture"
  | "private-aggregation"
  | "private-state-token-issuance"
  | "private-state-token-redemption"
  | "publickey-credentials-get"
  | "run-ad-auction"
  | "screen-wake-lock"
  | "serial"
  | "shared-autofill"
  | "shared-storage"
  | "shared-storage-select-url"
  | "smart-card"
  | "storage-access"
  | "sync-xhr"
  | "unload"
  | "usb"
  | "vertical-scroll"
  | "web-share"
  | "window-management"
  | "window-placement"
  | "xr-spatial-tracking";

/**
 * @experimental
 * Reason for a permissions policy feature to be disabled.
 */
export type Page_PermissionsPolicyBlockReason =
  | "Header"
  | "IframeAttribute"
  | "InFencedFrameTree"
  | "InIsolatedApp";

/**
 * @experimental
 */
export type Page_PermissionsPolicyBlockLocator = {
  frameId: Page_FrameId;
  blockReason: Page_PermissionsPolicyBlockReason;
};

/**
 * @experimental
 */
export type Page_PermissionsPolicyFeatureState = {
  feature: Page_PermissionsPolicyFeature;
  allowed: boolean;
  locator?: Page_PermissionsPolicyBlockLocator;
};

/**
 * @experimental
 * Origin Trial(https://www.chromium.org/blink/origin-trials) support.
 * Status for an Origin Trial token.
 */
export type Page_OriginTrialTokenStatus =
  | "Success"
  | "NotSupported"
  | "Insecure"
  | "Expired"
  | "WrongOrigin"
  | "InvalidSignature"
  | "Malformed"
  | "WrongVersion"
  | "FeatureDisabled"
  | "TokenDisabled"
  | "FeatureDisabledForUser"
  | "UnknownTrial";

/**
 * @experimental
 * Status for an Origin Trial.
 */
export type Page_OriginTrialStatus =
  | "Enabled"
  | "ValidTokenNotProvided"
  | "OSNotSupported"
  | "TrialNotAllowed";

/**
 * @experimental
 */
export type Page_OriginTrialUsageRestriction = "None" | "Subset";

/**
 * @experimental
 */
export type Page_OriginTrialToken = {
  origin: string;
  matchSubDomains: boolean;
  trialName: string;
  expiryTime: Network_TimeSinceEpoch;
  isThirdParty: boolean;
  usageRestriction: Page_OriginTrialUsageRestriction;
};

/**
 * @experimental
 */
export type Page_OriginTrialTokenWithStatus = {
  rawTokenText: string;
  /**
   * `parsedToken` is present only when the token is extractable and
   * parsable.
   */
  parsedToken?: Page_OriginTrialToken;
  status: Page_OriginTrialTokenStatus;
};

/**
 * @experimental
 */
export type Page_OriginTrial = {
  trialName: string;
  status: Page_OriginTrialStatus;
  tokensWithStatus: Page_OriginTrialTokenWithStatus[];
};

/**
 * Information about the Frame on the page.
 */
export type Page_Frame = {
  /**
   * Frame unique identifier.
   */
  id: Page_FrameId;
  /**
   * Parent frame identifier.
   */
  parentId?: Page_FrameId;
  /**
   * Identifier of the loader associated with this frame.
   */
  loaderId: Network_LoaderId;
  /**
   * Frame's name as specified in the tag.
   */
  name?: string;
  /**
   * Frame document's URL without fragment.
   */
  url: string;
  /**
   * @experimental
   * Frame document's URL fragment including the '#'.
   */
  urlFragment?: string;
  /**
   * @experimental
   * Frame document's registered domain, taking the public suffixes list into account.
   * Extracted from the Frame's url.
   * Example URLs: http://www.google.com/file.html -> "google.com"
   *               http://a.b.co.uk/file.html      -> "b.co.uk"
   */
  domainAndRegistry: string;
  /**
   * Frame document's security origin.
   */
  securityOrigin: string;
  /**
   * Frame document's mimeType as determined by the browser.
   */
  mimeType: string;
  /**
   * @experimental
   * If the frame failed to load, this contains the URL that could not be loaded. Note that unlike url above, this URL may contain a fragment.
   */
  unreachableUrl?: string;
  /**
   * @experimental
   * Indicates whether this frame was tagged as an ad and why.
   */
  adFrameStatus?: Page_AdFrameStatus;
  /**
   * @experimental
   * Indicates whether the main document is a secure context and explains why that is the case.
   */
  secureContextType: Page_SecureContextType;
  /**
   * @experimental
   * Indicates whether this is a cross origin isolated context.
   */
  crossOriginIsolatedContextType: Page_CrossOriginIsolatedContextType;
  /**
   * @experimental
   * Indicated which gated APIs / features are available.
   */
  gatedAPIFeatures: Page_GatedAPIFeatures[];
};

/**
 * @experimental
 * Information about the Resource on the page.
 */
export type Page_FrameResource = {
  /**
   * Resource URL.
   */
  url: string;
  /**
   * Type of this resource.
   */
  type: Network_ResourceType;
  /**
   * Resource mimeType as determined by the browser.
   */
  mimeType: string;
  /**
   * last-modified timestamp as reported by server.
   */
  lastModified?: Network_TimeSinceEpoch;
  /**
   * Resource content size.
   */
  contentSize?: number;
  /**
   * True if the resource failed to load.
   */
  failed?: boolean;
  /**
   * True if the resource was canceled during loading.
   */
  canceled?: boolean;
};

/**
 * @experimental
 * Information about the Frame hierarchy along with their cached resources.
 */
export type Page_FrameResourceTree = {
  /**
   * Frame information for this tree item.
   */
  frame: Page_Frame;
  /**
   * Child frames.
   */
  childFrames?: Page_FrameResourceTree[];
  /**
   * Information about frame resources.
   */
  resources: Page_FrameResource[];
};

/**
 * Information about the Frame hierarchy.
 */
export type Page_FrameTree = {
  /**
   * Frame information for this tree item.
   */
  frame: Page_Frame;
  /**
   * Child frames.
   */
  childFrames?: Page_FrameTree[];
};

/**
 * Unique script identifier.
 */
export type Page_ScriptIdentifier = string;

/**
 * Transition type.
 */
export type Page_TransitionType =
  | "link"
  | "typed"
  | "address_bar"
  | "auto_bookmark"
  | "auto_subframe"
  | "manual_subframe"
  | "generated"
  | "auto_toplevel"
  | "form_submit"
  | "reload"
  | "keyword"
  | "keyword_generated"
  | "other";

/**
 * Navigation history entry.
 */
export type Page_NavigationEntry = {
  /**
   * Unique id of the navigation history entry.
   */
  id: number;
  /**
   * URL of the navigation history entry.
   */
  url: string;
  /**
   * URL that the user typed in the url bar.
   */
  userTypedURL: string;
  /**
   * Title of the navigation history entry.
   */
  title: string;
  /**
   * Transition type.
   */
  transitionType: Page_TransitionType;
};

/**
 * @experimental
 * Screencast frame metadata.
 */
export type Page_ScreencastFrameMetadata = {
  /**
   * Top offset in DIP.
   */
  offsetTop: number;
  /**
   * Page scale factor.
   */
  pageScaleFactor: number;
  /**
   * Device screen width in DIP.
   */
  deviceWidth: number;
  /**
   * Device screen height in DIP.
   */
  deviceHeight: number;
  /**
   * Position of horizontal scroll in CSS pixels.
   */
  scrollOffsetX: number;
  /**
   * Position of vertical scroll in CSS pixels.
   */
  scrollOffsetY: number;
  /**
   * Frame swap timestamp.
   */
  timestamp?: Network_TimeSinceEpoch;
};

/**
 * Javascript dialog type.
 */
export type Page_DialogType = "alert" | "confirm" | "prompt" | "beforeunload";

/**
 * Error while paring app manifest.
 */
export type Page_AppManifestError = {
  /**
   * Error message.
   */
  message: string;
  /**
   * If criticial, this is a non-recoverable parse error.
   */
  critical: number;
  /**
   * Error line.
   */
  line: number;
  /**
   * Error column.
   */
  column: number;
};

/**
 * @experimental
 * Parsed app manifest properties.
 */
export type Page_AppManifestParsedProperties = {
  /**
   * Computed scope value
   */
  scope: string;
};

/**
 * Layout viewport position and dimensions.
 */
export type Page_LayoutViewport = {
  /**
   * Horizontal offset relative to the document (CSS pixels).
   */
  pageX: number;
  /**
   * Vertical offset relative to the document (CSS pixels).
   */
  pageY: number;
  /**
   * Width (CSS pixels), excludes scrollbar if present.
   */
  clientWidth: number;
  /**
   * Height (CSS pixels), excludes scrollbar if present.
   */
  clientHeight: number;
};

/**
 * Visual viewport position, dimensions, and scale.
 */
export type Page_VisualViewport = {
  /**
   * Horizontal offset relative to the layout viewport (CSS pixels).
   */
  offsetX: number;
  /**
   * Vertical offset relative to the layout viewport (CSS pixels).
   */
  offsetY: number;
  /**
   * Horizontal offset relative to the document (CSS pixels).
   */
  pageX: number;
  /**
   * Vertical offset relative to the document (CSS pixels).
   */
  pageY: number;
  /**
   * Width (CSS pixels), excludes scrollbar if present.
   */
  clientWidth: number;
  /**
   * Height (CSS pixels), excludes scrollbar if present.
   */
  clientHeight: number;
  /**
   * Scale relative to the ideal viewport (size at width=device-width).
   */
  scale: number;
  /**
   * Page zoom factor (CSS to device independent pixels ratio).
   */
  zoom?: number;
};

/**
 * Viewport for capturing screenshot.
 */
export type Page_Viewport = {
  /**
   * X offset in device independent pixels (dip).
   */
  x: number;
  /**
   * Y offset in device independent pixels (dip).
   */
  y: number;
  /**
   * Rectangle width in device independent pixels (dip).
   */
  width: number;
  /**
   * Rectangle height in device independent pixels (dip).
   */
  height: number;
  /**
   * Page scale factor.
   */
  scale: number;
};

/**
 * @experimental
 * Generic font families collection.
 */
export type Page_FontFamilies = {
  /**
   * The standard font-family.
   */
  standard?: string;
  /**
   * The fixed font-family.
   */
  fixed?: string;
  /**
   * The serif font-family.
   */
  serif?: string;
  /**
   * The sansSerif font-family.
   */
  sansSerif?: string;
  /**
   * The cursive font-family.
   */
  cursive?: string;
  /**
   * The fantasy font-family.
   */
  fantasy?: string;
  /**
   * The math font-family.
   */
  math?: string;
};

/**
 * @experimental
 * Font families collection for a script.
 */
export type Page_ScriptFontFamilies = {
  /**
   * Name of the script which these font families are defined for.
   */
  script: string;
  /**
   * Generic font families collection for the script.
   */
  fontFamilies: Page_FontFamilies;
};

/**
 * @experimental
 * Default font sizes.
 */
export type Page_FontSizes = {
  /**
   * Default standard font size.
   */
  standard?: number;
  /**
   * Default fixed font size.
   */
  fixed?: number;
};

/**
 * @experimental
 */
export type Page_ClientNavigationReason =
  | "formSubmissionGet"
  | "formSubmissionPost"
  | "httpHeaderRefresh"
  | "scriptInitiated"
  | "metaTagRefresh"
  | "pageBlockInterstitial"
  | "reload"
  | "anchorClick";

/**
 * @experimental
 */
export type Page_ClientNavigationDisposition =
  | "currentTab"
  | "newTab"
  | "newWindow"
  | "download";

/**
 * @experimental
 */
export type Page_InstallabilityErrorArgument = {
  /**
   * Argument name (e.g. name:'minimum-icon-size-in-pixels').
   */
  name: string;
  /**
   * Argument value (e.g. value:'64').
   */
  value: string;
};

/**
 * @experimental
 * The installability error
 */
export type Page_InstallabilityError = {
  /**
   * The error id (e.g. 'manifest-missing-suitable-icon').
   */
  errorId: string;
  /**
   * The list of error arguments (e.g. {name:'minimum-icon-size-in-pixels', value:'64'}).
   */
  errorArguments: Page_InstallabilityErrorArgument[];
};

/**
 * @experimental
 * The referring-policy used for the navigation.
 */
export type Page_ReferrerPolicy =
  | "noReferrer"
  | "noReferrerWhenDowngrade"
  | "origin"
  | "originWhenCrossOrigin"
  | "sameOrigin"
  | "strictOrigin"
  | "strictOriginWhenCrossOrigin"
  | "unsafeUrl";

/**
 * @experimental
 * Per-script compilation cache parameters for `Page.produceCompilationCache`
 */
export type Page_CompilationCacheParams = {
  /**
   * The URL of the script to produce a compilation cache entry for.
   */
  url: string;
  /**
   * A hint to the backend whether eager compilation is recommended.
   * (the actual compilation mode used is upon backend discretion).
   */
  eager?: boolean;
};

/**
 * @experimental
 * Enum of possible auto-reponse for permisison / prompt dialogs.
 */
export type Page_AutoResponseMode =
  | "none"
  | "autoAccept"
  | "autoReject"
  | "autoOptOut";

/**
 * @experimental
 * The type of a frameNavigated event.
 */
export type Page_NavigationType = "Navigation" | "BackForwardCacheRestore";

/**
 * @experimental
 * List of not restored reasons for back-forward cache.
 */
export type Page_BackForwardCacheNotRestoredReason =
  | "NotPrimaryMainFrame"
  | "BackForwardCacheDisabled"
  | "RelatedActiveContentsExist"
  | "HTTPStatusNotOK"
  | "SchemeNotHTTPOrHTTPS"
  | "Loading"
  | "WasGrantedMediaAccess"
  | "DisableForRenderFrameHostCalled"
  | "DomainNotAllowed"
  | "HTTPMethodNotGET"
  | "SubframeIsNavigating"
  | "Timeout"
  | "CacheLimit"
  | "JavaScriptExecution"
  | "RendererProcessKilled"
  | "RendererProcessCrashed"
  | "SchedulerTrackedFeatureUsed"
  | "ConflictingBrowsingInstance"
  | "CacheFlushed"
  | "ServiceWorkerVersionActivation"
  | "SessionRestored"
  | "ServiceWorkerPostMessage"
  | "EnteredBackForwardCacheBeforeServiceWorkerHostAdded"
  | "RenderFrameHostReused_SameSite"
  | "RenderFrameHostReused_CrossSite"
  | "ServiceWorkerClaim"
  | "IgnoreEventAndEvict"
  | "HaveInnerContents"
  | "TimeoutPuttingInCache"
  | "BackForwardCacheDisabledByLowMemory"
  | "BackForwardCacheDisabledByCommandLine"
  | "NetworkRequestDatapipeDrainedAsBytesConsumer"
  | "NetworkRequestRedirected"
  | "NetworkRequestTimeout"
  | "NetworkExceedsBufferLimit"
  | "NavigationCancelledWhileRestoring"
  | "NotMostRecentNavigationEntry"
  | "BackForwardCacheDisabledForPrerender"
  | "UserAgentOverrideDiffers"
  | "ForegroundCacheLimit"
  | "BrowsingInstanceNotSwapped"
  | "BackForwardCacheDisabledForDelegate"
  | "UnloadHandlerExistsInMainFrame"
  | "UnloadHandlerExistsInSubFrame"
  | "ServiceWorkerUnregistration"
  | "CacheControlNoStore"
  | "CacheControlNoStoreCookieModified"
  | "CacheControlNoStoreHTTPOnlyCookieModified"
  | "NoResponseHead"
  | "Unknown"
  | "ActivationNavigationsDisallowedForBug1234857"
  | "ErrorDocument"
  | "FencedFramesEmbedder"
  | "CookieDisabled"
  | "HTTPAuthRequired"
  | "CookieFlushed"
  | "WebSocket"
  | "WebTransport"
  | "WebRTC"
  | "MainResourceHasCacheControlNoStore"
  | "MainResourceHasCacheControlNoCache"
  | "SubresourceHasCacheControlNoStore"
  | "SubresourceHasCacheControlNoCache"
  | "ContainsPlugins"
  | "DocumentLoaded"
  | "DedicatedWorkerOrWorklet"
  | "OutstandingNetworkRequestOthers"
  | "RequestedMIDIPermission"
  | "RequestedAudioCapturePermission"
  | "RequestedVideoCapturePermission"
  | "RequestedBackForwardCacheBlockedSensors"
  | "RequestedBackgroundWorkPermission"
  | "BroadcastChannel"
  | "WebXR"
  | "SharedWorker"
  | "WebLocks"
  | "WebHID"
  | "WebShare"
  | "RequestedStorageAccessGrant"
  | "WebNfc"
  | "OutstandingNetworkRequestFetch"
  | "OutstandingNetworkRequestXHR"
  | "AppBanner"
  | "Printing"
  | "WebDatabase"
  | "PictureInPicture"
  | "Portal"
  | "SpeechRecognizer"
  | "IdleManager"
  | "PaymentManager"
  | "SpeechSynthesis"
  | "KeyboardLock"
  | "WebOTPService"
  | "OutstandingNetworkRequestDirectSocket"
  | "InjectedJavascript"
  | "InjectedStyleSheet"
  | "KeepaliveRequest"
  | "IndexedDBEvent"
  | "Dummy"
  | "JsNetworkRequestReceivedCacheControlNoStoreResource"
  | "WebRTCSticky"
  | "WebTransportSticky"
  | "WebSocketSticky"
  | "ContentSecurityHandler"
  | "ContentWebAuthenticationAPI"
  | "ContentFileChooser"
  | "ContentSerial"
  | "ContentFileSystemAccess"
  | "ContentMediaDevicesDispatcherHost"
  | "ContentWebBluetooth"
  | "ContentWebUSB"
  | "ContentMediaSessionService"
  | "ContentScreenReader"
  | "EmbedderPopupBlockerTabHelper"
  | "EmbedderSafeBrowsingTriggeredPopupBlocker"
  | "EmbedderSafeBrowsingThreatDetails"
  | "EmbedderAppBannerManager"
  | "EmbedderDomDistillerViewerSource"
  | "EmbedderDomDistillerSelfDeletingRequestDelegate"
  | "EmbedderOomInterventionTabHelper"
  | "EmbedderOfflinePage"
  | "EmbedderChromePasswordManagerClientBindCredentialManager"
  | "EmbedderPermissionRequestManager"
  | "EmbedderModalDialog"
  | "EmbedderExtensions"
  | "EmbedderExtensionMessaging"
  | "EmbedderExtensionMessagingForOpenPort"
  | "EmbedderExtensionSentMessageToCachedFrame";

/**
 * @experimental
 * Types of not restored reasons for back-forward cache.
 */
export type Page_BackForwardCacheNotRestoredReasonType =
  | "SupportPending"
  | "PageSupportNeeded"
  | "Circumstantial";

/**
 * @experimental
 */
export type Page_BackForwardCacheNotRestoredExplanation = {
  /**
   * Type of the reason
   */
  type: Page_BackForwardCacheNotRestoredReasonType;
  /**
   * Not restored reason
   */
  reason: Page_BackForwardCacheNotRestoredReason;
  /**
   * Context associated with the reason. The meaning of this context is
   * dependent on the reason:
   * - EmbedderExtensionSentMessageToCachedFrame: the extension ID.
   */
  context?: string;
};

/**
 * @experimental
 */
export type Page_BackForwardCacheNotRestoredExplanationTree = {
  /**
   * URL of each frame
   */
  url: string;
  /**
   * Not restored reasons of each frame
   */
  explanations: Page_BackForwardCacheNotRestoredExplanation[];
  /**
   * Array of children frame
   */
  children: Page_BackForwardCacheNotRestoredExplanationTree[];
};

// ----------------- Performance -----------------

/**
 * Run-time execution metric.
 */
export type Performance_Metric = {
  /**
   * Metric name.
   */
  name: string;
  /**
   * Metric value.
   */
  value: number;
};

// ----------------- PerformanceTimeline -----------------

/**
 * See https://github.com/WICG/LargestContentfulPaint and largest_contentful_paint.idl
 */
export type PerformanceTimeline_LargestContentfulPaint = {
  renderTime: Network_TimeSinceEpoch;
  loadTime: Network_TimeSinceEpoch;
  /**
   * The number of pixels being painted.
   */
  size: number;
  /**
   * The id attribute of the element, if available.
   */
  elementId?: string;
  /**
   * The URL of the image (may be trimmed).
   */
  url?: string;
  nodeId?: DOM_BackendNodeId;
};

export type PerformanceTimeline_LayoutShiftAttribution = {
  previousRect: DOM_Rect;
  currentRect: DOM_Rect;
  nodeId?: DOM_BackendNodeId;
};

/**
 * See https://wicg.github.io/layout-instability/#sec-layout-shift and layout_shift.idl
 */
export type PerformanceTimeline_LayoutShift = {
  /**
   * Score increment produced by this event.
   */
  value: number;
  hadRecentInput: boolean;
  lastInputTime: Network_TimeSinceEpoch;
  sources: PerformanceTimeline_LayoutShiftAttribution[];
};

export type PerformanceTimeline_TimelineEvent = {
  /**
   * Identifies the frame that this event is related to. Empty for non-frame targets.
   */
  frameId: Page_FrameId;
  /**
   * The event type, as specified in https://w3c.github.io/performance-timeline/#dom-performanceentry-entrytype
   * This determines which of the optional "details" fiedls is present.
   */
  type: string;
  /**
   * Name may be empty depending on the type.
   */
  name: string;
  /**
   * Time in seconds since Epoch, monotonically increasing within document lifetime.
   */
  time: Network_TimeSinceEpoch;
  /**
   * Event duration, if applicable.
   */
  duration?: number;
  lcpDetails?: PerformanceTimeline_LargestContentfulPaint;
  layoutShiftDetails?: PerformanceTimeline_LayoutShift;
};

// ----------------- Security -----------------

/**
 * An internal certificate ID value.
 */
export type Security_CertificateId = number;

/**
 * A description of mixed content (HTTP resources on HTTPS pages), as defined by
 * https://www.w3.org/TR/mixed-content/#categories
 */
export type Security_MixedContentType =
  | "blockable"
  | "optionally-blockable"
  | "none";

/**
 * The security level of a page or resource.
 */
export type Security_SecurityState =
  | "unknown"
  | "neutral"
  | "insecure"
  | "secure"
  | "info"
  | "insecure-broken";

/**
 * @experimental
 * Details about the security state of the page certificate.
 */
export type Security_CertificateSecurityState = {
  /**
   * Protocol name (e.g. "TLS 1.2" or "QUIC").
   */
  protocol: string;
  /**
   * Key Exchange used by the connection, or the empty string if not applicable.
   */
  keyExchange: string;
  /**
   * (EC)DH group used by the connection, if applicable.
   */
  keyExchangeGroup?: string;
  /**
   * Cipher name.
   */
  cipher: string;
  /**
   * TLS MAC. Note that AEAD ciphers do not have separate MACs.
   */
  mac?: string;
  /**
   * Page certificate.
   */
  certificate: string[];
  /**
   * Certificate subject name.
   */
  subjectName: string;
  /**
   * Name of the issuing CA.
   */
  issuer: string;
  /**
   * Certificate valid from date.
   */
  validFrom: Network_TimeSinceEpoch;
  /**
   * Certificate valid to (expiration) date
   */
  validTo: Network_TimeSinceEpoch;
  /**
   * The highest priority network error code, if the certificate has an error.
   */
  certificateNetworkError?: string;
  /**
   * True if the certificate uses a weak signature aglorithm.
   */
  certificateHasWeakSignature: boolean;
  /**
   * True if the certificate has a SHA1 signature in the chain.
   */
  certificateHasSha1Signature: boolean;
  /**
   * True if modern SSL
   */
  modernSSL: boolean;
  /**
   * True if the connection is using an obsolete SSL protocol.
   */
  obsoleteSslProtocol: boolean;
  /**
   * True if the connection is using an obsolete SSL key exchange.
   */
  obsoleteSslKeyExchange: boolean;
  /**
   * True if the connection is using an obsolete SSL cipher.
   */
  obsoleteSslCipher: boolean;
  /**
   * True if the connection is using an obsolete SSL signature.
   */
  obsoleteSslSignature: boolean;
};

/**
 * @experimental
 */
export type Security_SafetyTipStatus = "badReputation" | "lookalike";

/**
 * @experimental
 */
export type Security_SafetyTipInfo = {
  /**
   * Describes whether the page triggers any safety tips or reputation warnings. Default is unknown.
   */
  safetyTipStatus: Security_SafetyTipStatus;
  /**
   * The URL the safety tip suggested ("Did you mean?"). Only filled in for lookalike matches.
   */
  safeUrl?: string;
};

/**
 * @experimental
 * Security state information about the page.
 */
export type Security_VisibleSecurityState = {
  /**
   * The security level of the page.
   */
  securityState: Security_SecurityState;
  /**
   * Security state details about the page certificate.
   */
  certificateSecurityState?: Security_CertificateSecurityState;
  /**
   * The type of Safety Tip triggered on the page. Note that this field will be set even if the Safety Tip UI was not actually shown.
   */
  safetyTipInfo?: Security_SafetyTipInfo;
  /**
   * Array of security state issues ids.
   */
  securityStateIssueIds: string[];
};

/**
 * An explanation of an factor contributing to the security state.
 */
export type Security_SecurityStateExplanation = {
  /**
   * Security state representing the severity of the factor being explained.
   */
  securityState: Security_SecurityState;
  /**
   * Title describing the type of factor.
   */
  title: string;
  /**
   * Short phrase describing the type of factor.
   */
  summary: string;
  /**
   * Full text explanation of the factor.
   */
  description: string;
  /**
   * The type of mixed content described by the explanation.
   */
  mixedContentType: Security_MixedContentType;
  /**
   * Page certificate.
   */
  certificate: string[];
  /**
   * Recommendations to fix any issues.
   */
  recommendations?: string[];
};

/**
 * @deprecated
 * Information about insecure content on the page.
 */
export type Security_InsecureContentStatus = {
  /**
   * Always false.
   */
  ranMixedContent: boolean;
  /**
   * Always false.
   */
  displayedMixedContent: boolean;
  /**
   * Always false.
   */
  containedMixedForm: boolean;
  /**
   * Always false.
   */
  ranContentWithCertErrors: boolean;
  /**
   * Always false.
   */
  displayedContentWithCertErrors: boolean;
  /**
   * Always set to unknown.
   */
  ranInsecureContentStyle: Security_SecurityState;
  /**
   * Always set to unknown.
   */
  displayedInsecureContentStyle: Security_SecurityState;
};

/**
 * The action to take when a certificate error occurs. continue will continue processing the
 * request and cancel will cancel the request.
 */
export type Security_CertificateErrorAction = "continue" | "cancel";

// ----------------- ServiceWorker -----------------

export type ServiceWorker_RegistrationID = string;

/**
 * ServiceWorker registration.
 */
export type ServiceWorker_ServiceWorkerRegistration = {
  registrationId: ServiceWorker_RegistrationID;
  scopeURL: string;
  isDeleted: boolean;
};

export type ServiceWorker_ServiceWorkerVersionRunningStatus =
  | "stopped"
  | "starting"
  | "running"
  | "stopping";

export type ServiceWorker_ServiceWorkerVersionStatus =
  | "new"
  | "installing"
  | "installed"
  | "activating"
  | "activated"
  | "redundant";

/**
 * ServiceWorker version.
 */
export type ServiceWorker_ServiceWorkerVersion = {
  versionId: string;
  registrationId: ServiceWorker_RegistrationID;
  scriptURL: string;
  runningStatus: ServiceWorker_ServiceWorkerVersionRunningStatus;
  status: ServiceWorker_ServiceWorkerVersionStatus;
  /**
   * The Last-Modified header value of the main script.
   */
  scriptLastModified?: number;
  /**
   * The time at which the response headers of the main script were received from the server.
   * For cached script it is the last time the cache entry was validated.
   */
  scriptResponseTime?: number;
  controlledClients?: Target_TargetID[];
  targetId?: Target_TargetID;
};

/**
 * ServiceWorker error message.
 */
export type ServiceWorker_ServiceWorkerErrorMessage = {
  errorMessage: string;
  registrationId: ServiceWorker_RegistrationID;
  versionId: string;
  sourceURL: string;
  lineNumber: number;
  columnNumber: number;
};

// ----------------- Storage -----------------

export type Storage_SerializedStorageKey = string;

/**
 * Enum of possible storage types.
 */
export type Storage_StorageType =
  | "appcache"
  | "cookies"
  | "file_systems"
  | "indexeddb"
  | "local_storage"
  | "shader_cache"
  | "websql"
  | "service_workers"
  | "cache_storage"
  | "interest_groups"
  | "shared_storage"
  | "storage_buckets"
  | "all"
  | "other";

/**
 * Usage for a storage type.
 */
export type Storage_UsageForType = {
  /**
   * Name of storage type.
   */
  storageType: Storage_StorageType;
  /**
   * Storage usage (bytes).
   */
  usage: number;
};

/**
 * @experimental
 * Pair of issuer origin and number of available (signed, but not used) Trust
 * Tokens from that issuer.
 */
export type Storage_TrustTokens = {
  issuerOrigin: string;
  count: number;
};

/**
 * Enum of interest group access types.
 */
export type Storage_InterestGroupAccessType =
  | "join"
  | "leave"
  | "update"
  | "loaded"
  | "bid"
  | "win";

/**
 * Ad advertising element inside an interest group.
 */
export type Storage_InterestGroupAd = {
  renderUrl: string;
  metadata?: string;
};

/**
 * The full details of an interest group.
 */
export type Storage_InterestGroupDetails = {
  ownerOrigin: string;
  name: string;
  expirationTime: Network_TimeSinceEpoch;
  joiningOrigin: string;
  biddingUrl?: string;
  biddingWasmHelperUrl?: string;
  updateUrl?: string;
  trustedBiddingSignalsUrl?: string;
  trustedBiddingSignalsKeys: string[];
  userBiddingSignals?: string;
  ads: Storage_InterestGroupAd[];
  adComponents: Storage_InterestGroupAd[];
};

/**
 * Enum of shared storage access types.
 */
export type Storage_SharedStorageAccessType =
  | "documentAddModule"
  | "documentSelectURL"
  | "documentRun"
  | "documentSet"
  | "documentAppend"
  | "documentDelete"
  | "documentClear"
  | "workletSet"
  | "workletAppend"
  | "workletDelete"
  | "workletClear"
  | "workletGet"
  | "workletKeys"
  | "workletEntries"
  | "workletLength"
  | "workletRemainingBudget";

/**
 * Struct for a single key-value pair in an origin's shared storage.
 */
export type Storage_SharedStorageEntry = {
  key: string;
  value: string;
};

/**
 * Details for an origin's shared storage.
 */
export type Storage_SharedStorageMetadata = {
  creationTime: Network_TimeSinceEpoch;
  length: number;
  remainingBudget: number;
};

/**
 * Pair of reporting metadata details for a candidate URL for `selectURL()`.
 */
export type Storage_SharedStorageReportingMetadata = {
  eventType: string;
  reportingUrl: string;
};

/**
 * Bundles a candidate URL with its reporting metadata.
 */
export type Storage_SharedStorageUrlWithMetadata = {
  /**
   * Spec of candidate URL.
   */
  url: string;
  /**
   * Any associated reporting metadata.
   */
  reportingMetadata: Storage_SharedStorageReportingMetadata[];
};

/**
 * Bundles the parameters for shared storage access events whose
 * presence/absence can vary according to SharedStorageAccessType.
 */
export type Storage_SharedStorageAccessParams = {
  /**
   * Spec of the module script URL.
   * Present only for SharedStorageAccessType.documentAddModule.
   */
  scriptSourceUrl?: string;
  /**
   * Name of the registered operation to be run.
   * Present only for SharedStorageAccessType.documentRun and
   * SharedStorageAccessType.documentSelectURL.
   */
  operationName?: string;
  /**
   * The operation's serialized data in bytes (converted to a string).
   * Present only for SharedStorageAccessType.documentRun and
   * SharedStorageAccessType.documentSelectURL.
   */
  serializedData?: string;
  /**
   * Array of candidate URLs' specs, along with any associated metadata.
   * Present only for SharedStorageAccessType.documentSelectURL.
   */
  urlsWithMetadata?: Storage_SharedStorageUrlWithMetadata[];
  /**
   * Key for a specific entry in an origin's shared storage.
   * Present only for SharedStorageAccessType.documentSet,
   * SharedStorageAccessType.documentAppend,
   * SharedStorageAccessType.documentDelete,
   * SharedStorageAccessType.workletSet,
   * SharedStorageAccessType.workletAppend,
   * SharedStorageAccessType.workletDelete, and
   * SharedStorageAccessType.workletGet.
   */
  key?: string;
  /**
   * Value for a specific entry in an origin's shared storage.
   * Present only for SharedStorageAccessType.documentSet,
   * SharedStorageAccessType.documentAppend,
   * SharedStorageAccessType.workletSet, and
   * SharedStorageAccessType.workletAppend.
   */
  value?: string;
  /**
   * Whether or not to set an entry for a key if that key is already present.
   * Present only for SharedStorageAccessType.documentSet and
   * SharedStorageAccessType.workletSet.
   */
  ignoreIfPresent?: boolean;
};

export type Storage_StorageBucketsDurability = "relaxed" | "strict";

export type Storage_StorageBucket = {
  storageKey: Storage_SerializedStorageKey;
  /**
   * If not specified, it is the default bucket of the storageKey.
   */
  name?: string;
};

export type Storage_StorageBucketInfo = {
  bucket: Storage_StorageBucket;
  id: string;
  expiration: Network_TimeSinceEpoch;
  /**
   * Storage quota (bytes).
   */
  quota: number;
  persistent: boolean;
  durability: Storage_StorageBucketsDurability;
};

/**
 * @experimental
 */
export type Storage_AttributionReportingSourceType = "navigation" | "event";

/**
 * @experimental
 */
export type Storage_UnsignedInt64AsBase10 = string;

/**
 * @experimental
 */
export type Storage_UnsignedInt128AsBase16 = string;

/**
 * @experimental
 */
export type Storage_SignedInt64AsBase10 = string;

/**
 * @experimental
 */
export type Storage_AttributionReportingFilterDataEntry = {
  key: string;
  values: string[];
};

/**
 * @experimental
 */
export type Storage_AttributionReportingAggregationKeysEntry = {
  key: string;
  value: Storage_UnsignedInt128AsBase16;
};

/**
 * @experimental
 */
export type Storage_AttributionReportingSourceRegistration = {
  time: Network_TimeSinceEpoch;
  /**
   * duration in seconds
   */
  expiry?: number;
  /**
   * duration in seconds
   */
  eventReportWindow?: number;
  /**
   * duration in seconds
   */
  aggregatableReportWindow?: number;
  type: Storage_AttributionReportingSourceType;
  sourceOrigin: string;
  reportingOrigin: string;
  destinationSites: string[];
  eventId: Storage_UnsignedInt64AsBase10;
  priority: Storage_SignedInt64AsBase10;
  filterData: Storage_AttributionReportingFilterDataEntry[];
  aggregationKeys: Storage_AttributionReportingAggregationKeysEntry[];
  debugKey?: Storage_UnsignedInt64AsBase10;
};

/**
 * @experimental
 */
export type Storage_AttributionReportingSourceRegistrationResult =
  | "success"
  | "internalError"
  | "insufficientSourceCapacity"
  | "insufficientUniqueDestinationCapacity"
  | "excessiveReportingOrigins"
  | "prohibitedByBrowserPolicy"
  | "successNoised"
  | "destinationReportingLimitReached"
  | "destinationGlobalLimitReached"
  | "destinationBothLimitsReached"
  | "reportingOriginsPerSiteLimitReached";

// ----------------- SystemInfo -----------------

/**
 * Describes a single graphics processor (GPU).
 */
export type SystemInfo_GPUDevice = {
  /**
   * PCI ID of the GPU vendor, if available; 0 otherwise.
   */
  vendorId: number;
  /**
   * PCI ID of the GPU device, if available; 0 otherwise.
   */
  deviceId: number;
  /**
   * Sub sys ID of the GPU, only available on Windows.
   */
  subSysId?: number;
  /**
   * Revision of the GPU, only available on Windows.
   */
  revision?: number;
  /**
   * String description of the GPU vendor, if the PCI ID is not available.
   */
  vendorString: string;
  /**
   * String description of the GPU device, if the PCI ID is not available.
   */
  deviceString: string;
  /**
   * String description of the GPU driver vendor.
   */
  driverVendor: string;
  /**
   * String description of the GPU driver version.
   */
  driverVersion: string;
};

/**
 * Describes the width and height dimensions of an entity.
 */
export type SystemInfo_Size = {
  /**
   * Width in pixels.
   */
  width: number;
  /**
   * Height in pixels.
   */
  height: number;
};

/**
 * Describes a supported video decoding profile with its associated minimum and
 * maximum resolutions.
 */
export type SystemInfo_VideoDecodeAcceleratorCapability = {
  /**
   * Video codec profile that is supported, e.g. VP9 Profile 2.
   */
  profile: string;
  /**
   * Maximum video dimensions in pixels supported for this |profile|.
   */
  maxResolution: SystemInfo_Size;
  /**
   * Minimum video dimensions in pixels supported for this |profile|.
   */
  minResolution: SystemInfo_Size;
};

/**
 * Describes a supported video encoding profile with its associated maximum
 * resolution and maximum framerate.
 */
export type SystemInfo_VideoEncodeAcceleratorCapability = {
  /**
   * Video codec profile that is supported, e.g H264 Main.
   */
  profile: string;
  /**
   * Maximum video dimensions in pixels supported for this |profile|.
   */
  maxResolution: SystemInfo_Size;
  /**
   * Maximum encoding framerate in frames per second supported for this
   * |profile|, as fraction's numerator and denominator, e.g. 24/1 fps,
   * 24000/1001 fps, etc.
   */
  maxFramerateNumerator: number;
  maxFramerateDenominator: number;
};

/**
 * YUV subsampling type of the pixels of a given image.
 */
export type SystemInfo_SubsamplingFormat = "yuv420" | "yuv422" | "yuv444";

/**
 * Image format of a given image.
 */
export type SystemInfo_ImageType = "jpeg" | "webp" | "unknown";

/**
 * Describes a supported image decoding profile with its associated minimum and
 * maximum resolutions and subsampling.
 */
export type SystemInfo_ImageDecodeAcceleratorCapability = {
  /**
   * Image coded, e.g. Jpeg.
   */
  imageType: SystemInfo_ImageType;
  /**
   * Maximum supported dimensions of the image in pixels.
   */
  maxDimensions: SystemInfo_Size;
  /**
   * Minimum supported dimensions of the image in pixels.
   */
  minDimensions: SystemInfo_Size;
  /**
   * Optional array of supported subsampling formats, e.g. 4:2:0, if known.
   */
  subsamplings: SystemInfo_SubsamplingFormat[];
};

/**
 * Provides information about the GPU(s) on the system.
 */
export type SystemInfo_GPUInfo = {
  /**
   * The graphics devices on the system. Element 0 is the primary GPU.
   */
  devices: SystemInfo_GPUDevice[];
  /**
   * An optional dictionary of additional GPU related attributes.
   */
  auxAttributes?: object;
  /**
   * An optional dictionary of graphics features and their status.
   */
  featureStatus?: object;
  /**
   * An optional array of GPU driver bug workarounds.
   */
  driverBugWorkarounds: string[];
  /**
   * Supported accelerated video decoding capabilities.
   */
  videoDecoding: SystemInfo_VideoDecodeAcceleratorCapability[];
  /**
   * Supported accelerated video encoding capabilities.
   */
  videoEncoding: SystemInfo_VideoEncodeAcceleratorCapability[];
  /**
   * Supported accelerated image decoding capabilities.
   */
  imageDecoding: SystemInfo_ImageDecodeAcceleratorCapability[];
};

/**
 * Represents process info.
 */
export type SystemInfo_ProcessInfo = {
  /**
   * Specifies process type.
   */
  type: string;
  /**
   * Specifies process id.
   */
  id: number;
  /**
   * Specifies cumulative CPU usage in seconds across all threads of the
   * process since the process start.
   */
  cpuTime: number;
};

// ----------------- Target -----------------

export type Target_TargetID = string;

/**
 * Unique identifier of attached debugging session.
 */
export type Target_SessionID = string;

export type Target_TargetInfo = {
  targetId: Target_TargetID;
  type: string;
  title: string;
  url: string;
  /**
   * Whether the target has an attached client.
   */
  attached: boolean;
  /**
   * Opener target Id
   */
  openerId?: Target_TargetID;
  /**
   * @experimental
   * Whether the target has access to the originating window.
   */
  canAccessOpener: boolean;
  /**
   * @experimental
   * Frame id of originating window (is only set if target has an opener).
   */
  openerFrameId?: Page_FrameId;
  /**
   * @experimental
   */
  browserContextId?: Browser_BrowserContextID;
  /**
   * @experimental
   * Provides additional details for specific target types. For example, for
   * the type of "page", this may be set to "portal" or "prerender".
   */
  subtype?: string;
};

/**
 * @experimental
 * A filter used by target query/discovery/auto-attach operations.
 */
export type Target_FilterEntry = {
  /**
   * If set, causes exclusion of mathcing targets from the list.
   */
  exclude?: boolean;
  /**
   * If not present, matches any type.
   */
  type?: string;
};

/**
 * @experimental
 * The entries in TargetFilter are matched sequentially against targets and
 * the first entry that matches determines if the target is included or not,
 * depending on the value of `exclude` field in the entry.
 * If filter is not specified, the one assumed is
 * [{type: "browser", exclude: true}, {type: "tab", exclude: true}, {}]
 * (i.e. include everything but `browser` and `tab`).
 */
export type Target_TargetFilter = Target_FilterEntry[];

/**
 * @experimental
 */
export type Target_RemoteLocation = {
  host: string;
  port: number;
};

// ----------------- Tethering -----------------

// ----------------- Tracing -----------------

/**
 * Configuration for memory dump. Used only when "memory-infra" category is enabled.
 */
export type Tracing_MemoryDumpConfig = object;

export type Tracing_TraceConfig = {
  /**
   * Controls how the trace buffer stores data.
   */
  recordMode?:
    | "recordUntilFull"
    | "recordContinuously"
    | "recordAsMuchAsPossible"
    | "echoToConsole";
  /**
   * Size of the trace buffer in kilobytes. If not specified or zero is passed, a default value
   * of 200 MB would be used.
   */
  traceBufferSizeInKb?: number;
  /**
   * Turns on JavaScript stack sampling.
   */
  enableSampling?: boolean;
  /**
   * Turns on system tracing.
   */
  enableSystrace?: boolean;
  /**
   * Turns on argument filter.
   */
  enableArgumentFilter?: boolean;
  /**
   * Included category filters.
   */
  includedCategories?: string[];
  /**
   * Excluded category filters.
   */
  excludedCategories?: string[];
  /**
   * Configuration to synthesize the delays in tracing.
   */
  syntheticDelays?: string[];
  /**
   * Configuration for memory dump triggers. Used only when "memory-infra" category is enabled.
   */
  memoryDumpConfig?: Tracing_MemoryDumpConfig;
};

/**
 * Data format of a trace. Can be either the legacy JSON format or the
 * protocol buffer format. Note that the JSON format will be deprecated soon.
 */
export type Tracing_StreamFormat = "json" | "proto";

/**
 * Compression type to use for traces returned via streams.
 */
export type Tracing_StreamCompression = "none" | "gzip";

/**
 * Details exposed when memory request explicitly declared.
 * Keep consistent with memory_dump_request_args.h and
 * memory_instrumentation.mojom
 */
export type Tracing_MemoryDumpLevelOfDetail =
  | "background"
  | "light"
  | "detailed";

/**
 * Backend type to use for tracing. `chrome` uses the Chrome-integrated
 * tracing service and is supported on all platforms. `system` is only
 * supported on Chrome OS and uses the Perfetto system tracing service.
 * `auto` chooses `system` when the perfettoConfig provided to Tracing.start
 * specifies at least one non-Chrome data source; otherwise uses `chrome`.
 */
export type Tracing_TracingBackend = "auto" | "chrome" | "system";

// ----------------- Fetch -----------------

/**
 * Unique request identifier.
 */
export type Fetch_RequestId = string;

/**
 * Stages of the request to handle. Request will intercept before the request is
 * sent. Response will intercept after the response is received (but before response
 * body is received).
 */
export type Fetch_RequestStage = "Request" | "Response";

export type Fetch_RequestPattern = {
  /**
   * Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is
   * backslash. Omitting is equivalent to `"*"`.
   */
  urlPattern?: string;
  /**
   * If set, only requests for matching resource types will be intercepted.
   */
  resourceType?: Network_ResourceType;
  /**
   * Stage at which to begin intercepting requests. Default is Request.
   */
  requestStage?: Fetch_RequestStage;
};

/**
 * Response HTTP header entry
 */
export type Fetch_HeaderEntry = {
  name: string;
  value: string;
};

/**
 * Authorization challenge for HTTP status code 401 or 407.
 */
export type Fetch_AuthChallenge = {
  /**
   * Source of the authentication challenge.
   */
  source?: "Server" | "Proxy";
  /**
   * Origin of the challenger.
   */
  origin: string;
  /**
   * The authentication scheme used, such as basic or digest
   */
  scheme: string;
  /**
   * The realm of the challenge. May be empty.
   */
  realm: string;
};

/**
 * Response to an AuthChallenge.
 */
export type Fetch_AuthChallengeResponse = {
  /**
   * The decision on what to do in response to the authorization challenge.  Default means
   * deferring to the default behavior of the net stack, which will likely either the Cancel
   * authentication or display a popup dialog box.
   */
  response: "Default" | "CancelAuth" | "ProvideCredentials";
  /**
   * The username to provide, possibly empty. Should only be set if response is
   * ProvideCredentials.
   */
  username?: string;
  /**
   * The password to provide, possibly empty. Should only be set if response is
   * ProvideCredentials.
   */
  password?: string;
};

// ----------------- WebAudio -----------------

/**
 * An unique ID for a graph object (AudioContext, AudioNode, AudioParam) in Web Audio API
 */
export type WebAudio_GraphObjectId = string;

/**
 * Enum of BaseAudioContext types
 */
export type WebAudio_ContextType = "realtime" | "offline";

/**
 * Enum of AudioContextState from the spec
 */
export type WebAudio_ContextState = "suspended" | "running" | "closed";

/**
 * Enum of AudioNode types
 */
export type WebAudio_NodeType = string;

/**
 * Enum of AudioNode::ChannelCountMode from the spec
 */
export type WebAudio_ChannelCountMode = "clamped-max" | "explicit" | "max";

/**
 * Enum of AudioNode::ChannelInterpretation from the spec
 */
export type WebAudio_ChannelInterpretation = "discrete" | "speakers";

/**
 * Enum of AudioParam types
 */
export type WebAudio_ParamType = string;

/**
 * Enum of AudioParam::AutomationRate from the spec
 */
export type WebAudio_AutomationRate = "a-rate" | "k-rate";

/**
 * Fields in AudioContext that change in real-time.
 */
export type WebAudio_ContextRealtimeData = {
  /**
   * The current context time in second in BaseAudioContext.
   */
  currentTime: number;
  /**
   * The time spent on rendering graph divided by render quantum duration,
   * and multiplied by 100. 100 means the audio renderer reached the full
   * capacity and glitch may occur.
   */
  renderCapacity: number;
  /**
   * A running mean of callback interval.
   */
  callbackIntervalMean: number;
  /**
   * A running variance of callback interval.
   */
  callbackIntervalVariance: number;
};

/**
 * Protocol object for BaseAudioContext
 */
export type WebAudio_BaseAudioContext = {
  contextId: WebAudio_GraphObjectId;
  contextType: WebAudio_ContextType;
  contextState: WebAudio_ContextState;
  realtimeData?: WebAudio_ContextRealtimeData;
  /**
   * Platform-dependent callback buffer size.
   */
  callbackBufferSize: number;
  /**
   * Number of output channels supported by audio hardware in use.
   */
  maxOutputChannelCount: number;
  /**
   * Context sample rate.
   */
  sampleRate: number;
};

/**
 * Protocol object for AudioListener
 */
export type WebAudio_AudioListener = {
  listenerId: WebAudio_GraphObjectId;
  contextId: WebAudio_GraphObjectId;
};

/**
 * Protocol object for AudioNode
 */
export type WebAudio_AudioNode = {
  nodeId: WebAudio_GraphObjectId;
  contextId: WebAudio_GraphObjectId;
  nodeType: WebAudio_NodeType;
  numberOfInputs: number;
  numberOfOutputs: number;
  channelCount: number;
  channelCountMode: WebAudio_ChannelCountMode;
  channelInterpretation: WebAudio_ChannelInterpretation;
};

/**
 * Protocol object for AudioParam
 */
export type WebAudio_AudioParam = {
  paramId: WebAudio_GraphObjectId;
  nodeId: WebAudio_GraphObjectId;
  contextId: WebAudio_GraphObjectId;
  paramType: WebAudio_ParamType;
  rate: WebAudio_AutomationRate;
  defaultValue: number;
  minValue: number;
  maxValue: number;
};

// ----------------- WebAuthn -----------------

export type WebAuthn_AuthenticatorId = string;

export type WebAuthn_AuthenticatorProtocol = "u2f" | "ctap2";

export type WebAuthn_Ctap2Version = "ctap2_0" | "ctap2_1";

export type WebAuthn_AuthenticatorTransport =
  | "usb"
  | "nfc"
  | "ble"
  | "cable"
  | "internal";

export type WebAuthn_VirtualAuthenticatorOptions = {
  protocol: WebAuthn_AuthenticatorProtocol;
  /**
   * Defaults to ctap2_0. Ignored if |protocol| == u2f.
   */
  ctap2Version?: WebAuthn_Ctap2Version;
  transport: WebAuthn_AuthenticatorTransport;
  /**
   * Defaults to false.
   */
  hasResidentKey?: boolean;
  /**
   * Defaults to false.
   */
  hasUserVerification?: boolean;
  /**
   * If set to true, the authenticator will support the largeBlob extension.
   * https://w3c.github.io/webauthn#largeBlob
   * Defaults to false.
   */
  hasLargeBlob?: boolean;
  /**
   * If set to true, the authenticator will support the credBlob extension.
   * https://fidoalliance.org/specs/fido-v2.1-rd-20201208/fido-client-to-authenticator-protocol-v2.1-rd-20201208.html#sctn-credBlob-extension
   * Defaults to false.
   */
  hasCredBlob?: boolean;
  /**
   * If set to true, the authenticator will support the minPinLength extension.
   * https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-20210615.html#sctn-minpinlength-extension
   * Defaults to false.
   */
  hasMinPinLength?: boolean;
  /**
   * If set to true, the authenticator will support the prf extension.
   * https://w3c.github.io/webauthn/#prf-extension
   * Defaults to false.
   */
  hasPrf?: boolean;
  /**
   * If set to true, tests of user presence will succeed immediately.
   * Otherwise, they will not be resolved. Defaults to true.
   */
  automaticPresenceSimulation?: boolean;
  /**
   * Sets whether User Verification succeeds or fails for an authenticator.
   * Defaults to false.
   */
  isUserVerified?: boolean;
};

export type WebAuthn_Credential = {
  credentialId: string;
  isResidentCredential: boolean;
  /**
   * Relying Party ID the credential is scoped to. Must be set when adding a
   * credential.
   */
  rpId?: string;
  /**
   * The ECDSA P-256 private key in PKCS#8 format.
   */
  privateKey: string;
  /**
   * An opaque byte sequence with a maximum size of 64 bytes mapping the
   * credential to a specific user.
   */
  userHandle?: string;
  /**
   * Signature counter. This is incremented by one for each successful
   * assertion.
   * See https://w3c.github.io/webauthn/#signature-counter
   */
  signCount: number;
  /**
   * The large blob associated with the credential.
   * See https://w3c.github.io/webauthn/#sctn-large-blob-extension
   */
  largeBlob?: string;
};

// ----------------- Media -----------------

/**
 * Players will get an ID that is unique within the agent context.
 */
export type Media_PlayerId = string;

export type Media_Timestamp = number;

/**
 * Have one type per entry in MediaLogRecord::Type
 * Corresponds to kMessage
 */
export type Media_PlayerMessage = {
  /**
   * Keep in sync with MediaLogMessageLevel
   * We are currently keeping the message level 'error' separate from the
   * PlayerError type because right now they represent different things,
   * this one being a DVLOG(ERROR) style log message that gets printed
   * based on what log level is selected in the UI, and the other is a
   * representation of a media::PipelineStatus object. Soon however we're
   * going to be moving away from using PipelineStatus for errors and
   * introducing a new error type which should hopefully let us integrate
   * the error log level into the PlayerError type.
   */
  level: "error" | "warning" | "info" | "debug";
  message: string;
};

/**
 * Corresponds to kMediaPropertyChange
 */
export type Media_PlayerProperty = {
  name: string;
  value: string;
};

/**
 * Corresponds to kMediaEventTriggered
 */
export type Media_PlayerEvent = {
  timestamp: Media_Timestamp;
  value: string;
};

/**
 * Represents logged source line numbers reported in an error.
 * NOTE: file and line are from chromium c++ implementation code, not js.
 */
export type Media_PlayerErrorSourceLocation = {
  file: string;
  line: number;
};

/**
 * Corresponds to kMediaError
 */
export type Media_PlayerError = {
  errorType: string;
  /**
   * Code is the numeric enum entry for a specific set of error codes, such
   * as PipelineStatusCodes in media/base/pipeline_status.h
   */
  code: number;
  /**
   * A trace of where this error was caused / where it passed through.
   */
  stack: Media_PlayerErrorSourceLocation[];
  /**
   * Errors potentially have a root cause error, ie, a DecoderError might be
   * caused by an WindowsError
   */
  cause: Media_PlayerError[];
  /**
   * Extra data attached to an error, such as an HRESULT, Video Codec, etc.
   */
  data: object;
};

// ----------------- DeviceAccess -----------------

/**
 * Device request id.
 */
export type DeviceAccess_RequestId = string;

/**
 * A device id.
 */
export type DeviceAccess_DeviceId = string;

/**
 * Device information displayed in a user prompt to select a device.
 */
export type DeviceAccess_PromptDevice = {
  id: DeviceAccess_DeviceId;
  /**
   * Display name as it appears in a device request user prompt.
   */
  name: string;
};

// ----------------- Preload -----------------

/**
 * Unique id
 */
export type Preload_RuleSetId = string;

/**
 * Corresponds to SpeculationRuleSet
 */
export type Preload_RuleSet = {
  id: Preload_RuleSetId;
  /**
   * Identifies a document which the rule set is associated with.
   */
  loaderId: Network_LoaderId;
  /**
   * Source text of JSON representing the rule set. If it comes from
   * `<script>` tag, it is the textContent of the node. Note that it is
   * a JSON for valid case.
   *
   * See also:
   * - https://wicg.github.io/nav-speculation/speculation-rules.html
   * - https://github.com/WICG/nav-speculation/blob/main/triggers.md
   */
  sourceText: string;
  /**
   * A speculation rule set is either added through an inline
   * `<script>` tag or through an external resource via the
   * 'Speculation-Rules' HTTP header. For the first case, we include
   * the BackendNodeId of the relevant `<script>` tag. For the second
   * case, we include the external URL where the rule set was loaded
   * from, and also RequestId if Network domain is enabled.
   *
   * See also:
   * - https://wicg.github.io/nav-speculation/speculation-rules.html#speculation-rules-script
   * - https://wicg.github.io/nav-speculation/speculation-rules.html#speculation-rules-header
   */
  backendNodeId?: DOM_BackendNodeId;
  url?: string;
  requestId?: Network_RequestId;
  /**
   * Error information
   * `errorMessage` is null iff `errorType` is null.
   */
  errorType?: Preload_RuleSetErrorType;
  /**
   * @deprecated
   * TODO(https://crbug.com/1425354): Replace this property with structured error.
   */
  errorMessage?: string;
};

export type Preload_RuleSetErrorType =
  | "SourceIsNotJsonObject"
  | "InvalidRulesSkipped";

/**
 * The type of preloading attempted. It corresponds to
 * mojom::SpeculationAction (although PrefetchWithSubresources is omitted as it
 * isn't being used by clients).
 */
export type Preload_SpeculationAction = "Prefetch" | "Prerender";

/**
 * Corresponds to mojom::SpeculationTargetHint.
 * See https://github.com/WICG/nav-speculation/blob/main/triggers.md#window-name-targeting-hints
 */
export type Preload_SpeculationTargetHint = "Blank" | "Self";

/**
 * A key that identifies a preloading attempt.
 *
 * The url used is the url specified by the trigger (i.e. the initial URL), and
 * not the final url that is navigated to. For example, prerendering allows
 * same-origin main frame navigations during the attempt, but the attempt is
 * still keyed with the initial URL.
 */
export type Preload_PreloadingAttemptKey = {
  loaderId: Network_LoaderId;
  action: Preload_SpeculationAction;
  url: string;
  targetHint?: Preload_SpeculationTargetHint;
};

/**
 * Lists sources for a preloading attempt, specifically the ids of rule sets
 * that had a speculation rule that triggered the attempt, and the
 * BackendNodeIds of <a href> or <area href> elements that triggered the
 * attempt (in the case of attempts triggered by a document rule). It is
 * possible for mulitple rule sets and links to trigger a single attempt.
 */
export type Preload_PreloadingAttemptSource = {
  key: Preload_PreloadingAttemptKey;
  ruleSetIds: Preload_RuleSetId[];
  nodeIds: DOM_BackendNodeId[];
};

/**
 * List of FinalStatus reasons for Prerender2.
 */
export type Preload_PrerenderFinalStatus =
  | "Activated"
  | "Destroyed"
  | "LowEndDevice"
  | "InvalidSchemeRedirect"
  | "InvalidSchemeNavigation"
  | "InProgressNavigation"
  | "NavigationRequestBlockedByCsp"
  | "MainFrameNavigation"
  | "MojoBinderPolicy"
  | "RendererProcessCrashed"
  | "RendererProcessKilled"
  | "Download"
  | "TriggerDestroyed"
  | "NavigationNotCommitted"
  | "NavigationBadHttpStatus"
  | "ClientCertRequested"
  | "NavigationRequestNetworkError"
  | "MaxNumOfRunningPrerendersExceeded"
  | "CancelAllHostsForTesting"
  | "DidFailLoad"
  | "Stop"
  | "SslCertificateError"
  | "LoginAuthRequested"
  | "UaChangeRequiresReload"
  | "BlockedByClient"
  | "AudioOutputDeviceRequested"
  | "MixedContent"
  | "TriggerBackgrounded"
  | "MemoryLimitExceeded"
  | "FailToGetMemoryUsage"
  | "DataSaverEnabled"
  | "HasEffectiveUrl"
  | "ActivatedBeforeStarted"
  | "InactivePageRestriction"
  | "StartFailed"
  | "TimeoutBackgrounded"
  | "CrossSiteRedirectInInitialNavigation"
  | "CrossSiteNavigationInInitialNavigation"
  | "SameSiteCrossOriginRedirectNotOptInInInitialNavigation"
  | "SameSiteCrossOriginNavigationNotOptInInInitialNavigation"
  | "ActivationNavigationParameterMismatch"
  | "ActivatedInBackground"
  | "EmbedderHostDisallowed"
  | "ActivationNavigationDestroyedBeforeSuccess"
  | "TabClosedByUserGesture"
  | "TabClosedWithoutUserGesture"
  | "PrimaryMainFrameRendererProcessCrashed"
  | "PrimaryMainFrameRendererProcessKilled"
  | "ActivationFramePolicyNotCompatible"
  | "PreloadingDisabled"
  | "BatterySaverEnabled"
  | "ActivatedDuringMainFrameNavigation"
  | "PreloadingUnsupportedByWebContents"
  | "CrossSiteRedirectInMainFrameNavigation"
  | "CrossSiteNavigationInMainFrameNavigation"
  | "SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation"
  | "SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation"
  | "MemoryPressureOnTrigger"
  | "MemoryPressureAfterTriggered"
  | "PrerenderingDisabledByDevTools"
  | "ResourceLoadBlockedByClient"
  | "SpeculationRuleRemoved"
  | "ActivatedWithAuxiliaryBrowsingContexts";

/**
 * Preloading status values, see also PreloadingTriggeringOutcome. This
 * status is shared by prefetchStatusUpdated and prerenderStatusUpdated.
 */
export type Preload_PreloadingStatus =
  | "Pending"
  | "Running"
  | "Ready"
  | "Success"
  | "Failure"
  | "NotSupported";

/**
 * TODO(https://crbug.com/1384419): revisit the list of PrefetchStatus and
 * filter out the ones that aren't necessary to the developers.
 */
export type Preload_PrefetchStatus =
  | "PrefetchAllowed"
  | "PrefetchFailedIneligibleRedirect"
  | "PrefetchFailedInvalidRedirect"
  | "PrefetchFailedMIMENotSupported"
  | "PrefetchFailedNetError"
  | "PrefetchFailedNon2XX"
  | "PrefetchFailedPerPageLimitExceeded"
  | "PrefetchEvicted"
  | "PrefetchHeldback"
  | "PrefetchIneligibleRetryAfter"
  | "PrefetchIsPrivacyDecoy"
  | "PrefetchIsStale"
  | "PrefetchNotEligibleBrowserContextOffTheRecord"
  | "PrefetchNotEligibleDataSaverEnabled"
  | "PrefetchNotEligibleExistingProxy"
  | "PrefetchNotEligibleHostIsNonUnique"
  | "PrefetchNotEligibleNonDefaultStoragePartition"
  | "PrefetchNotEligibleSameSiteCrossOriginPrefetchRequiredProxy"
  | "PrefetchNotEligibleSchemeIsNotHttps"
  | "PrefetchNotEligibleUserHasCookies"
  | "PrefetchNotEligibleUserHasServiceWorker"
  | "PrefetchNotEligibleBatterySaverEnabled"
  | "PrefetchNotEligiblePreloadingDisabled"
  | "PrefetchNotFinishedInTime"
  | "PrefetchNotStarted"
  | "PrefetchNotUsedCookiesChanged"
  | "PrefetchProxyNotAvailable"
  | "PrefetchResponseUsed"
  | "PrefetchSuccessfulButNotUsed"
  | "PrefetchNotUsedProbeFailed";

// ----------------- FedCm -----------------

/**
 * Whether this is a sign-up or sign-in action for this account, i.e.
 * whether this account has ever been used to sign in to this RP before.
 */
export type FedCm_LoginState = "SignIn" | "SignUp";

/**
 * Whether the dialog shown is an account chooser or an auto re-authentication dialog.
 */
export type FedCm_DialogType = "AccountChooser" | "AutoReauthn";

/**
 * Corresponds to IdentityRequestAccount
 */
export type FedCm_Account = {
  accountId: string;
  email: string;
  name: string;
  givenName: string;
  pictureUrl: string;
  idpConfigUrl: string;
  idpSigninUrl: string;
  loginState: FedCm_LoginState;
  /**
   * These two are only set if the loginState is signUp
   */
  termsOfServiceUrl?: string;
  privacyPolicyUrl?: string;
};

// ----------------- Console -----------------

/**
 * Console message.
 */
export type Console_ConsoleMessage = {
  /**
   * Message source.
   */
  source:
    | "xml"
    | "javascript"
    | "network"
    | "console-api"
    | "storage"
    | "appcache"
    | "rendering"
    | "security"
    | "other"
    | "deprecation"
    | "worker";
  /**
   * Message severity.
   */
  level: "log" | "warning" | "error" | "debug" | "info";
  /**
   * Message text.
   */
  text: string;
  /**
   * URL of the message origin.
   */
  url?: string;
  /**
   * Line number in the resource that generated this message (1-based).
   */
  line?: number;
  /**
   * Column number in the resource that generated this message (1-based).
   */
  column?: number;
};

// ----------------- Debugger -----------------

/**
 * Breakpoint identifier.
 */
export type Debugger_BreakpointId = string;

/**
 * Call frame identifier.
 */
export type Debugger_CallFrameId = string;

/**
 * Location in the source code.
 */
export type Debugger_Location = {
  /**
   * Script identifier as reported in the `Debugger.scriptParsed`.
   */
  scriptId: Runtime_ScriptId;
  /**
   * Line number in the script (0-based).
   */
  lineNumber: number;
  /**
   * Column number in the script (0-based).
   */
  columnNumber?: number;
};

/**
 * @experimental
 * Location in the source code.
 */
export type Debugger_ScriptPosition = {
  lineNumber: number;
  columnNumber: number;
};

/**
 * @experimental
 * Location range within one script.
 */
export type Debugger_LocationRange = {
  scriptId: Runtime_ScriptId;
  start: Debugger_ScriptPosition;
  end: Debugger_ScriptPosition;
};

/**
 * JavaScript call frame. Array of call frames form the call stack.
 */
export type Debugger_CallFrame = {
  /**
   * Call frame identifier. This identifier is only valid while the virtual machine is paused.
   */
  callFrameId: Debugger_CallFrameId;
  /**
   * Name of the JavaScript function called on this call frame.
   */
  functionName: string;
  /**
   * Location in the source code.
   */
  functionLocation?: Debugger_Location;
  /**
   * Location in the source code.
   */
  location: Debugger_Location;
  /**
   * @deprecated
   * JavaScript script name or url.
   * Deprecated in favor of using the `location.scriptId` to resolve the URL via a previously
   * sent `Debugger.scriptParsed` event.
   */
  url: string;
  /**
   * Scope chain for this call frame.
   */
  scopeChain: Debugger_Scope[];
  /**
   * `this` object for this call frame.
   */
  this: Runtime_RemoteObject;
  /**
   * The value being returned, if the function is at return point.
   */
  returnValue?: Runtime_RemoteObject;
  /**
   * @experimental
   * Valid only while the VM is paused and indicates whether this frame
   * can be restarted or not. Note that a `true` value here does not
   * guarantee that Debugger#restartFrame with this CallFrameId will be
   * successful, but it is very likely.
   */
  canBeRestarted?: boolean;
};

/**
 * Scope description.
 */
export type Debugger_Scope = {
  /**
   * Scope type.
   */
  type:
    | "global"
    | "local"
    | "with"
    | "closure"
    | "catch"
    | "block"
    | "script"
    | "eval"
    | "module"
    | "wasm-expression-stack";
  /**
   * Object representing the scope. For `global` and `with` scopes it represents the actual
   * object; for the rest of the scopes, it is artificial transient object enumerating scope
   * variables as its properties.
   */
  object: Runtime_RemoteObject;
  name?: string;
  /**
   * Location in the source code where scope starts
   */
  startLocation?: Debugger_Location;
  /**
   * Location in the source code where scope ends
   */
  endLocation?: Debugger_Location;
};

/**
 * Search match for resource.
 */
export type Debugger_SearchMatch = {
  /**
   * Line number in resource content.
   */
  lineNumber: number;
  /**
   * Line with match content.
   */
  lineContent: string;
};

export type Debugger_BreakLocation = {
  /**
   * Script identifier as reported in the `Debugger.scriptParsed`.
   */
  scriptId: Runtime_ScriptId;
  /**
   * Line number in the script (0-based).
   */
  lineNumber: number;
  /**
   * Column number in the script (0-based).
   */
  columnNumber?: number;
  type?: "debuggerStatement" | "call" | "return";
};

/**
 * @experimental
 */
export type Debugger_WasmDisassemblyChunk = {
  /**
   * The next chunk of disassembled lines.
   */
  lines: string[];
  /**
   * The bytecode offsets describing the start of each line.
   */
  bytecodeOffsets: number[];
};

/**
 * Enum of possible script languages.
 */
export type Debugger_ScriptLanguage = "JavaScript" | "WebAssembly";

/**
 * Debug symbols available for a wasm script.
 */
export type Debugger_DebugSymbols = {
  /**
   * Type of the debug symbols.
   */
  type: "None" | "SourceMap" | "EmbeddedDWARF" | "ExternalDWARF";
  /**
   * URL of the external symbol source.
   */
  externalURL?: string;
};

// ----------------- HeapProfiler -----------------

/**
 * Heap snapshot object id.
 */
export type HeapProfiler_HeapSnapshotObjectId = string;

/**
 * Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.
 */
export type HeapProfiler_SamplingHeapProfileNode = {
  /**
   * Function location.
   */
  callFrame: Runtime_CallFrame;
  /**
   * Allocations size in bytes for the node excluding children.
   */
  selfSize: number;
  /**
   * Node id. Ids are unique across all profiles collected between startSampling and stopSampling.
   */
  id: number;
  /**
   * Child nodes.
   */
  children: HeapProfiler_SamplingHeapProfileNode[];
};

/**
 * A single sample from a sampling profile.
 */
export type HeapProfiler_SamplingHeapProfileSample = {
  /**
   * Allocation size in bytes attributed to the sample.
   */
  size: number;
  /**
   * Id of the corresponding profile tree node.
   */
  nodeId: number;
  /**
   * Time-ordered sample ordinal number. It is unique across all profiles retrieved
   * between startSampling and stopSampling.
   */
  ordinal: number;
};

/**
 * Sampling profile.
 */
export type HeapProfiler_SamplingHeapProfile = {
  head: HeapProfiler_SamplingHeapProfileNode;
  samples: HeapProfiler_SamplingHeapProfileSample[];
};

// ----------------- Profiler -----------------

/**
 * Profile node. Holds callsite information, execution statistics and child nodes.
 */
export type Profiler_ProfileNode = {
  /**
   * Unique id of the node.
   */
  id: number;
  /**
   * Function location.
   */
  callFrame: Runtime_CallFrame;
  /**
   * Number of samples where this node was on top of the call stack.
   */
  hitCount?: number;
  /**
   * Child node ids.
   */
  children?: number[];
  /**
   * The reason of being not optimized. The function may be deoptimized or marked as don't
   * optimize.
   */
  deoptReason?: string;
  /**
   * An array of source position ticks.
   */
  positionTicks?: Profiler_PositionTickInfo[];
};

/**
 * Profile.
 */
export type Profiler_Profile = {
  /**
   * The list of profile nodes. First item is the root node.
   */
  nodes: Profiler_ProfileNode[];
  /**
   * Profiling start timestamp in microseconds.
   */
  startTime: number;
  /**
   * Profiling end timestamp in microseconds.
   */
  endTime: number;
  /**
   * Ids of samples top nodes.
   */
  samples?: number[];
  /**
   * Time intervals between adjacent samples in microseconds. The first delta is relative to the
   * profile startTime.
   */
  timeDeltas?: number[];
};

/**
 * Specifies a number of samples attributed to a certain source position.
 */
export type Profiler_PositionTickInfo = {
  /**
   * Source line number (1-based).
   */
  line: number;
  /**
   * Number of samples attributed to the source line.
   */
  ticks: number;
};

/**
 * Coverage data for a source range.
 */
export type Profiler_CoverageRange = {
  /**
   * JavaScript script source offset for the range start.
   */
  startOffset: number;
  /**
   * JavaScript script source offset for the range end.
   */
  endOffset: number;
  /**
   * Collected execution count of the source range.
   */
  count: number;
};

/**
 * Coverage data for a JavaScript function.
 */
export type Profiler_FunctionCoverage = {
  /**
   * JavaScript function name.
   */
  functionName: string;
  /**
   * Source ranges inside the function with coverage data.
   */
  ranges: Profiler_CoverageRange[];
  /**
   * Whether coverage data for this function has block granularity.
   */
  isBlockCoverage: boolean;
};

/**
 * Coverage data for a JavaScript script.
 */
export type Profiler_ScriptCoverage = {
  /**
   * JavaScript script id.
   */
  scriptId: Runtime_ScriptId;
  /**
   * JavaScript script name or url.
   */
  url: string;
  /**
   * Functions contained in the script that has coverage data.
   */
  functions: Profiler_FunctionCoverage[];
};

// ----------------- Runtime -----------------

/**
 * Unique script identifier.
 */
export type Runtime_ScriptId = string;

/**
 * Represents options for serialization. Overrides `generatePreview`, `returnByValue` and
 * `generateWebDriverValue`.
 */
export type Runtime_SerializationOptions = {
  serialization: "deep" | "json" | "idOnly";
  /**
   * Deep serialization depth. Default is full depth. Respected only in `deep` serialization mode.
   */
  maxDepth?: number;
  /**
   * Embedder-specific parameters. For example if connected to V8 in Chrome these control DOM
   * serialization via `maxNodeDepth: integer` and `includeShadowTree: "none" | "open" | "all"`.
   * Values can be only of type string or integer.
   */
  additionalParameters?: object;
};

/**
 * Represents deep serialized value.
 */
export type Runtime_DeepSerializedValue = {
  type:
    | "undefined"
    | "null"
    | "string"
    | "number"
    | "boolean"
    | "bigint"
    | "regexp"
    | "date"
    | "symbol"
    | "array"
    | "object"
    | "function"
    | "map"
    | "set"
    | "weakmap"
    | "weakset"
    | "error"
    | "proxy"
    | "promise"
    | "typedarray"
    | "arraybuffer"
    | "node"
    | "window";
  value?: any;
  objectId?: string;
  /**
   * Set if value reference met more then once during serialization. In such
   * case, value is provided only to one of the serialized values. Unique
   * per value in the scope of one CDP call.
   */
  weakLocalObjectReference?: number;
};

/**
 * Unique object identifier.
 */
export type Runtime_RemoteObjectId = string;

/**
 * Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`,
 * `-Infinity`, and bigint literals.
 */
export type Runtime_UnserializableValue = string;

/**
 * Mirror object referencing original JavaScript object.
 */
export type Runtime_RemoteObject = {
  /**
   * Object type.
   */
  type:
    | "object"
    | "function"
    | "undefined"
    | "string"
    | "number"
    | "boolean"
    | "symbol"
    | "bigint";
  /**
   * Object subtype hint. Specified for `object` type values only.
   * NOTE: If you change anything here, make sure to also update
   * `subtype` in `ObjectPreview` and `PropertyPreview` below.
   */
  subtype?:
    | "array"
    | "null"
    | "node"
    | "regexp"
    | "date"
    | "map"
    | "set"
    | "weakmap"
    | "weakset"
    | "iterator"
    | "generator"
    | "error"
    | "proxy"
    | "promise"
    | "typedarray"
    | "arraybuffer"
    | "dataview"
    | "webassemblymemory"
    | "wasmvalue";
  /**
   * Object class (constructor) name. Specified for `object` type values only.
   */
  className?: string;
  /**
   * Remote object value in case of primitive values or JSON values (if it was requested).
   */
  value?: any;
  /**
   * Primitive value which can not be JSON-stringified does not have `value`, but gets this
   * property.
   */
  unserializableValue?: Runtime_UnserializableValue;
  /**
   * String representation of the object.
   */
  description?: string;
  /**
   * @deprecated
   * Deprecated. Use `deepSerializedValue` instead. WebDriver BiDi representation of the value.
   */
  webDriverValue?: Runtime_DeepSerializedValue;
  /**
   * @experimental
   * Deep serialized value.
   */
  deepSerializedValue?: Runtime_DeepSerializedValue;
  /**
   * Unique object identifier (for non-primitive values).
   */
  objectId?: Runtime_RemoteObjectId;
  /**
   * @experimental
   * Preview containing abbreviated property values. Specified for `object` type values only.
   */
  preview?: Runtime_ObjectPreview;
  /**
   * @experimental
   */
  customPreview?: Runtime_CustomPreview;
};

/**
 * @experimental
 */
export type Runtime_CustomPreview = {
  /**
   * The JSON-stringified result of formatter.header(object, config) call.
   * It contains json ML array that represents RemoteObject.
   */
  header: string;
  /**
   * If formatter returns true as a result of formatter.hasBody call then bodyGetterId will
   * contain RemoteObjectId for the function that returns result of formatter.body(object, config) call.
   * The result value is json ML array.
   */
  bodyGetterId?: Runtime_RemoteObjectId;
};

/**
 * @experimental
 * Object containing abbreviated remote object value.
 */
export type Runtime_ObjectPreview = {
  /**
   * Object type.
   */
  type:
    | "object"
    | "function"
    | "undefined"
    | "string"
    | "number"
    | "boolean"
    | "symbol"
    | "bigint";
  /**
   * Object subtype hint. Specified for `object` type values only.
   */
  subtype?:
    | "array"
    | "null"
    | "node"
    | "regexp"
    | "date"
    | "map"
    | "set"
    | "weakmap"
    | "weakset"
    | "iterator"
    | "generator"
    | "error"
    | "proxy"
    | "promise"
    | "typedarray"
    | "arraybuffer"
    | "dataview"
    | "webassemblymemory"
    | "wasmvalue";
  /**
   * String representation of the object.
   */
  description?: string;
  /**
   * True iff some of the properties or entries of the original object did not fit.
   */
  overflow: boolean;
  /**
   * List of the properties.
   */
  properties: Runtime_PropertyPreview[];
  /**
   * List of the entries. Specified for `map` and `set` subtype values only.
   */
  entries?: Runtime_EntryPreview[];
};

/**
 * @experimental
 */
export type Runtime_PropertyPreview = {
  /**
   * Property name.
   */
  name: string;
  /**
   * Object type. Accessor means that the property itself is an accessor property.
   */
  type:
    | "object"
    | "function"
    | "undefined"
    | "string"
    | "number"
    | "boolean"
    | "symbol"
    | "accessor"
    | "bigint";
  /**
   * User-friendly property value string.
   */
  value?: string;
  /**
   * Nested value preview.
   */
  valuePreview?: Runtime_ObjectPreview;
  /**
   * Object subtype hint. Specified for `object` type values only.
   */
  subtype?:
    | "array"
    | "null"
    | "node"
    | "regexp"
    | "date"
    | "map"
    | "set"
    | "weakmap"
    | "weakset"
    | "iterator"
    | "generator"
    | "error"
    | "proxy"
    | "promise"
    | "typedarray"
    | "arraybuffer"
    | "dataview"
    | "webassemblymemory"
    | "wasmvalue";
};

/**
 * @experimental
 */
export type Runtime_EntryPreview = {
  /**
   * Preview of the key. Specified for map-like collection entries.
   */
  key?: Runtime_ObjectPreview;
  /**
   * Preview of the value.
   */
  value: Runtime_ObjectPreview;
};

/**
 * Object property descriptor.
 */
export type Runtime_PropertyDescriptor = {
  /**
   * Property name or symbol description.
   */
  name: string;
  /**
   * The value associated with the property.
   */
  value?: Runtime_RemoteObject;
  /**
   * True if the value associated with the property may be changed (data descriptors only).
   */
  writable?: boolean;
  /**
   * A function which serves as a getter for the property, or `undefined` if there is no getter
   * (accessor descriptors only).
   */
  get?: Runtime_RemoteObject;
  /**
   * A function which serves as a setter for the property, or `undefined` if there is no setter
   * (accessor descriptors only).
   */
  set?: Runtime_RemoteObject;
  /**
   * True if the type of this property descriptor may be changed and if the property may be
   * deleted from the corresponding object.
   */
  configurable: boolean;
  /**
   * True if this property shows up during enumeration of the properties on the corresponding
   * object.
   */
  enumerable: boolean;
  /**
   * True if the result was thrown during the evaluation.
   */
  wasThrown?: boolean;
  /**
   * True if the property is owned for the object.
   */
  isOwn?: boolean;
  /**
   * Property symbol object, if the property is of the `symbol` type.
   */
  symbol?: Runtime_RemoteObject;
};

/**
 * Object internal property descriptor. This property isn't normally visible in JavaScript code.
 */
export type Runtime_InternalPropertyDescriptor = {
  /**
   * Conventional property name.
   */
  name: string;
  /**
   * The value associated with the property.
   */
  value?: Runtime_RemoteObject;
};

/**
 * @experimental
 * Object private field descriptor.
 */
export type Runtime_PrivatePropertyDescriptor = {
  /**
   * Private property name.
   */
  name: string;
  /**
   * The value associated with the private property.
   */
  value?: Runtime_RemoteObject;
  /**
   * A function which serves as a getter for the private property,
   * or `undefined` if there is no getter (accessor descriptors only).
   */
  get?: Runtime_RemoteObject;
  /**
   * A function which serves as a setter for the private property,
   * or `undefined` if there is no setter (accessor descriptors only).
   */
  set?: Runtime_RemoteObject;
};

/**
 * Represents function call argument. Either remote object id `objectId`, primitive `value`,
 * unserializable primitive value or neither of (for undefined) them should be specified.
 */
export type Runtime_CallArgument = {
  /**
   * Primitive value or serializable javascript object.
   */
  value?: any;
  /**
   * Primitive value which can not be JSON-stringified.
   */
  unserializableValue?: Runtime_UnserializableValue;
  /**
   * Remote object handle.
   */
  objectId?: Runtime_RemoteObjectId;
};

/**
 * Id of an execution context.
 */
export type Runtime_ExecutionContextId = number;

/**
 * Description of an isolated world.
 */
export type Runtime_ExecutionContextDescription = {
  /**
   * Unique id of the execution context. It can be used to specify in which execution context
   * script evaluation should be performed.
   */
  id: Runtime_ExecutionContextId;
  /**
   * Execution context origin.
   */
  origin: string;
  /**
   * Human readable name describing given context.
   */
  name: string;
  /**
   * @experimental
   * A system-unique execution context identifier. Unlike the id, this is unique across
   * multiple processes, so can be reliably used to identify specific context while backend
   * performs a cross-process navigation.
   */
  uniqueId: string;
  /**
   * Embedder-specific auxiliary data likely matching {isDefault: boolean, type: 'default'|'isolated'|'worker', frameId: string}
   */
  auxData?: object;
};

/**
 * Detailed information about exception (or error) that was thrown during script compilation or
 * execution.
 */
export type Runtime_ExceptionDetails = {
  /**
   * Exception id.
   */
  exceptionId: number;
  /**
   * Exception text, which should be used together with exception object when available.
   */
  text: string;
  /**
   * Line number of the exception location (0-based).
   */
  lineNumber: number;
  /**
   * Column number of the exception location (0-based).
   */
  columnNumber: number;
  /**
   * Script ID of the exception location.
   */
  scriptId?: Runtime_ScriptId;
  /**
   * URL of the exception location, to be used when the script was not reported.
   */
  url?: string;
  /**
   * JavaScript stack trace if available.
   */
  stackTrace?: Runtime_StackTrace;
  /**
   * Exception object if available.
   */
  exception?: Runtime_RemoteObject;
  /**
   * Identifier of the context where exception happened.
   */
  executionContextId?: Runtime_ExecutionContextId;
  /**
   * @experimental
   * Dictionary with entries of meta data that the client associated
   * with this exception, such as information about associated network
   * requests, etc.
   */
  exceptionMetaData?: object;
};

/**
 * Number of milliseconds since epoch.
 */
export type Runtime_Timestamp = number;

/**
 * Number of milliseconds.
 */
export type Runtime_TimeDelta = number;

/**
 * Stack entry for runtime errors and assertions.
 */
export type Runtime_CallFrame = {
  /**
   * JavaScript function name.
   */
  functionName: string;
  /**
   * JavaScript script id.
   */
  scriptId: Runtime_ScriptId;
  /**
   * JavaScript script name or url.
   */
  url: string;
  /**
   * JavaScript script line number (0-based).
   */
  lineNumber: number;
  /**
   * JavaScript script column number (0-based).
   */
  columnNumber: number;
};

/**
 * Call frames for assertions or error messages.
 */
export type Runtime_StackTrace = {
  /**
   * String label of this stack trace. For async traces this may be a name of the function that
   * initiated the async call.
   */
  description?: string;
  /**
   * JavaScript function name.
   */
  callFrames: Runtime_CallFrame[];
  /**
   * Asynchronous JavaScript stack trace that preceded this stack, if available.
   */
  parent?: Runtime_StackTrace;
  /**
   * @experimental
   * Asynchronous JavaScript stack trace that preceded this stack, if available.
   */
  parentId?: Runtime_StackTraceId;
};

/**
 * @experimental
 * Unique identifier of current debugger.
 */
export type Runtime_UniqueDebuggerId = string;

/**
 * @experimental
 * If `debuggerId` is set stack trace comes from another debugger and can be resolved there. This
 * allows to track cross-debugger calls. See `Runtime.StackTrace` and `Debugger.paused` for usages.
 */
export type Runtime_StackTraceId = {
  id: string;
  debuggerId?: Runtime_UniqueDebuggerId;
};

// ----------------- Schema -----------------

/**
 * Description of the protocol domain.
 */
export type Schema_Domain = {
  /**
   * Domain name.
   */
  name: string;
  /**
   * Domain version.
   */
  version: string;
};

export class Celestial {
  #ws: WebSocket;
  #id = 0;
  #handlers: Map<number, (value: unknown) => void> = new Map();

  /**
   * Celestial expects a open websocket to communicate over
   */
  constructor(ws: WebSocket) {
    this.#ws = ws;

    this.#ws.onmessage = (e) => {
      const data = JSON.parse(e.data);

      const handler = this.#handlers.get(data.id);

      if (handler) {
        handler(data.result);
      }
    };
  }

  #sendReq(method: string, params?: unknown) {
    this.#ws.send(JSON.stringify({
      id: ++this.#id,
      method,
      params,
    }));

    return new Promise((res) => {
      this.#handlers.set(this.#id, res);
    });
  }
  /**
   * @experimental
   */
  Accessibility = {
    /**
     * Disables the accessibility domain.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Accessibility.disable");
    },

    /**
     * Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.
     * This turns on accessibility for the page, which can impact performance until accessibility is disabled.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("Accessibility.enable");
    },

    /**
     * @experimental
     * Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.
     */

    getPartialAXTree: async (
      opts: {
        nodeId: DOM_NodeId;
        backendNodeId: DOM_BackendNodeId;
        objectId: Runtime_RemoteObjectId;
        fetchRelatives: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Accessibility.getPartialAXTree", opts);
    },

    /**
     * @experimental
     * Fetches the entire accessibility tree for the root Document
     */

    getFullAXTree: async (
      opts: { depth: number; frameId: Page_FrameId },
    ): Promise<any> => {
      return await this.#sendReq("Accessibility.getFullAXTree", opts);
    },

    /**
     * @experimental
     * Fetches the root node.
     * Requires `enable()` to have been called previously.
     */

    getRootAXNode: async (opts: { frameId: Page_FrameId }): Promise<any> => {
      return await this.#sendReq("Accessibility.getRootAXNode", opts);
    },

    /**
     * @experimental
     * Fetches a node and all ancestors up to and including the root.
     * Requires `enable()` to have been called previously.
     */

    getAXNodeAndAncestors: async (
      opts: {
        nodeId: DOM_NodeId;
        backendNodeId: DOM_BackendNodeId;
        objectId: Runtime_RemoteObjectId;
      },
    ): Promise<any> => {
      return await this.#sendReq("Accessibility.getAXNodeAndAncestors", opts);
    },

    /**
     * @experimental
     * Fetches a particular accessibility node by AXNodeId.
     * Requires `enable()` to have been called previously.
     */

    getChildAXNodes: async (
      opts: { id: Accessibility_AXNodeId; frameId: Page_FrameId },
    ): Promise<any> => {
      return await this.#sendReq("Accessibility.getChildAXNodes", opts);
    },

    /**
     * @experimental
     * Query a DOM node's accessibility subtree for accessible name and role.
     * This command computes the name and role for all nodes in the subtree, including those that are
     * ignored for accessibility, and returns those that mactch the specified name and role. If no DOM
     * node is specified, or the DOM node does not exist, the command returns an error. If neither
     * `accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree.
     */

    queryAXTree: async (
      opts: {
        nodeId: DOM_NodeId;
        backendNodeId: DOM_BackendNodeId;
        objectId: Runtime_RemoteObjectId;
        accessibleName: string;
        role: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("Accessibility.queryAXTree", opts);
    },
  };

  /**
   * @experimental
   */
  Animation = {
    /**
     * Disables animation domain notifications.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Animation.disable");
    },

    /**
     * Enables animation domain notifications.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("Animation.enable");
    },

    /**
     * Returns the current time of the an animation.
     */

    getCurrentTime: async (opts: { id: string }): Promise<any> => {
      return await this.#sendReq("Animation.getCurrentTime", opts);
    },

    /**
     * Gets the playback rate of the document timeline.
     */

    getPlaybackRate: async (): Promise<any> => {
      return await this.#sendReq("Animation.getPlaybackRate");
    },

    /**
     * Releases a set of animations to no longer be manipulated.
     */

    releaseAnimations: async (opts: { animations: string[] }): Promise<any> => {
      return await this.#sendReq("Animation.releaseAnimations", opts);
    },

    /**
     * Gets the remote object of the Animation.
     */

    resolveAnimation: async (opts: { animationId: string }): Promise<any> => {
      return await this.#sendReq("Animation.resolveAnimation", opts);
    },

    /**
     * Seek a set of animations to a particular time within each animation.
     */

    seekAnimations: async (
      opts: { animations: string[]; currentTime: number },
    ): Promise<any> => {
      return await this.#sendReq("Animation.seekAnimations", opts);
    },

    /**
     * Sets the paused state of a set of animations.
     */

    setPaused: async (
      opts: { animations: string[]; paused: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Animation.setPaused", opts);
    },

    /**
     * Sets the playback rate of the document timeline.
     */

    setPlaybackRate: async (opts: { playbackRate: number }): Promise<any> => {
      return await this.#sendReq("Animation.setPlaybackRate", opts);
    },

    /**
     * Sets the timing of an animation node.
     */

    setTiming: async (
      opts: { animationId: string; duration: number; delay: number },
    ): Promise<any> => {
      return await this.#sendReq("Animation.setTiming", opts);
    },
  };

  /**
   * @experimental
   * Audits domain allows investigation of page violations and possible improvements.
   */
  Audits = {
    /**
     * Returns the response body and size if it were re-encoded with the specified settings. Only
     * applies to images.
     */

    getEncodedResponse: async (
      opts: {
        requestId: Network_RequestId;
        encoding: "webp" | "jpeg" | "png";
        quality: number;
        sizeOnly: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Audits.getEncodedResponse", opts);
    },

    /**
     * Disables issues domain, prevents further issues from being reported to the client.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Audits.disable");
    },

    /**
     * Enables issues domain, sends the issues collected so far to the client by means of the
     * `issueAdded` event.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("Audits.enable");
    },

    /**
     * Runs the contrast check for the target page. Found issues are reported
     * using Audits.issueAdded event.
     */

    checkContrast: async (opts: { reportAAA: boolean }): Promise<any> => {
      return await this.#sendReq("Audits.checkContrast", opts);
    },

    /**
     * Runs the form issues check for the target page. Found issues are reported
     * using Audits.issueAdded event.
     */

    checkFormsIssues: async (): Promise<any> => {
      return await this.#sendReq("Audits.checkFormsIssues");
    },
  };

  /**
   * @experimental
   * Defines commands and events for Autofill.
   */
  Autofill = {
    /**
     * Trigger autofill on a form identified by the fieldId.
     * If the field and related form cannot be autofilled, returns an error.
     */

    trigger: async (
      opts: {
        fieldId: DOM_BackendNodeId;
        frameId: Page_FrameId;
        card: Autofill_CreditCard;
      },
    ): Promise<any> => {
      return await this.#sendReq("Autofill.trigger", opts);
    },

    /**
     * Set addresses so that developers can verify their forms implementation.
     */

    setAddresses: async (
      opts: { addresses: Autofill_Address[] },
    ): Promise<any> => {
      return await this.#sendReq("Autofill.setAddresses", opts);
    },
  };

  /**
   * @experimental
   * Defines events for background web platform features.
   */
  BackgroundService = {
    /**
     * Enables event updates for the service.
     */

    startObserving: async (
      opts: { service: BackgroundService_ServiceName },
    ): Promise<any> => {
      return await this.#sendReq("BackgroundService.startObserving", opts);
    },

    /**
     * Disables event updates for the service.
     */

    stopObserving: async (
      opts: { service: BackgroundService_ServiceName },
    ): Promise<any> => {
      return await this.#sendReq("BackgroundService.stopObserving", opts);
    },

    /**
     * Set the recording state for the service.
     */

    setRecording: async (
      opts: { shouldRecord: boolean; service: BackgroundService_ServiceName },
    ): Promise<any> => {
      return await this.#sendReq("BackgroundService.setRecording", opts);
    },

    /**
     * Clears all stored data for the service.
     */

    clearEvents: async (
      opts: { service: BackgroundService_ServiceName },
    ): Promise<any> => {
      return await this.#sendReq("BackgroundService.clearEvents", opts);
    },
  };

  /**
   * The Browser domain defines methods and events for browser managing.
   */
  Browser = {
    /**
     * @experimental
     * Set permission settings for given origin.
     */

    setPermission: async (
      opts: {
        permission: Browser_PermissionDescriptor;
        setting: Browser_PermissionSetting;
        origin: string;
        browserContextId: Browser_BrowserContextID;
      },
    ): Promise<any> => {
      return await this.#sendReq("Browser.setPermission", opts);
    },

    /**
     * @experimental
     * Grant specific permissions to the given origin and reject all others.
     */

    grantPermissions: async (
      opts: {
        permissions: Browser_PermissionType[];
        origin: string;
        browserContextId: Browser_BrowserContextID;
      },
    ): Promise<any> => {
      return await this.#sendReq("Browser.grantPermissions", opts);
    },

    /**
     * @experimental
     * Reset all permission management for all origins.
     */

    resetPermissions: async (
      opts: { browserContextId: Browser_BrowserContextID },
    ): Promise<any> => {
      return await this.#sendReq("Browser.resetPermissions", opts);
    },

    /**
     * @experimental
     * Set the behavior when downloading a file.
     */

    setDownloadBehavior: async (
      opts: {
        behavior: "deny" | "allow" | "allowAndName" | "default";
        browserContextId: Browser_BrowserContextID;
        downloadPath: string;
        eventsEnabled: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Browser.setDownloadBehavior", opts);
    },

    /**
     * @experimental
     * Cancel a download if in progress
     */

    cancelDownload: async (
      opts: { guid: string; browserContextId: Browser_BrowserContextID },
    ): Promise<any> => {
      return await this.#sendReq("Browser.cancelDownload", opts);
    },

    /**
     * Close browser gracefully.
     */

    close: async (): Promise<any> => {
      return await this.#sendReq("Browser.close");
    },

    /**
     * @experimental
     * Crashes browser on the main thread.
     */

    crash: async (): Promise<any> => {
      return await this.#sendReq("Browser.crash");
    },

    /**
     * @experimental
     * Crashes GPU process.
     */

    crashGpuProcess: async (): Promise<any> => {
      return await this.#sendReq("Browser.crashGpuProcess");
    },

    /**
     * Returns version information.
     */

    getVersion: async (): Promise<any> => {
      return await this.#sendReq("Browser.getVersion");
    },

    /**
     * @experimental
     * Returns the command line switches for the browser process if, and only if
     * --enable-automation is on the commandline.
     */

    getBrowserCommandLine: async (): Promise<any> => {
      return await this.#sendReq("Browser.getBrowserCommandLine");
    },

    /**
     * @experimental
     * Get Chrome histograms.
     */

    getHistograms: async (
      opts: { query: string; delta: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Browser.getHistograms", opts);
    },

    /**
     * @experimental
     * Get a Chrome histogram by name.
     */

    getHistogram: async (
      opts: { name: string; delta: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Browser.getHistogram", opts);
    },

    /**
     * @experimental
     * Get position and size of the browser window.
     */

    getWindowBounds: async (
      opts: { windowId: Browser_WindowID },
    ): Promise<any> => {
      return await this.#sendReq("Browser.getWindowBounds", opts);
    },

    /**
     * @experimental
     * Get the browser window that contains the devtools target.
     */

    getWindowForTarget: async (
      opts: { targetId: Target_TargetID },
    ): Promise<any> => {
      return await this.#sendReq("Browser.getWindowForTarget", opts);
    },

    /**
     * @experimental
     * Set position and/or size of the browser window.
     */

    setWindowBounds: async (
      opts: { windowId: Browser_WindowID; bounds: Browser_Bounds },
    ): Promise<any> => {
      return await this.#sendReq("Browser.setWindowBounds", opts);
    },

    /**
     * @experimental
     * Set dock tile details, platform-specific.
     */

    setDockTile: async (
      opts: { badgeLabel: string; image: string },
    ): Promise<any> => {
      return await this.#sendReq("Browser.setDockTile", opts);
    },

    /**
     * @experimental
     * Invoke custom browser commands used by telemetry.
     */

    executeBrowserCommand: async (
      opts: { commandId: Browser_BrowserCommandId },
    ): Promise<any> => {
      return await this.#sendReq("Browser.executeBrowserCommand", opts);
    },

    /**
     * Allows a site to use privacy sandbox features that require enrollment
     * without the site actually being enrolled. Only supported on page targets.
     */

    addPrivacySandboxEnrollmentOverride: async (
      opts: { url: string },
    ): Promise<any> => {
      return await this.#sendReq(
        "Browser.addPrivacySandboxEnrollmentOverride",
        opts,
      );
    },
  };

  /**
   * @experimental
   * This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles)
   * have an associated `id` used in subsequent operations on the related object. Each object type has
   * a specific `id` structure, and those are not interchangeable between objects of different kinds.
   * CSS objects can be loaded using the `get*ForNode()` calls (which accept a DOM node id). A client
   * can also keep track of stylesheets via the `styleSheetAdded`/`styleSheetRemoved` events and
   * subsequently load the required stylesheet contents using the `getStyleSheet[Text]()` methods.
   */
  CSS = {
    /**
     * Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
     * position specified by `location`.
     */

    addRule: async (
      opts: {
        styleSheetId: CSS_StyleSheetId;
        ruleText: string;
        location: CSS_SourceRange;
      },
    ): Promise<any> => {
      return await this.#sendReq("CSS.addRule", opts);
    },

    /**
     * Returns all class names from specified stylesheet.
     */

    collectClassNames: async (
      opts: { styleSheetId: CSS_StyleSheetId },
    ): Promise<any> => {
      return await this.#sendReq("CSS.collectClassNames", opts);
    },

    /**
     * Creates a new special "via-inspector" stylesheet in the frame with given `frameId`.
     */

    createStyleSheet: async (opts: { frameId: Page_FrameId }): Promise<any> => {
      return await this.#sendReq("CSS.createStyleSheet", opts);
    },

    /**
     * Disables the CSS agent for the given page.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("CSS.disable");
    },

    /**
     * Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
     * enabled until the result of this command is received.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("CSS.enable");
    },

    /**
     * Ensures that the given node will have specified pseudo-classes whenever its style is computed by
     * the browser.
     */

    forcePseudoState: async (
      opts: { nodeId: DOM_NodeId; forcedPseudoClasses: string[] },
    ): Promise<any> => {
      return await this.#sendReq("CSS.forcePseudoState", opts);
    },

    getBackgroundColors: async (opts: { nodeId: DOM_NodeId }): Promise<any> => {
      return await this.#sendReq("CSS.getBackgroundColors", opts);
    },

    /**
     * Returns the computed style for a DOM node identified by `nodeId`.
     */

    getComputedStyleForNode: async (
      opts: { nodeId: DOM_NodeId },
    ): Promise<any> => {
      return await this.#sendReq("CSS.getComputedStyleForNode", opts);
    },

    /**
     * Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
     * attributes) for a DOM node identified by `nodeId`.
     */

    getInlineStylesForNode: async (
      opts: { nodeId: DOM_NodeId },
    ): Promise<any> => {
      return await this.#sendReq("CSS.getInlineStylesForNode", opts);
    },

    /**
     * Returns requested styles for a DOM node identified by `nodeId`.
     */

    getMatchedStylesForNode: async (
      opts: { nodeId: DOM_NodeId },
    ): Promise<any> => {
      return await this.#sendReq("CSS.getMatchedStylesForNode", opts);
    },

    /**
     * Returns all media queries parsed by the rendering engine.
     */

    getMediaQueries: async (): Promise<any> => {
      return await this.#sendReq("CSS.getMediaQueries");
    },

    /**
     * Requests information about platform fonts which we used to render child TextNodes in the given
     * node.
     */

    getPlatformFontsForNode: async (
      opts: { nodeId: DOM_NodeId },
    ): Promise<any> => {
      return await this.#sendReq("CSS.getPlatformFontsForNode", opts);
    },

    /**
     * Returns the current textual content for a stylesheet.
     */

    getStyleSheetText: async (
      opts: { styleSheetId: CSS_StyleSheetId },
    ): Promise<any> => {
      return await this.#sendReq("CSS.getStyleSheetText", opts);
    },

    /**
     * @experimental
     * Returns all layers parsed by the rendering engine for the tree scope of a node.
     * Given a DOM element identified by nodeId, getLayersForNode returns the root
     * layer for the nearest ancestor document or shadow root. The layer root contains
     * the full layer tree for the tree scope and their ordering.
     */

    getLayersForNode: async (opts: { nodeId: DOM_NodeId }): Promise<any> => {
      return await this.#sendReq("CSS.getLayersForNode", opts);
    },

    /**
     * @experimental
     * Starts tracking the given computed styles for updates. The specified array of properties
     * replaces the one previously specified. Pass empty array to disable tracking.
     * Use takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.
     * The changes to computed style properties are only tracked for nodes pushed to the front-end
     * by the DOM agent. If no changes to the tracked properties occur after the node has been pushed
     * to the front-end, no updates will be issued for the node.
     */

    trackComputedStyleUpdates: async (
      opts: { propertiesToTrack: CSS_CSSComputedStyleProperty[] },
    ): Promise<any> => {
      return await this.#sendReq("CSS.trackComputedStyleUpdates", opts);
    },

    /**
     * @experimental
     * Polls the next batch of computed style updates.
     */

    takeComputedStyleUpdates: async (): Promise<any> => {
      return await this.#sendReq("CSS.takeComputedStyleUpdates");
    },

    /**
     * Find a rule with the given active property for the given node and set the new value for this
     * property
     */

    setEffectivePropertyValueForNode: async (
      opts: { nodeId: DOM_NodeId; propertyName: string; value: string },
    ): Promise<any> => {
      return await this.#sendReq("CSS.setEffectivePropertyValueForNode", opts);
    },

    /**
     * Modifies the keyframe rule key text.
     */

    setKeyframeKey: async (
      opts: {
        styleSheetId: CSS_StyleSheetId;
        range: CSS_SourceRange;
        keyText: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("CSS.setKeyframeKey", opts);
    },

    /**
     * Modifies the rule selector.
     */

    setMediaText: async (
      opts: {
        styleSheetId: CSS_StyleSheetId;
        range: CSS_SourceRange;
        text: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("CSS.setMediaText", opts);
    },

    /**
     * @experimental
     * Modifies the expression of a container query.
     */

    setContainerQueryText: async (
      opts: {
        styleSheetId: CSS_StyleSheetId;
        range: CSS_SourceRange;
        text: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("CSS.setContainerQueryText", opts);
    },

    /**
     * @experimental
     * Modifies the expression of a supports at-rule.
     */

    setSupportsText: async (
      opts: {
        styleSheetId: CSS_StyleSheetId;
        range: CSS_SourceRange;
        text: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("CSS.setSupportsText", opts);
    },

    /**
     * @experimental
     * Modifies the expression of a scope at-rule.
     */

    setScopeText: async (
      opts: {
        styleSheetId: CSS_StyleSheetId;
        range: CSS_SourceRange;
        text: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("CSS.setScopeText", opts);
    },

    /**
     * Modifies the rule selector.
     */

    setRuleSelector: async (
      opts: {
        styleSheetId: CSS_StyleSheetId;
        range: CSS_SourceRange;
        selector: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("CSS.setRuleSelector", opts);
    },

    /**
     * Sets the new stylesheet text.
     */

    setStyleSheetText: async (
      opts: { styleSheetId: CSS_StyleSheetId; text: string },
    ): Promise<any> => {
      return await this.#sendReq("CSS.setStyleSheetText", opts);
    },

    /**
     * Applies specified style edits one after another in the given order.
     */

    setStyleTexts: async (
      opts: { edits: CSS_StyleDeclarationEdit[] },
    ): Promise<any> => {
      return await this.#sendReq("CSS.setStyleTexts", opts);
    },

    /**
     * Enables the selector recording.
     */

    startRuleUsageTracking: async (): Promise<any> => {
      return await this.#sendReq("CSS.startRuleUsageTracking");
    },

    /**
     * Stop tracking rule usage and return the list of rules that were used since last call to
     * `takeCoverageDelta` (or since start of coverage instrumentation).
     */

    stopRuleUsageTracking: async (): Promise<any> => {
      return await this.#sendReq("CSS.stopRuleUsageTracking");
    },

    /**
     * Obtain list of rules that became used since last call to this method (or since start of coverage
     * instrumentation).
     */

    takeCoverageDelta: async (): Promise<any> => {
      return await this.#sendReq("CSS.takeCoverageDelta");
    },

    /**
     * @experimental
     * Enables/disables rendering of local CSS fonts (enabled by default).
     */

    setLocalFontsEnabled: async (opts: { enabled: boolean }): Promise<any> => {
      return await this.#sendReq("CSS.setLocalFontsEnabled", opts);
    },
  };

  /**
   * @experimental
   */
  CacheStorage = {
    /**
     * Deletes a cache.
     */

    deleteCache: async (
      opts: { cacheId: CacheStorage_CacheId },
    ): Promise<any> => {
      return await this.#sendReq("CacheStorage.deleteCache", opts);
    },

    /**
     * Deletes a cache entry.
     */

    deleteEntry: async (
      opts: { cacheId: CacheStorage_CacheId; request: string },
    ): Promise<any> => {
      return await this.#sendReq("CacheStorage.deleteEntry", opts);
    },

    /**
     * Requests cache names.
     */

    requestCacheNames: async (
      opts: {
        securityOrigin: string;
        storageKey: string;
        storageBucket: Storage_StorageBucket;
      },
    ): Promise<any> => {
      return await this.#sendReq("CacheStorage.requestCacheNames", opts);
    },

    /**
     * Fetches cache entry.
     */

    requestCachedResponse: async (
      opts: {
        cacheId: CacheStorage_CacheId;
        requestURL: string;
        requestHeaders: CacheStorage_Header[];
      },
    ): Promise<any> => {
      return await this.#sendReq("CacheStorage.requestCachedResponse", opts);
    },

    /**
     * Requests data from cache.
     */

    requestEntries: async (
      opts: {
        cacheId: CacheStorage_CacheId;
        skipCount: number;
        pageSize: number;
        pathFilter: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("CacheStorage.requestEntries", opts);
    },
  };

  /**
   * @experimental
   * A domain for interacting with Cast, Presentation API, and Remote Playback API
   * functionalities.
   */
  Cast = {
    /**
     * Starts observing for sinks that can be used for tab mirroring, and if set,
     * sinks compatible with |presentationUrl| as well. When sinks are found, a
     * |sinksUpdated| event is fired.
     * Also starts observing for issue messages. When an issue is added or removed,
     * an |issueUpdated| event is fired.
     */

    enable: async (opts: { presentationUrl: string }): Promise<any> => {
      return await this.#sendReq("Cast.enable", opts);
    },

    /**
     * Stops observing for sinks and issues.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Cast.disable");
    },

    /**
     * Sets a sink to be used when the web page requests the browser to choose a
     * sink via Presentation API, Remote Playback API, or Cast SDK.
     */

    setSinkToUse: async (opts: { sinkName: string }): Promise<any> => {
      return await this.#sendReq("Cast.setSinkToUse", opts);
    },

    /**
     * Starts mirroring the desktop to the sink.
     */

    startDesktopMirroring: async (opts: { sinkName: string }): Promise<any> => {
      return await this.#sendReq("Cast.startDesktopMirroring", opts);
    },

    /**
     * Starts mirroring the tab to the sink.
     */

    startTabMirroring: async (opts: { sinkName: string }): Promise<any> => {
      return await this.#sendReq("Cast.startTabMirroring", opts);
    },

    /**
     * Stops the active Cast session on the sink.
     */

    stopCasting: async (opts: { sinkName: string }): Promise<any> => {
      return await this.#sendReq("Cast.stopCasting", opts);
    },
  };

  /**
   * This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object
   * that has an `id`. This `id` can be used to get additional information on the Node, resolve it into
   * the JavaScript object wrapper, etc. It is important that client receives DOM events only for the
   * nodes that are known to the client. Backend keeps track of the nodes that were sent to the client
   * and never sends the same node twice. It is client's responsibility to collect information about
   * the nodes that were sent to the client. Note that `iframe` owner elements will return
   * corresponding document elements as their child nodes.
   */
  DOM = {
    /**
     * @experimental
     * Collects class names for the node with given id and all of it's child nodes.
     */

    collectClassNamesFromSubtree: async (
      opts: { nodeId: DOM_NodeId },
    ): Promise<any> => {
      return await this.#sendReq("DOM.collectClassNamesFromSubtree", opts);
    },

    /**
     * @experimental
     * Creates a deep copy of the specified node and places it into the target container before the
     * given anchor.
     */

    copyTo: async (
      opts: {
        nodeId: DOM_NodeId;
        targetNodeId: DOM_NodeId;
        insertBeforeNodeId: DOM_NodeId;
      },
    ): Promise<any> => {
      return await this.#sendReq("DOM.copyTo", opts);
    },

    /**
     * Describes node given its id, does not require domain to be enabled. Does not start tracking any
     * objects, can be used for automation.
     */

    describeNode: async (
      opts: {
        nodeId: DOM_NodeId;
        backendNodeId: DOM_BackendNodeId;
        objectId: Runtime_RemoteObjectId;
        depth: number;
        pierce: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("DOM.describeNode", opts);
    },

    /**
     * @experimental
     * Scrolls the specified rect of the given node into view if not already visible.
     * Note: exactly one between nodeId, backendNodeId and objectId should be passed
     * to identify the node.
     */

    scrollIntoViewIfNeeded: async (
      opts: {
        nodeId: DOM_NodeId;
        backendNodeId: DOM_BackendNodeId;
        objectId: Runtime_RemoteObjectId;
        rect: DOM_Rect;
      },
    ): Promise<any> => {
      return await this.#sendReq("DOM.scrollIntoViewIfNeeded", opts);
    },

    /**
     * Disables DOM agent for the given page.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("DOM.disable");
    },

    /**
     * @experimental
     * Discards search results from the session with the given id. `getSearchResults` should no longer
     * be called for that search.
     */

    discardSearchResults: async (opts: { searchId: string }): Promise<any> => {
      return await this.#sendReq("DOM.discardSearchResults", opts);
    },

    /**
     * Enables DOM agent for the given page.
     */

    enable: async (
      opts: { includeWhitespace: "none" | "all" },
    ): Promise<any> => {
      return await this.#sendReq("DOM.enable", opts);
    },

    /**
     * Focuses the given element.
     */

    focus: async (
      opts: {
        nodeId: DOM_NodeId;
        backendNodeId: DOM_BackendNodeId;
        objectId: Runtime_RemoteObjectId;
      },
    ): Promise<any> => {
      return await this.#sendReq("DOM.focus", opts);
    },

    /**
     * Returns attributes for the specified node.
     */

    getAttributes: async (opts: { nodeId: DOM_NodeId }): Promise<any> => {
      return await this.#sendReq("DOM.getAttributes", opts);
    },

    /**
     * Returns boxes for the given node.
     */

    getBoxModel: async (
      opts: {
        nodeId: DOM_NodeId;
        backendNodeId: DOM_BackendNodeId;
        objectId: Runtime_RemoteObjectId;
      },
    ): Promise<any> => {
      return await this.#sendReq("DOM.getBoxModel", opts);
    },

    /**
     * @experimental
     * Returns quads that describe node position on the page. This method
     * might return multiple quads for inline nodes.
     */

    getContentQuads: async (
      opts: {
        nodeId: DOM_NodeId;
        backendNodeId: DOM_BackendNodeId;
        objectId: Runtime_RemoteObjectId;
      },
    ): Promise<any> => {
      return await this.#sendReq("DOM.getContentQuads", opts);
    },

    /**
     * Returns the root DOM node (and optionally the subtree) to the caller.
     * Implicitly enables the DOM domain events for the current target.
     */

    getDocument: async (
      opts: { depth: number; pierce: boolean },
    ): Promise<any> => {
      return await this.#sendReq("DOM.getDocument", opts);
    },

    /**
     * @deprecated
     * Returns the root DOM node (and optionally the subtree) to the caller.
     * Deprecated, as it is not designed to work well with the rest of the DOM agent.
     * Use DOMSnapshot.captureSnapshot instead.
     */

    getFlattenedDocument: async (
      opts: { depth: number; pierce: boolean },
    ): Promise<any> => {
      return await this.#sendReq("DOM.getFlattenedDocument", opts);
    },

    /**
     * @experimental
     * Finds nodes with a given computed style in a subtree.
     */

    getNodesForSubtreeByStyle: async (
      opts: {
        nodeId: DOM_NodeId;
        computedStyles: DOM_CSSComputedStyleProperty[];
        pierce: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("DOM.getNodesForSubtreeByStyle", opts);
    },

    /**
     * Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
     * either returned or not.
     */

    getNodeForLocation: async (
      opts: {
        x: number;
        y: number;
        includeUserAgentShadowDOM: boolean;
        ignorePointerEventsNone: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("DOM.getNodeForLocation", opts);
    },

    /**
     * Returns node's HTML markup.
     */

    getOuterHTML: async (
      opts: {
        nodeId: DOM_NodeId;
        backendNodeId: DOM_BackendNodeId;
        objectId: Runtime_RemoteObjectId;
      },
    ): Promise<any> => {
      return await this.#sendReq("DOM.getOuterHTML", opts);
    },

    /**
     * @experimental
     * Returns the id of the nearest ancestor that is a relayout boundary.
     */

    getRelayoutBoundary: async (opts: { nodeId: DOM_NodeId }): Promise<any> => {
      return await this.#sendReq("DOM.getRelayoutBoundary", opts);
    },

    /**
     * @experimental
     * Returns search results from given `fromIndex` to given `toIndex` from the search with the given
     * identifier.
     */

    getSearchResults: async (
      opts: { searchId: string; fromIndex: number; toIndex: number },
    ): Promise<any> => {
      return await this.#sendReq("DOM.getSearchResults", opts);
    },

    /**
     * Hides any highlight.
     */

    hideHighlight: async (): Promise<any> => {
      return await this.#sendReq("DOM.hideHighlight");
    },

    /**
     * Highlights DOM node.
     */

    highlightNode: async (): Promise<any> => {
      return await this.#sendReq("DOM.highlightNode");
    },

    /**
     * Highlights given rectangle.
     */

    highlightRect: async (): Promise<any> => {
      return await this.#sendReq("DOM.highlightRect");
    },

    /**
     * @experimental
     * Marks last undoable state.
     */

    markUndoableState: async (): Promise<any> => {
      return await this.#sendReq("DOM.markUndoableState");
    },

    /**
     * Moves node into the new container, places it before the given anchor.
     */

    moveTo: async (
      opts: {
        nodeId: DOM_NodeId;
        targetNodeId: DOM_NodeId;
        insertBeforeNodeId: DOM_NodeId;
      },
    ): Promise<any> => {
      return await this.#sendReq("DOM.moveTo", opts);
    },

    /**
     * @experimental
     * Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
     * `cancelSearch` to end this search session.
     */

    performSearch: async (
      opts: { query: string; includeUserAgentShadowDOM: boolean },
    ): Promise<any> => {
      return await this.#sendReq("DOM.performSearch", opts);
    },

    /**
     * @experimental
     * Requests that the node is sent to the caller given its path. // FIXME, use XPath
     */

    pushNodeByPathToFrontend: async (opts: { path: string }): Promise<any> => {
      return await this.#sendReq("DOM.pushNodeByPathToFrontend", opts);
    },

    /**
     * @experimental
     * Requests that a batch of nodes is sent to the caller given their backend node ids.
     */

    pushNodesByBackendIdsToFrontend: async (
      opts: { backendNodeIds: DOM_BackendNodeId[] },
    ): Promise<any> => {
      return await this.#sendReq("DOM.pushNodesByBackendIdsToFrontend", opts);
    },

    /**
     * Executes `querySelector` on a given node.
     */

    querySelector: async (
      opts: { nodeId: DOM_NodeId; selector: string },
    ): Promise<any> => {
      return await this.#sendReq("DOM.querySelector", opts);
    },

    /**
     * Executes `querySelectorAll` on a given node.
     */

    querySelectorAll: async (
      opts: { nodeId: DOM_NodeId; selector: string },
    ): Promise<any> => {
      return await this.#sendReq("DOM.querySelectorAll", opts);
    },

    /**
     * @experimental
     * Returns NodeIds of current top layer elements.
     * Top layer is rendered closest to the user within a viewport, therefore its elements always
     * appear on top of all other content.
     */

    getTopLayerElements: async (): Promise<any> => {
      return await this.#sendReq("DOM.getTopLayerElements");
    },

    /**
     * @experimental
     * Re-does the last undone action.
     */

    redo: async (): Promise<any> => {
      return await this.#sendReq("DOM.redo");
    },

    /**
     * Removes attribute with given name from an element with given id.
     */

    removeAttribute: async (
      opts: { nodeId: DOM_NodeId; name: string },
    ): Promise<any> => {
      return await this.#sendReq("DOM.removeAttribute", opts);
    },

    /**
     * Removes node with given id.
     */

    removeNode: async (opts: { nodeId: DOM_NodeId }): Promise<any> => {
      return await this.#sendReq("DOM.removeNode", opts);
    },

    /**
     * Requests that children of the node with given id are returned to the caller in form of
     * `setChildNodes` events where not only immediate children are retrieved, but all children down to
     * the specified depth.
     */

    requestChildNodes: async (
      opts: { nodeId: DOM_NodeId; depth: number; pierce: boolean },
    ): Promise<any> => {
      return await this.#sendReq("DOM.requestChildNodes", opts);
    },

    /**
     * Requests that the node is sent to the caller given the JavaScript node object reference. All
     * nodes that form the path from the node to the root are also sent to the client as a series of
     * `setChildNodes` notifications.
     */

    requestNode: async (
      opts: { objectId: Runtime_RemoteObjectId },
    ): Promise<any> => {
      return await this.#sendReq("DOM.requestNode", opts);
    },

    /**
     * Resolves the JavaScript node object for a given NodeId or BackendNodeId.
     */

    resolveNode: async (
      opts: {
        nodeId: DOM_NodeId;
        backendNodeId: DOM_BackendNodeId;
        objectGroup: string;
        executionContextId: Runtime_ExecutionContextId;
      },
    ): Promise<any> => {
      return await this.#sendReq("DOM.resolveNode", opts);
    },

    /**
     * Sets attribute for an element with given id.
     */

    setAttributeValue: async (
      opts: { nodeId: DOM_NodeId; name: string; value: string },
    ): Promise<any> => {
      return await this.#sendReq("DOM.setAttributeValue", opts);
    },

    /**
     * Sets attributes on element with given id. This method is useful when user edits some existing
     * attribute value and types in several attribute name/value pairs.
     */

    setAttributesAsText: async (
      opts: { nodeId: DOM_NodeId; text: string; name: string },
    ): Promise<any> => {
      return await this.#sendReq("DOM.setAttributesAsText", opts);
    },

    /**
     * Sets files for the given file input element.
     */

    setFileInputFiles: async (
      opts: {
        files: string[];
        nodeId: DOM_NodeId;
        backendNodeId: DOM_BackendNodeId;
        objectId: Runtime_RemoteObjectId;
      },
    ): Promise<any> => {
      return await this.#sendReq("DOM.setFileInputFiles", opts);
    },

    /**
     * @experimental
     * Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.
     */

    setNodeStackTracesEnabled: async (
      opts: { enable: boolean },
    ): Promise<any> => {
      return await this.#sendReq("DOM.setNodeStackTracesEnabled", opts);
    },

    /**
     * @experimental
     * Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.
     */

    getNodeStackTraces: async (opts: { nodeId: DOM_NodeId }): Promise<any> => {
      return await this.#sendReq("DOM.getNodeStackTraces", opts);
    },

    /**
     * @experimental
     * Returns file information for the given
     * File wrapper.
     */

    getFileInfo: async (
      opts: { objectId: Runtime_RemoteObjectId },
    ): Promise<any> => {
      return await this.#sendReq("DOM.getFileInfo", opts);
    },

    /**
     * @experimental
     * Enables console to refer to the node with given id via $x (see Command Line API for more details
     * $x functions).
     */

    setInspectedNode: async (opts: { nodeId: DOM_NodeId }): Promise<any> => {
      return await this.#sendReq("DOM.setInspectedNode", opts);
    },

    /**
     * Sets node name for a node with given id.
     */

    setNodeName: async (
      opts: { nodeId: DOM_NodeId; name: string },
    ): Promise<any> => {
      return await this.#sendReq("DOM.setNodeName", opts);
    },

    /**
     * Sets node value for a node with given id.
     */

    setNodeValue: async (
      opts: { nodeId: DOM_NodeId; value: string },
    ): Promise<any> => {
      return await this.#sendReq("DOM.setNodeValue", opts);
    },

    /**
     * Sets node HTML markup, returns new node id.
     */

    setOuterHTML: async (
      opts: { nodeId: DOM_NodeId; outerHTML: string },
    ): Promise<any> => {
      return await this.#sendReq("DOM.setOuterHTML", opts);
    },

    /**
     * @experimental
     * Undoes the last performed action.
     */

    undo: async (): Promise<any> => {
      return await this.#sendReq("DOM.undo");
    },

    /**
     * @experimental
     * Returns iframe node that owns iframe with the given domain.
     */

    getFrameOwner: async (opts: { frameId: Page_FrameId }): Promise<any> => {
      return await this.#sendReq("DOM.getFrameOwner", opts);
    },

    /**
     * @experimental
     * Returns the query container of the given node based on container query
     * conditions: containerName, physical, and logical axes. If no axes are
     * provided, the style container is returned, which is the direct parent or the
     * closest element with a matching container-name.
     */

    getContainerForNode: async (
      opts: {
        nodeId: DOM_NodeId;
        containerName: string;
        physicalAxes: DOM_PhysicalAxes;
        logicalAxes: DOM_LogicalAxes;
      },
    ): Promise<any> => {
      return await this.#sendReq("DOM.getContainerForNode", opts);
    },

    /**
     * @experimental
     * Returns the descendants of a container query container that have
     * container queries against this container.
     */

    getQueryingDescendantsForContainer: async (
      opts: { nodeId: DOM_NodeId },
    ): Promise<any> => {
      return await this.#sendReq(
        "DOM.getQueryingDescendantsForContainer",
        opts,
      );
    },
  };

  /**
   * DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript
   * execution will stop on these operations as if there was a regular breakpoint set.
   */
  DOMDebugger = {
    /**
     * Returns event listeners of the given object.
     */

    getEventListeners: async (
      opts: {
        objectId: Runtime_RemoteObjectId;
        depth: number;
        pierce: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("DOMDebugger.getEventListeners", opts);
    },

    /**
     * Removes DOM breakpoint that was set using `setDOMBreakpoint`.
     */

    removeDOMBreakpoint: async (
      opts: { nodeId: DOM_NodeId; type: DOMDebugger_DOMBreakpointType },
    ): Promise<any> => {
      return await this.#sendReq("DOMDebugger.removeDOMBreakpoint", opts);
    },

    /**
     * Removes breakpoint on particular DOM event.
     */

    removeEventListenerBreakpoint: async (
      opts: { eventName: string; targetName: string },
    ): Promise<any> => {
      return await this.#sendReq(
        "DOMDebugger.removeEventListenerBreakpoint",
        opts,
      );
    },

    /**
     * @experimental
     * Removes breakpoint on particular native event.
     */

    removeInstrumentationBreakpoint: async (
      opts: { eventName: string },
    ): Promise<any> => {
      return await this.#sendReq(
        "DOMDebugger.removeInstrumentationBreakpoint",
        opts,
      );
    },

    /**
     * Removes breakpoint from XMLHttpRequest.
     */

    removeXHRBreakpoint: async (opts: { url: string }): Promise<any> => {
      return await this.#sendReq("DOMDebugger.removeXHRBreakpoint", opts);
    },

    /**
     * @experimental
     * Sets breakpoint on particular CSP violations.
     */

    setBreakOnCSPViolation: async (
      opts: { violationTypes: DOMDebugger_CSPViolationType[] },
    ): Promise<any> => {
      return await this.#sendReq("DOMDebugger.setBreakOnCSPViolation", opts);
    },

    /**
     * Sets breakpoint on particular operation with DOM.
     */

    setDOMBreakpoint: async (
      opts: { nodeId: DOM_NodeId; type: DOMDebugger_DOMBreakpointType },
    ): Promise<any> => {
      return await this.#sendReq("DOMDebugger.setDOMBreakpoint", opts);
    },

    /**
     * Sets breakpoint on particular DOM event.
     */

    setEventListenerBreakpoint: async (
      opts: { eventName: string; targetName: string },
    ): Promise<any> => {
      return await this.#sendReq(
        "DOMDebugger.setEventListenerBreakpoint",
        opts,
      );
    },

    /**
     * @experimental
     * Sets breakpoint on particular native event.
     */

    setInstrumentationBreakpoint: async (
      opts: { eventName: string },
    ): Promise<any> => {
      return await this.#sendReq(
        "DOMDebugger.setInstrumentationBreakpoint",
        opts,
      );
    },

    /**
     * Sets breakpoint on XMLHttpRequest.
     */

    setXHRBreakpoint: async (opts: { url: string }): Promise<any> => {
      return await this.#sendReq("DOMDebugger.setXHRBreakpoint", opts);
    },
  };

  /**
   * @experimental
   * EventBreakpoints permits setting breakpoints on particular operations and
   * events in targets that run JavaScript but do not have a DOM.
   * JavaScript execution will stop on these operations as if there was a regular
   * breakpoint set.
   */
  EventBreakpoints = {
    /**
     * Sets breakpoint on particular native event.
     */

    setInstrumentationBreakpoint: async (
      opts: { eventName: string },
    ): Promise<any> => {
      return await this.#sendReq(
        "EventBreakpoints.setInstrumentationBreakpoint",
        opts,
      );
    },

    /**
     * Removes breakpoint on particular native event.
     */

    removeInstrumentationBreakpoint: async (
      opts: { eventName: string },
    ): Promise<any> => {
      return await this.#sendReq(
        "EventBreakpoints.removeInstrumentationBreakpoint",
        opts,
      );
    },
  };

  /**
   * @experimental
   * This domain facilitates obtaining document snapshots with DOM, layout, and style information.
   */
  DOMSnapshot = {
    /**
     * Disables DOM snapshot agent for the given page.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("DOMSnapshot.disable");
    },

    /**
     * Enables DOM snapshot agent for the given page.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("DOMSnapshot.enable");
    },

    /**
     * @deprecated
     * Returns a document snapshot, including the full DOM tree of the root node (including iframes,
     * template contents, and imported documents) in a flattened array, as well as layout and
     * white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
     * flattened.
     */

    getSnapshot: async (
      opts: {
        computedStyleWhitelist: string[];
        includeEventListeners: boolean;
        includePaintOrder: boolean;
        includeUserAgentShadowTree: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("DOMSnapshot.getSnapshot", opts);
    },

    /**
     * Returns a document snapshot, including the full DOM tree of the root node (including iframes,
     * template contents, and imported documents) in a flattened array, as well as layout and
     * white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
     * flattened.
     */

    captureSnapshot: async (
      opts: {
        computedStyles: string[];
        includePaintOrder: boolean;
        includeDOMRects: boolean;
        includeBlendedBackgroundColors: boolean;
        includeTextColorOpacities: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("DOMSnapshot.captureSnapshot", opts);
    },
  };

  /**
   * @experimental
   * Query and modify DOM storage.
   */
  DOMStorage = {
    clear: async (opts: { storageId: DOMStorage_StorageId }): Promise<any> => {
      return await this.#sendReq("DOMStorage.clear", opts);
    },

    /**
     * Disables storage tracking, prevents storage events from being sent to the client.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("DOMStorage.disable");
    },

    /**
     * Enables storage tracking, storage events will now be delivered to the client.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("DOMStorage.enable");
    },

    getDOMStorageItems: async (
      opts: { storageId: DOMStorage_StorageId },
    ): Promise<any> => {
      return await this.#sendReq("DOMStorage.getDOMStorageItems", opts);
    },

    removeDOMStorageItem: async (
      opts: { storageId: DOMStorage_StorageId; key: string },
    ): Promise<any> => {
      return await this.#sendReq("DOMStorage.removeDOMStorageItem", opts);
    },

    setDOMStorageItem: async (
      opts: { storageId: DOMStorage_StorageId; key: string; value: string },
    ): Promise<any> => {
      return await this.#sendReq("DOMStorage.setDOMStorageItem", opts);
    },
  };

  /**
   * @experimental
   */
  Database = {
    /**
     * Disables database tracking, prevents database events from being sent to the client.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Database.disable");
    },

    /**
     * Enables database tracking, database events will now be delivered to the client.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("Database.enable");
    },

    executeSQL: async (
      opts: { databaseId: Database_DatabaseId; query: string },
    ): Promise<any> => {
      return await this.#sendReq("Database.executeSQL", opts);
    },

    getDatabaseTableNames: async (
      opts: { databaseId: Database_DatabaseId },
    ): Promise<any> => {
      return await this.#sendReq("Database.getDatabaseTableNames", opts);
    },
  };

  /**
   * @experimental
   */
  DeviceOrientation = {
    /**
     * Clears the overridden Device Orientation.
     */

    clearDeviceOrientationOverride: async (): Promise<any> => {
      return await this.#sendReq(
        "DeviceOrientation.clearDeviceOrientationOverride",
      );
    },

    /**
     * Overrides the Device Orientation.
     */

    setDeviceOrientationOverride: async (
      opts: { alpha: number; beta: number; gamma: number },
    ): Promise<any> => {
      return await this.#sendReq(
        "DeviceOrientation.setDeviceOrientationOverride",
        opts,
      );
    },
  };

  /**
   * This domain emulates different environments for the page.
   */
  Emulation = {
    /**
     * Tells whether emulation is supported.
     */

    canEmulate: async (): Promise<any> => {
      return await this.#sendReq("Emulation.canEmulate");
    },

    /**
     * Clears the overridden device metrics.
     */

    clearDeviceMetricsOverride: async (): Promise<any> => {
      return await this.#sendReq("Emulation.clearDeviceMetricsOverride");
    },

    /**
     * Clears the overridden Geolocation Position and Error.
     */

    clearGeolocationOverride: async (): Promise<any> => {
      return await this.#sendReq("Emulation.clearGeolocationOverride");
    },

    /**
     * @experimental
     * Requests that page scale factor is reset to initial values.
     */

    resetPageScaleFactor: async (): Promise<any> => {
      return await this.#sendReq("Emulation.resetPageScaleFactor");
    },

    /**
     * @experimental
     * Enables or disables simulating a focused and active page.
     */

    setFocusEmulationEnabled: async (
      opts: { enabled: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Emulation.setFocusEmulationEnabled", opts);
    },

    /**
     * @experimental
     * Automatically render all web contents using a dark theme.
     */

    setAutoDarkModeOverride: async (
      opts: { enabled: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Emulation.setAutoDarkModeOverride", opts);
    },

    /**
     * @experimental
     * Enables CPU throttling to emulate slow CPUs.
     */

    setCPUThrottlingRate: async (opts: { rate: number }): Promise<any> => {
      return await this.#sendReq("Emulation.setCPUThrottlingRate", opts);
    },

    /**
     * Sets or clears an override of the default background color of the frame. This override is used
     * if the content does not specify one.
     */

    setDefaultBackgroundColorOverride: async (
      opts: { color: DOM_RGBA },
    ): Promise<any> => {
      return await this.#sendReq(
        "Emulation.setDefaultBackgroundColorOverride",
        opts,
      );
    },

    /**
     * Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
     * window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
     * query results).
     */

    setDeviceMetricsOverride: async (
      opts: {
        width: number;
        height: number;
        deviceScaleFactor: number;
        mobile: boolean;
        scale: number;
        screenWidth: number;
        screenHeight: number;
        positionX: number;
        positionY: number;
        dontSetVisibleSize: boolean;
        screenOrientation: Emulation_ScreenOrientation;
        viewport: Page_Viewport;
        displayFeature: Emulation_DisplayFeature;
      },
    ): Promise<any> => {
      return await this.#sendReq("Emulation.setDeviceMetricsOverride", opts);
    },

    /**
     * @experimental
     */

    setScrollbarsHidden: async (opts: { hidden: boolean }): Promise<any> => {
      return await this.#sendReq("Emulation.setScrollbarsHidden", opts);
    },

    /**
     * @experimental
     */

    setDocumentCookieDisabled: async (
      opts: { disabled: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Emulation.setDocumentCookieDisabled", opts);
    },

    /**
     * @experimental
     */

    setEmitTouchEventsForMouse: async (
      opts: { enabled: boolean; configuration: "mobile" | "desktop" },
    ): Promise<any> => {
      return await this.#sendReq("Emulation.setEmitTouchEventsForMouse", opts);
    },

    /**
     * Emulates the given media type or media feature for CSS media queries.
     */

    setEmulatedMedia: async (
      opts: { media: string; features: Emulation_MediaFeature[] },
    ): Promise<any> => {
      return await this.#sendReq("Emulation.setEmulatedMedia", opts);
    },

    /**
     * @experimental
     * Emulates the given vision deficiency.
     */

    setEmulatedVisionDeficiency: async (
      opts: {
        type:
          | "none"
          | "blurredVision"
          | "reducedContrast"
          | "achromatopsia"
          | "deuteranopia"
          | "protanopia"
          | "tritanopia";
      },
    ): Promise<any> => {
      return await this.#sendReq("Emulation.setEmulatedVisionDeficiency", opts);
    },

    /**
     * Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
     * unavailable.
     */

    setGeolocationOverride: async (
      opts: { latitude: number; longitude: number; accuracy: number },
    ): Promise<any> => {
      return await this.#sendReq("Emulation.setGeolocationOverride", opts);
    },

    /**
     * @experimental
     * Overrides the Idle state.
     */

    setIdleOverride: async (
      opts: { isUserActive: boolean; isScreenUnlocked: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Emulation.setIdleOverride", opts);
    },

    /**
     * @experimental
     * Clears Idle state overrides.
     */

    clearIdleOverride: async (): Promise<any> => {
      return await this.#sendReq("Emulation.clearIdleOverride");
    },

    /**
     * @experimental
     * @deprecated
     * Overrides value returned by the javascript navigator object.
     */

    setNavigatorOverrides: async (opts: { platform: string }): Promise<any> => {
      return await this.#sendReq("Emulation.setNavigatorOverrides", opts);
    },

    /**
     * @experimental
     * Sets a specified page scale factor.
     */

    setPageScaleFactor: async (
      opts: { pageScaleFactor: number },
    ): Promise<any> => {
      return await this.#sendReq("Emulation.setPageScaleFactor", opts);
    },

    /**
     * Switches script execution in the page.
     */

    setScriptExecutionDisabled: async (
      opts: { value: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Emulation.setScriptExecutionDisabled", opts);
    },

    /**
     * Enables touch on platforms which do not support them.
     */

    setTouchEmulationEnabled: async (
      opts: { enabled: boolean; maxTouchPoints: number },
    ): Promise<any> => {
      return await this.#sendReq("Emulation.setTouchEmulationEnabled", opts);
    },

    /**
     * @experimental
     * Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
     * the current virtual time policy.  Note this supersedes any previous time budget.
     */

    setVirtualTimePolicy: async (
      opts: {
        policy: Emulation_VirtualTimePolicy;
        budget: number;
        maxVirtualTimeTaskStarvationCount: number;
        initialVirtualTime: Network_TimeSinceEpoch;
      },
    ): Promise<any> => {
      return await this.#sendReq("Emulation.setVirtualTimePolicy", opts);
    },

    /**
     * @experimental
     * Overrides default host system locale with the specified one.
     */

    setLocaleOverride: async (opts: { locale: string }): Promise<any> => {
      return await this.#sendReq("Emulation.setLocaleOverride", opts);
    },

    /**
     * @experimental
     * Overrides default host system timezone with the specified one.
     */

    setTimezoneOverride: async (opts: { timezoneId: string }): Promise<any> => {
      return await this.#sendReq("Emulation.setTimezoneOverride", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Resizes the frame/viewport of the page. Note that this does not affect the frame's container
     * (e.g. browser window). Can be used to produce screenshots of the specified size. Not supported
     * on Android.
     */

    setVisibleSize: async (
      opts: { width: number; height: number },
    ): Promise<any> => {
      return await this.#sendReq("Emulation.setVisibleSize", opts);
    },

    /**
     * @experimental
     */

    setDisabledImageTypes: async (
      opts: { imageTypes: Emulation_DisabledImageType[] },
    ): Promise<any> => {
      return await this.#sendReq("Emulation.setDisabledImageTypes", opts);
    },

    /**
     * @experimental
     */

    setHardwareConcurrencyOverride: async (
      opts: { hardwareConcurrency: number },
    ): Promise<any> => {
      return await this.#sendReq(
        "Emulation.setHardwareConcurrencyOverride",
        opts,
      );
    },

    /**
     * Allows overriding user agent with the given string.
     */

    setUserAgentOverride: async (
      opts: {
        userAgent: string;
        acceptLanguage: string;
        platform: string;
        userAgentMetadata: Emulation_UserAgentMetadata;
      },
    ): Promise<any> => {
      return await this.#sendReq("Emulation.setUserAgentOverride", opts);
    },

    /**
     * @experimental
     * Allows overriding the automation flag.
     */

    setAutomationOverride: async (opts: { enabled: boolean }): Promise<any> => {
      return await this.#sendReq("Emulation.setAutomationOverride", opts);
    },
  };

  /**
   * @experimental
   * This domain provides experimental commands only supported in headless mode.
   */
  HeadlessExperimental = {
    /**
     * Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
     * screenshot from the resulting frame. Requires that the target was created with enabled
     * BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
     * https://goo.gle/chrome-headless-rendering for more background.
     */

    beginFrame: async (
      opts: {
        frameTimeTicks: number;
        interval: number;
        noDisplayUpdates: boolean;
        screenshot: HeadlessExperimental_ScreenshotParams;
      },
    ): Promise<any> => {
      return await this.#sendReq("HeadlessExperimental.beginFrame", opts);
    },

    /**
     * @deprecated
     * Disables headless events for the target.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("HeadlessExperimental.disable");
    },

    /**
     * @deprecated
     * Enables headless events for the target.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("HeadlessExperimental.enable");
    },
  };

  /**
   * Input/Output operations for streams produced by DevTools.
   */
  IO = {
    /**
     * Close the stream, discard any temporary backing storage.
     */

    close: async (opts: { handle: IO_StreamHandle }): Promise<any> => {
      return await this.#sendReq("IO.close", opts);
    },

    /**
     * Read a chunk of the stream
     */

    read: async (
      opts: { handle: IO_StreamHandle; offset: number; size: number },
    ): Promise<any> => {
      return await this.#sendReq("IO.read", opts);
    },

    /**
     * Return UUID of Blob object specified by a remote object id.
     */

    resolveBlob: async (
      opts: { objectId: Runtime_RemoteObjectId },
    ): Promise<any> => {
      return await this.#sendReq("IO.resolveBlob", opts);
    },
  };

  /**
   * @experimental
   */
  IndexedDB = {
    /**
     * Clears all entries from an object store.
     */

    clearObjectStore: async (
      opts: {
        securityOrigin: string;
        storageKey: string;
        storageBucket: Storage_StorageBucket;
        databaseName: string;
        objectStoreName: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("IndexedDB.clearObjectStore", opts);
    },

    /**
     * Deletes a database.
     */

    deleteDatabase: async (
      opts: {
        securityOrigin: string;
        storageKey: string;
        storageBucket: Storage_StorageBucket;
        databaseName: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("IndexedDB.deleteDatabase", opts);
    },

    /**
     * Delete a range of entries from an object store
     */

    deleteObjectStoreEntries: async (
      opts: {
        securityOrigin: string;
        storageKey: string;
        storageBucket: Storage_StorageBucket;
        databaseName: string;
        objectStoreName: string;
        keyRange: IndexedDB_KeyRange;
      },
    ): Promise<any> => {
      return await this.#sendReq("IndexedDB.deleteObjectStoreEntries", opts);
    },

    /**
     * Disables events from backend.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("IndexedDB.disable");
    },

    /**
     * Enables events from backend.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("IndexedDB.enable");
    },

    /**
     * Requests data from object store or index.
     */

    requestData: async (
      opts: {
        securityOrigin: string;
        storageKey: string;
        storageBucket: Storage_StorageBucket;
        databaseName: string;
        objectStoreName: string;
        indexName: string;
        skipCount: number;
        pageSize: number;
        keyRange: IndexedDB_KeyRange;
      },
    ): Promise<any> => {
      return await this.#sendReq("IndexedDB.requestData", opts);
    },

    /**
     * Gets metadata of an object store.
     */

    getMetadata: async (
      opts: {
        securityOrigin: string;
        storageKey: string;
        storageBucket: Storage_StorageBucket;
        databaseName: string;
        objectStoreName: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("IndexedDB.getMetadata", opts);
    },

    /**
     * Requests database with given name in given frame.
     */

    requestDatabase: async (
      opts: {
        securityOrigin: string;
        storageKey: string;
        storageBucket: Storage_StorageBucket;
        databaseName: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("IndexedDB.requestDatabase", opts);
    },

    /**
     * Requests database names for given security origin.
     */

    requestDatabaseNames: async (
      opts: {
        securityOrigin: string;
        storageKey: string;
        storageBucket: Storage_StorageBucket;
      },
    ): Promise<any> => {
      return await this.#sendReq("IndexedDB.requestDatabaseNames", opts);
    },
  };

  Input = {
    /**
     * @experimental
     * Dispatches a drag event into the page.
     */

    dispatchDragEvent: async (
      opts: {
        type: "dragEnter" | "dragOver" | "drop" | "dragCancel";
        x: number;
        y: number;
        data: Input_DragData;
        modifiers: number;
      },
    ): Promise<any> => {
      return await this.#sendReq("Input.dispatchDragEvent", opts);
    },

    /**
     * Dispatches a key event to the page.
     */

    dispatchKeyEvent: async (
      opts: {
        type: "keyDown" | "keyUp" | "rawKeyDown" | "char";
        modifiers: number;
        timestamp: Input_TimeSinceEpoch;
        text: string;
        unmodifiedText: string;
        keyIdentifier: string;
        code: string;
        key: string;
        windowsVirtualKeyCode: number;
        nativeVirtualKeyCode: number;
        autoRepeat: boolean;
        isKeypad: boolean;
        isSystemKey: boolean;
        location: number;
        commands: string[];
      },
    ): Promise<any> => {
      return await this.#sendReq("Input.dispatchKeyEvent", opts);
    },

    /**
     * @experimental
     * This method emulates inserting text that doesn't come from a key press,
     * for example an emoji keyboard or an IME.
     */

    insertText: async (opts: { text: string }): Promise<any> => {
      return await this.#sendReq("Input.insertText", opts);
    },

    /**
     * @experimental
     * This method sets the current candidate text for ime.
     * Use imeCommitComposition to commit the final text.
     * Use imeSetComposition with empty string as text to cancel composition.
     */

    imeSetComposition: async (
      opts: {
        text: string;
        selectionStart: number;
        selectionEnd: number;
        replacementStart: number;
        replacementEnd: number;
      },
    ): Promise<any> => {
      return await this.#sendReq("Input.imeSetComposition", opts);
    },

    /**
     * Dispatches a mouse event to the page.
     */

    dispatchMouseEvent: async (
      opts: {
        type: "mousePressed" | "mouseReleased" | "mouseMoved" | "mouseWheel";
        x: number;
        y: number;
        modifiers: number;
        timestamp: Input_TimeSinceEpoch;
        button: Input_MouseButton;
        buttons: number;
        clickCount: number;
        force: number;
        tangentialPressure: number;
        tiltX: number;
        tiltY: number;
        twist: number;
        deltaX: number;
        deltaY: number;
        pointerType: "mouse" | "pen";
      },
    ): Promise<any> => {
      return await this.#sendReq("Input.dispatchMouseEvent", opts);
    },

    /**
     * Dispatches a touch event to the page.
     */

    dispatchTouchEvent: async (
      opts: {
        type: "touchStart" | "touchEnd" | "touchMove" | "touchCancel";
        touchPoints: Input_TouchPoint[];
        modifiers: number;
        timestamp: Input_TimeSinceEpoch;
      },
    ): Promise<any> => {
      return await this.#sendReq("Input.dispatchTouchEvent", opts);
    },

    /**
     * Cancels any active dragging in the page.
     */

    cancelDragging: async (): Promise<any> => {
      return await this.#sendReq("Input.cancelDragging");
    },

    /**
     * @experimental
     * Emulates touch event from the mouse event parameters.
     */

    emulateTouchFromMouseEvent: async (
      opts: {
        type: "mousePressed" | "mouseReleased" | "mouseMoved" | "mouseWheel";
        x: number;
        y: number;
        button: Input_MouseButton;
        timestamp: Input_TimeSinceEpoch;
        deltaX: number;
        deltaY: number;
        modifiers: number;
        clickCount: number;
      },
    ): Promise<any> => {
      return await this.#sendReq("Input.emulateTouchFromMouseEvent", opts);
    },

    /**
     * Ignores input events (useful while auditing page).
     */

    setIgnoreInputEvents: async (opts: { ignore: boolean }): Promise<any> => {
      return await this.#sendReq("Input.setIgnoreInputEvents", opts);
    },

    /**
     * @experimental
     * Prevents default drag and drop behavior and instead emits `Input.dragIntercepted` events.
     * Drag and drop behavior can be directly controlled via `Input.dispatchDragEvent`.
     */

    setInterceptDrags: async (opts: { enabled: boolean }): Promise<any> => {
      return await this.#sendReq("Input.setInterceptDrags", opts);
    },

    /**
     * @experimental
     * Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
     */

    synthesizePinchGesture: async (
      opts: {
        x: number;
        y: number;
        scaleFactor: number;
        relativeSpeed: number;
        gestureSourceType: Input_GestureSourceType;
      },
    ): Promise<any> => {
      return await this.#sendReq("Input.synthesizePinchGesture", opts);
    },

    /**
     * @experimental
     * Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
     */

    synthesizeScrollGesture: async (
      opts: {
        x: number;
        y: number;
        xDistance: number;
        yDistance: number;
        xOverscroll: number;
        yOverscroll: number;
        preventFling: boolean;
        speed: number;
        gestureSourceType: Input_GestureSourceType;
        repeatCount: number;
        repeatDelayMs: number;
        interactionMarkerName: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("Input.synthesizeScrollGesture", opts);
    },

    /**
     * @experimental
     * Synthesizes a tap gesture over a time period by issuing appropriate touch events.
     */

    synthesizeTapGesture: async (
      opts: {
        x: number;
        y: number;
        duration: number;
        tapCount: number;
        gestureSourceType: Input_GestureSourceType;
      },
    ): Promise<any> => {
      return await this.#sendReq("Input.synthesizeTapGesture", opts);
    },
  };

  /**
   * @experimental
   */
  Inspector = {
    /**
     * Disables inspector domain notifications.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Inspector.disable");
    },

    /**
     * Enables inspector domain notifications.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("Inspector.enable");
    },
  };

  /**
   * @experimental
   */
  LayerTree = {
    /**
     * Provides the reasons why the given layer was composited.
     */

    compositingReasons: async (
      opts: { layerId: LayerTree_LayerId },
    ): Promise<any> => {
      return await this.#sendReq("LayerTree.compositingReasons", opts);
    },

    /**
     * Disables compositing tree inspection.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("LayerTree.disable");
    },

    /**
     * Enables compositing tree inspection.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("LayerTree.enable");
    },

    /**
     * Returns the snapshot identifier.
     */

    loadSnapshot: async (
      opts: { tiles: LayerTree_PictureTile[] },
    ): Promise<any> => {
      return await this.#sendReq("LayerTree.loadSnapshot", opts);
    },

    /**
     * Returns the layer snapshot identifier.
     */

    makeSnapshot: async (
      opts: { layerId: LayerTree_LayerId },
    ): Promise<any> => {
      return await this.#sendReq("LayerTree.makeSnapshot", opts);
    },

    profileSnapshot: async (
      opts: {
        snapshotId: LayerTree_SnapshotId;
        minRepeatCount: number;
        minDuration: number;
        clipRect: DOM_Rect;
      },
    ): Promise<any> => {
      return await this.#sendReq("LayerTree.profileSnapshot", opts);
    },

    /**
     * Releases layer snapshot captured by the back-end.
     */

    releaseSnapshot: async (
      opts: { snapshotId: LayerTree_SnapshotId },
    ): Promise<any> => {
      return await this.#sendReq("LayerTree.releaseSnapshot", opts);
    },

    /**
     * Replays the layer snapshot and returns the resulting bitmap.
     */

    replaySnapshot: async (
      opts: {
        snapshotId: LayerTree_SnapshotId;
        fromStep: number;
        toStep: number;
        scale: number;
      },
    ): Promise<any> => {
      return await this.#sendReq("LayerTree.replaySnapshot", opts);
    },

    /**
     * Replays the layer snapshot and returns canvas log.
     */

    snapshotCommandLog: async (
      opts: { snapshotId: LayerTree_SnapshotId },
    ): Promise<any> => {
      return await this.#sendReq("LayerTree.snapshotCommandLog", opts);
    },
  };

  /**
   * Provides access to log entries.
   */
  Log = {
    /**
     * Clears the log.
     */

    clear: async (): Promise<any> => {
      return await this.#sendReq("Log.clear");
    },

    /**
     * Disables log domain, prevents further log entries from being reported to the client.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Log.disable");
    },

    /**
     * Enables log domain, sends the entries collected so far to the client by means of the
     * `entryAdded` notification.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("Log.enable");
    },

    /**
     * start violation reporting.
     */

    startViolationsReport: async (
      opts: { config: Log_ViolationSetting[] },
    ): Promise<any> => {
      return await this.#sendReq("Log.startViolationsReport", opts);
    },

    /**
     * Stop violation reporting.
     */

    stopViolationsReport: async (): Promise<any> => {
      return await this.#sendReq("Log.stopViolationsReport");
    },
  };

  /**
   * @experimental
   */
  Memory = {
    getDOMCounters: async (): Promise<any> => {
      return await this.#sendReq("Memory.getDOMCounters");
    },

    prepareForLeakDetection: async (): Promise<any> => {
      return await this.#sendReq("Memory.prepareForLeakDetection");
    },

    /**
     * Simulate OomIntervention by purging V8 memory.
     */

    forciblyPurgeJavaScriptMemory: async (): Promise<any> => {
      return await this.#sendReq("Memory.forciblyPurgeJavaScriptMemory");
    },

    /**
     * Enable/disable suppressing memory pressure notifications in all processes.
     */

    setPressureNotificationsSuppressed: async (
      opts: { suppressed: boolean },
    ): Promise<any> => {
      return await this.#sendReq(
        "Memory.setPressureNotificationsSuppressed",
        opts,
      );
    },

    /**
     * Simulate a memory pressure notification in all processes.
     */

    simulatePressureNotification: async (
      opts: { level: Memory_PressureLevel },
    ): Promise<any> => {
      return await this.#sendReq("Memory.simulatePressureNotification", opts);
    },

    /**
     * Start collecting native memory profile.
     */

    startSampling: async (
      opts: { samplingInterval: number; suppressRandomness: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Memory.startSampling", opts);
    },

    /**
     * Stop collecting native memory profile.
     */

    stopSampling: async (): Promise<any> => {
      return await this.#sendReq("Memory.stopSampling");
    },

    /**
     * Retrieve native memory allocations profile
     * collected since renderer process startup.
     */

    getAllTimeSamplingProfile: async (): Promise<any> => {
      return await this.#sendReq("Memory.getAllTimeSamplingProfile");
    },

    /**
     * Retrieve native memory allocations profile
     * collected since browser process startup.
     */

    getBrowserSamplingProfile: async (): Promise<any> => {
      return await this.#sendReq("Memory.getBrowserSamplingProfile");
    },

    /**
     * Retrieve native memory allocations profile collected since last
     * `startSampling` call.
     */

    getSamplingProfile: async (): Promise<any> => {
      return await this.#sendReq("Memory.getSamplingProfile");
    },
  };

  /**
   * Network domain allows tracking network activities of the page. It exposes information about http,
   * file, data and other requests and responses, their headers, bodies, timing, etc.
   */
  Network = {
    /**
     * @experimental
     * Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted.
     */

    setAcceptedEncodings: async (
      opts: { encodings: Network_ContentEncoding[] },
    ): Promise<any> => {
      return await this.#sendReq("Network.setAcceptedEncodings", opts);
    },

    /**
     * @experimental
     * Clears accepted encodings set by setAcceptedEncodings
     */

    clearAcceptedEncodingsOverride: async (): Promise<any> => {
      return await this.#sendReq("Network.clearAcceptedEncodingsOverride");
    },

    /**
     * @deprecated
     * Tells whether clearing browser cache is supported.
     */

    canClearBrowserCache: async (): Promise<any> => {
      return await this.#sendReq("Network.canClearBrowserCache");
    },

    /**
     * @deprecated
     * Tells whether clearing browser cookies is supported.
     */

    canClearBrowserCookies: async (): Promise<any> => {
      return await this.#sendReq("Network.canClearBrowserCookies");
    },

    /**
     * @deprecated
     * Tells whether emulation of network conditions is supported.
     */

    canEmulateNetworkConditions: async (): Promise<any> => {
      return await this.#sendReq("Network.canEmulateNetworkConditions");
    },

    /**
     * Clears browser cache.
     */

    clearBrowserCache: async (): Promise<any> => {
      return await this.#sendReq("Network.clearBrowserCache");
    },

    /**
     * Clears browser cookies.
     */

    clearBrowserCookies: async (): Promise<any> => {
      return await this.#sendReq("Network.clearBrowserCookies");
    },

    /**
     * @experimental
     * @deprecated
     * Response to Network.requestIntercepted which either modifies the request to continue with any
     * modifications, or blocks it, or completes it with the provided response bytes. If a network
     * fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
     * event will be sent with the same InterceptionId.
     * Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead.
     */

    continueInterceptedRequest: async (
      opts: {
        interceptionId: Network_InterceptionId;
        errorReason: Network_ErrorReason;
        rawResponse: string;
        url: string;
        method: string;
        postData: string;
        headers: Network_Headers;
        authChallengeResponse: Network_AuthChallengeResponse;
      },
    ): Promise<any> => {
      return await this.#sendReq("Network.continueInterceptedRequest", opts);
    },

    /**
     * Deletes browser cookies with matching name and url or domain/path pair.
     */

    deleteCookies: async (
      opts: { name: string; url: string; domain: string; path: string },
    ): Promise<any> => {
      return await this.#sendReq("Network.deleteCookies", opts);
    },

    /**
     * Disables network tracking, prevents network events from being sent to the client.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Network.disable");
    },

    /**
     * Activates emulation of network conditions.
     */

    emulateNetworkConditions: async (
      opts: {
        offline: boolean;
        latency: number;
        downloadThroughput: number;
        uploadThroughput: number;
        connectionType: Network_ConnectionType;
      },
    ): Promise<any> => {
      return await this.#sendReq("Network.emulateNetworkConditions", opts);
    },

    /**
     * Enables network tracking, network events will now be delivered to the client.
     */

    enable: async (
      opts: {
        maxTotalBufferSize: number;
        maxResourceBufferSize: number;
        maxPostDataSize: number;
      },
    ): Promise<any> => {
      return await this.#sendReq("Network.enable", opts);
    },

    /**
     * @deprecated
     * Returns all browser cookies. Depending on the backend support, will return detailed cookie
     * information in the `cookies` field.
     * Deprecated. Use Storage.getCookies instead.
     */

    getAllCookies: async (): Promise<any> => {
      return await this.#sendReq("Network.getAllCookies");
    },

    /**
     * @experimental
     * Returns the DER-encoded certificate.
     */

    getCertificate: async (opts: { origin: string }): Promise<any> => {
      return await this.#sendReq("Network.getCertificate", opts);
    },

    /**
     * Returns all browser cookies for the current URL. Depending on the backend support, will return
     * detailed cookie information in the `cookies` field.
     */

    getCookies: async (opts: { urls: string[] }): Promise<any> => {
      return await this.#sendReq("Network.getCookies", opts);
    },

    /**
     * Returns content served for the given request.
     */

    getResponseBody: async (
      opts: { requestId: Network_RequestId },
    ): Promise<any> => {
      return await this.#sendReq("Network.getResponseBody", opts);
    },

    /**
     * Returns post data sent with the request. Returns an error when no data was sent with the request.
     */

    getRequestPostData: async (
      opts: { requestId: Network_RequestId },
    ): Promise<any> => {
      return await this.#sendReq("Network.getRequestPostData", opts);
    },

    /**
     * @experimental
     * Returns content served for the given currently intercepted request.
     */

    getResponseBodyForInterception: async (
      opts: { interceptionId: Network_InterceptionId },
    ): Promise<any> => {
      return await this.#sendReq(
        "Network.getResponseBodyForInterception",
        opts,
      );
    },

    /**
     * @experimental
     * Returns a handle to the stream representing the response body. Note that after this command,
     * the intercepted request can't be continued as is -- you either need to cancel it or to provide
     * the response body. The stream only supports sequential read, IO.read will fail if the position
     * is specified.
     */

    takeResponseBodyForInterceptionAsStream: async (
      opts: { interceptionId: Network_InterceptionId },
    ): Promise<any> => {
      return await this.#sendReq(
        "Network.takeResponseBodyForInterceptionAsStream",
        opts,
      );
    },

    /**
     * @experimental
     * This method sends a new XMLHttpRequest which is identical to the original one. The following
     * parameters should be identical: method, url, async, request body, extra headers, withCredentials
     * attribute, user, password.
     */

    replayXHR: async (opts: { requestId: Network_RequestId }): Promise<any> => {
      return await this.#sendReq("Network.replayXHR", opts);
    },

    /**
     * @experimental
     * Searches for given string in response content.
     */

    searchInResponseBody: async (
      opts: {
        requestId: Network_RequestId;
        query: string;
        caseSensitive: boolean;
        isRegex: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Network.searchInResponseBody", opts);
    },

    /**
     * @experimental
     * Blocks URLs from loading.
     */

    setBlockedURLs: async (opts: { urls: string[] }): Promise<any> => {
      return await this.#sendReq("Network.setBlockedURLs", opts);
    },

    /**
     * @experimental
     * Toggles ignoring of service worker for each request.
     */

    setBypassServiceWorker: async (opts: { bypass: boolean }): Promise<any> => {
      return await this.#sendReq("Network.setBypassServiceWorker", opts);
    },

    /**
     * Toggles ignoring cache for each request. If `true`, cache will not be used.
     */

    setCacheDisabled: async (
      opts: { cacheDisabled: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Network.setCacheDisabled", opts);
    },

    /**
     * Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
     */

    setCookie: async (
      opts: {
        name: string;
        value: string;
        url: string;
        domain: string;
        path: string;
        secure: boolean;
        httpOnly: boolean;
        sameSite: Network_CookieSameSite;
        expires: Network_TimeSinceEpoch;
        priority: Network_CookiePriority;
        sameParty: boolean;
        sourceScheme: Network_CookieSourceScheme;
        sourcePort: number;
        partitionKey: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("Network.setCookie", opts);
    },

    /**
     * Sets given cookies.
     */

    setCookies: async (
      opts: { cookies: Network_CookieParam[] },
    ): Promise<any> => {
      return await this.#sendReq("Network.setCookies", opts);
    },

    /**
     * Specifies whether to always send extra HTTP headers with the requests from this page.
     */

    setExtraHTTPHeaders: async (
      opts: { headers: Network_Headers },
    ): Promise<any> => {
      return await this.#sendReq("Network.setExtraHTTPHeaders", opts);
    },

    /**
     * @experimental
     * Specifies whether to attach a page script stack id in requests
     */

    setAttachDebugStack: async (opts: { enabled: boolean }): Promise<any> => {
      return await this.#sendReq("Network.setAttachDebugStack", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Sets the requests to intercept that match the provided patterns and optionally resource types.
     * Deprecated, please use Fetch.enable instead.
     */

    setRequestInterception: async (
      opts: { patterns: Network_RequestPattern[] },
    ): Promise<any> => {
      return await this.#sendReq("Network.setRequestInterception", opts);
    },

    /**
     * Allows overriding user agent with the given string.
     */

    setUserAgentOverride: async (
      opts: {
        userAgent: string;
        acceptLanguage: string;
        platform: string;
        userAgentMetadata: Emulation_UserAgentMetadata;
      },
    ): Promise<any> => {
      return await this.#sendReq("Network.setUserAgentOverride", opts);
    },

    /**
     * @experimental
     * Returns information about the COEP/COOP isolation status.
     */

    getSecurityIsolationStatus: async (
      opts: { frameId: Page_FrameId },
    ): Promise<any> => {
      return await this.#sendReq("Network.getSecurityIsolationStatus", opts);
    },

    /**
     * @experimental
     * Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.
     * Enabling triggers 'reportingApiReportAdded' for all existing reports.
     */

    enableReportingApi: async (opts: { enable: boolean }): Promise<any> => {
      return await this.#sendReq("Network.enableReportingApi", opts);
    },

    /**
     * @experimental
     * Fetches the resource and returns the content.
     */

    loadNetworkResource: async (
      opts: {
        frameId: Page_FrameId;
        url: string;
        options: Network_LoadNetworkResourceOptions;
      },
    ): Promise<any> => {
      return await this.#sendReq("Network.loadNetworkResource", opts);
    },
  };

  /**
   * @experimental
   * This domain provides various functionality related to drawing atop the inspected page.
   */
  Overlay = {
    /**
     * Disables domain notifications.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Overlay.disable");
    },

    /**
     * Enables domain notifications.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("Overlay.enable");
    },

    /**
     * For testing.
     */

    getHighlightObjectForTest: async (
      opts: {
        nodeId: DOM_NodeId;
        includeDistance: boolean;
        includeStyle: boolean;
        colorFormat: Overlay_ColorFormat;
        showAccessibilityInfo: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.getHighlightObjectForTest", opts);
    },

    /**
     * For Persistent Grid testing.
     */

    getGridHighlightObjectsForTest: async (
      opts: { nodeIds: DOM_NodeId[] },
    ): Promise<any> => {
      return await this.#sendReq(
        "Overlay.getGridHighlightObjectsForTest",
        opts,
      );
    },

    /**
     * For Source Order Viewer testing.
     */

    getSourceOrderHighlightObjectForTest: async (
      opts: { nodeId: DOM_NodeId },
    ): Promise<any> => {
      return await this.#sendReq(
        "Overlay.getSourceOrderHighlightObjectForTest",
        opts,
      );
    },

    /**
     * Hides any highlight.
     */

    hideHighlight: async (): Promise<any> => {
      return await this.#sendReq("Overlay.hideHighlight");
    },

    /**
     * @deprecated
     * Highlights owner element of the frame with given id.
     * Deprecated: Doesn't work reliablity and cannot be fixed due to process
     * separatation (the owner node might be in a different process). Determine
     * the owner node in the client and use highlightNode.
     */

    highlightFrame: async (
      opts: {
        frameId: Page_FrameId;
        contentColor: DOM_RGBA;
        contentOutlineColor: DOM_RGBA;
      },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.highlightFrame", opts);
    },

    /**
     * Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or
     * objectId must be specified.
     */

    highlightNode: async (
      opts: {
        highlightConfig: Overlay_HighlightConfig;
        nodeId: DOM_NodeId;
        backendNodeId: DOM_BackendNodeId;
        objectId: Runtime_RemoteObjectId;
        selector: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.highlightNode", opts);
    },

    /**
     * Highlights given quad. Coordinates are absolute with respect to the main frame viewport.
     */

    highlightQuad: async (
      opts: { quad: DOM_Quad; color: DOM_RGBA; outlineColor: DOM_RGBA },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.highlightQuad", opts);
    },

    /**
     * Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.
     */

    highlightRect: async (
      opts: {
        x: number;
        y: number;
        width: number;
        height: number;
        color: DOM_RGBA;
        outlineColor: DOM_RGBA;
      },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.highlightRect", opts);
    },

    /**
     * Highlights the source order of the children of the DOM node with given id or with the given
     * JavaScript object wrapper. Either nodeId or objectId must be specified.
     */

    highlightSourceOrder: async (
      opts: {
        sourceOrderConfig: Overlay_SourceOrderConfig;
        nodeId: DOM_NodeId;
        backendNodeId: DOM_BackendNodeId;
        objectId: Runtime_RemoteObjectId;
      },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.highlightSourceOrder", opts);
    },

    /**
     * Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.
     * Backend then generates 'inspectNodeRequested' event upon element selection.
     */

    setInspectMode: async (
      opts: {
        mode: Overlay_InspectMode;
        highlightConfig: Overlay_HighlightConfig;
      },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.setInspectMode", opts);
    },

    /**
     * Highlights owner element of all frames detected to be ads.
     */

    setShowAdHighlights: async (opts: { show: boolean }): Promise<any> => {
      return await this.#sendReq("Overlay.setShowAdHighlights", opts);
    },

    setPausedInDebuggerMessage: async (
      opts: { message: string },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.setPausedInDebuggerMessage", opts);
    },

    /**
     * Requests that backend shows debug borders on layers
     */

    setShowDebugBorders: async (opts: { show: boolean }): Promise<any> => {
      return await this.#sendReq("Overlay.setShowDebugBorders", opts);
    },

    /**
     * Requests that backend shows the FPS counter
     */

    setShowFPSCounter: async (opts: { show: boolean }): Promise<any> => {
      return await this.#sendReq("Overlay.setShowFPSCounter", opts);
    },

    /**
     * Highlight multiple elements with the CSS Grid overlay.
     */

    setShowGridOverlays: async (
      opts: { gridNodeHighlightConfigs: Overlay_GridNodeHighlightConfig[] },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.setShowGridOverlays", opts);
    },

    setShowFlexOverlays: async (
      opts: { flexNodeHighlightConfigs: Overlay_FlexNodeHighlightConfig[] },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.setShowFlexOverlays", opts);
    },

    setShowScrollSnapOverlays: async (
      opts: { scrollSnapHighlightConfigs: Overlay_ScrollSnapHighlightConfig[] },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.setShowScrollSnapOverlays", opts);
    },

    setShowContainerQueryOverlays: async (
      opts: {
        containerQueryHighlightConfigs: Overlay_ContainerQueryHighlightConfig[];
      },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.setShowContainerQueryOverlays", opts);
    },

    /**
     * Requests that backend shows paint rectangles
     */

    setShowPaintRects: async (opts: { result: boolean }): Promise<any> => {
      return await this.#sendReq("Overlay.setShowPaintRects", opts);
    },

    /**
     * Requests that backend shows layout shift regions
     */

    setShowLayoutShiftRegions: async (
      opts: { result: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.setShowLayoutShiftRegions", opts);
    },

    /**
     * Requests that backend shows scroll bottleneck rects
     */

    setShowScrollBottleneckRects: async (
      opts: { show: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.setShowScrollBottleneckRects", opts);
    },

    /**
     * @deprecated
     * Deprecated, no longer has any effect.
     */

    setShowHitTestBorders: async (opts: { show: boolean }): Promise<any> => {
      return await this.#sendReq("Overlay.setShowHitTestBorders", opts);
    },

    /**
     * Request that backend shows an overlay with web vital metrics.
     */

    setShowWebVitals: async (opts: { show: boolean }): Promise<any> => {
      return await this.#sendReq("Overlay.setShowWebVitals", opts);
    },

    /**
     * Paints viewport size upon main frame resize.
     */

    setShowViewportSizeOnResize: async (
      opts: { show: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.setShowViewportSizeOnResize", opts);
    },

    /**
     * Add a dual screen device hinge
     */

    setShowHinge: async (
      opts: { hingeConfig: Overlay_HingeConfig },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.setShowHinge", opts);
    },

    /**
     * Show elements in isolation mode with overlays.
     */

    setShowIsolatedElements: async (
      opts: {
        isolatedElementHighlightConfigs:
          Overlay_IsolatedElementHighlightConfig[];
      },
    ): Promise<any> => {
      return await this.#sendReq("Overlay.setShowIsolatedElements", opts);
    },
  };

  /**
   * Actions and events related to the inspected page belong to the page domain.
   */
  Page = {
    /**
     * @experimental
     * @deprecated
     * Deprecated, please use addScriptToEvaluateOnNewDocument instead.
     */

    addScriptToEvaluateOnLoad: async (
      opts: { scriptSource: string },
    ): Promise<any> => {
      return await this.#sendReq("Page.addScriptToEvaluateOnLoad", opts);
    },

    /**
     * Evaluates given script in every frame upon creation (before loading frame's scripts).
     */

    addScriptToEvaluateOnNewDocument: async (
      opts: {
        source: string;
        worldName: string;
        includeCommandLineAPI: boolean;
        runImmediately: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Page.addScriptToEvaluateOnNewDocument", opts);
    },

    /**
     * Brings page to front (activates tab).
     */

    bringToFront: async (): Promise<any> => {
      return await this.#sendReq("Page.bringToFront");
    },

    /**
     * Capture page screenshot.
     */

    captureScreenshot: async (
      opts: {
        format: "jpeg" | "png" | "webp";
        quality: number;
        clip: Page_Viewport;
        fromSurface: boolean;
        captureBeyondViewport: boolean;
        optimizeForSpeed: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Page.captureScreenshot", opts);
    },

    /**
     * @experimental
     * Returns a snapshot of the page as a string. For MHTML format, the serialization includes
     * iframes, shadow DOM, external resources, and element-inline styles.
     */

    captureSnapshot: async (opts: { format: "mhtml" }): Promise<any> => {
      return await this.#sendReq("Page.captureSnapshot", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Clears the overridden device metrics.
     */

    clearDeviceMetricsOverride: async (): Promise<any> => {
      return await this.#sendReq("Page.clearDeviceMetricsOverride");
    },

    /**
     * @experimental
     * @deprecated
     * Clears the overridden Device Orientation.
     */

    clearDeviceOrientationOverride: async (): Promise<any> => {
      return await this.#sendReq("Page.clearDeviceOrientationOverride");
    },

    /**
     * @deprecated
     * Clears the overridden Geolocation Position and Error.
     */

    clearGeolocationOverride: async (): Promise<any> => {
      return await this.#sendReq("Page.clearGeolocationOverride");
    },

    /**
     * Creates an isolated world for the given frame.
     */

    createIsolatedWorld: async (
      opts: {
        frameId: Page_FrameId;
        worldName: string;
        grantUniveralAccess: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Page.createIsolatedWorld", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Deletes browser cookie with given name, domain and path.
     */

    deleteCookie: async (
      opts: { cookieName: string; url: string },
    ): Promise<any> => {
      return await this.#sendReq("Page.deleteCookie", opts);
    },

    /**
     * Disables page domain notifications.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Page.disable");
    },

    /**
     * Enables page domain notifications.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("Page.enable");
    },

    getAppManifest: async (): Promise<any> => {
      return await this.#sendReq("Page.getAppManifest");
    },

    /**
     * @experimental
     */

    getInstallabilityErrors: async (): Promise<any> => {
      return await this.#sendReq("Page.getInstallabilityErrors");
    },

    /**
     * @experimental
     * @deprecated
     * Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation.
     */

    getManifestIcons: async (): Promise<any> => {
      return await this.#sendReq("Page.getManifestIcons");
    },

    /**
     * @experimental
     * Returns the unique (PWA) app id.
     * Only returns values if the feature flag 'WebAppEnableManifestId' is enabled
     */

    getAppId: async (): Promise<any> => {
      return await this.#sendReq("Page.getAppId");
    },

    /**
     * @experimental
     */

    getAdScriptId: async (opts: { frameId: Page_FrameId }): Promise<any> => {
      return await this.#sendReq("Page.getAdScriptId", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Returns all browser cookies for the page and all of its subframes. Depending
     * on the backend support, will return detailed cookie information in the
     * `cookies` field.
     */

    getCookies: async (): Promise<any> => {
      return await this.#sendReq("Page.getCookies");
    },

    /**
     * Returns present frame tree structure.
     */

    getFrameTree: async (): Promise<any> => {
      return await this.#sendReq("Page.getFrameTree");
    },

    /**
     * Returns metrics relating to the layouting of the page, such as viewport bounds/scale.
     */

    getLayoutMetrics: async (): Promise<any> => {
      return await this.#sendReq("Page.getLayoutMetrics");
    },

    /**
     * Returns navigation history for the current page.
     */

    getNavigationHistory: async (): Promise<any> => {
      return await this.#sendReq("Page.getNavigationHistory");
    },

    /**
     * Resets navigation history for the current page.
     */

    resetNavigationHistory: async (): Promise<any> => {
      return await this.#sendReq("Page.resetNavigationHistory");
    },

    /**
     * @experimental
     * Returns content of the given resource.
     */

    getResourceContent: async (
      opts: { frameId: Page_FrameId; url: string },
    ): Promise<any> => {
      return await this.#sendReq("Page.getResourceContent", opts);
    },

    /**
     * @experimental
     * Returns present frame / resource tree structure.
     */

    getResourceTree: async (): Promise<any> => {
      return await this.#sendReq("Page.getResourceTree");
    },

    /**
     * Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
     */

    handleJavaScriptDialog: async (
      opts: { accept: boolean; promptText: string },
    ): Promise<any> => {
      return await this.#sendReq("Page.handleJavaScriptDialog", opts);
    },

    /**
     * Navigates current page to the given URL.
     */

    navigate: async (
      opts: {
        url: string;
        referrer: string;
        transitionType: Page_TransitionType;
        frameId: Page_FrameId;
        referrerPolicy: Page_ReferrerPolicy;
      },
    ): Promise<any> => {
      return await this.#sendReq("Page.navigate", opts);
    },

    /**
     * Navigates current page to the given history entry.
     */

    navigateToHistoryEntry: async (opts: { entryId: number }): Promise<any> => {
      return await this.#sendReq("Page.navigateToHistoryEntry", opts);
    },

    /**
     * Print page as PDF.
     */

    printToPDF: async (
      opts: {
        landscape: boolean;
        displayHeaderFooter: boolean;
        printBackground: boolean;
        scale: number;
        paperWidth: number;
        paperHeight: number;
        marginTop: number;
        marginBottom: number;
        marginLeft: number;
        marginRight: number;
        pageRanges: string;
        headerTemplate: string;
        footerTemplate: string;
        preferCSSPageSize: boolean;
        transferMode: "ReturnAsBase64" | "ReturnAsStream";
      },
    ): Promise<any> => {
      return await this.#sendReq("Page.printToPDF", opts);
    },

    /**
     * Reloads given page optionally ignoring the cache.
     */

    reload: async (
      opts: { ignoreCache: boolean; scriptToEvaluateOnLoad: string },
    ): Promise<any> => {
      return await this.#sendReq("Page.reload", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Deprecated, please use removeScriptToEvaluateOnNewDocument instead.
     */

    removeScriptToEvaluateOnLoad: async (
      opts: { identifier: Page_ScriptIdentifier },
    ): Promise<any> => {
      return await this.#sendReq("Page.removeScriptToEvaluateOnLoad", opts);
    },

    /**
     * Removes given script from the list.
     */

    removeScriptToEvaluateOnNewDocument: async (
      opts: { identifier: Page_ScriptIdentifier },
    ): Promise<any> => {
      return await this.#sendReq(
        "Page.removeScriptToEvaluateOnNewDocument",
        opts,
      );
    },

    /**
     * @experimental
     * Acknowledges that a screencast frame has been received by the frontend.
     */

    screencastFrameAck: async (opts: { sessionId: number }): Promise<any> => {
      return await this.#sendReq("Page.screencastFrameAck", opts);
    },

    /**
     * @experimental
     * Searches for given string in resource content.
     */

    searchInResource: async (
      opts: {
        frameId: Page_FrameId;
        url: string;
        query: string;
        caseSensitive: boolean;
        isRegex: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Page.searchInResource", opts);
    },

    /**
     * @experimental
     * Enable Chrome's experimental ad filter on all sites.
     */

    setAdBlockingEnabled: async (opts: { enabled: boolean }): Promise<any> => {
      return await this.#sendReq("Page.setAdBlockingEnabled", opts);
    },

    /**
     * @experimental
     * Enable page Content Security Policy by-passing.
     */

    setBypassCSP: async (opts: { enabled: boolean }): Promise<any> => {
      return await this.#sendReq("Page.setBypassCSP", opts);
    },

    /**
     * @experimental
     * Get Permissions Policy state on given frame.
     */

    getPermissionsPolicyState: async (
      opts: { frameId: Page_FrameId },
    ): Promise<any> => {
      return await this.#sendReq("Page.getPermissionsPolicyState", opts);
    },

    /**
     * @experimental
     * Get Origin Trials on given frame.
     */

    getOriginTrials: async (opts: { frameId: Page_FrameId }): Promise<any> => {
      return await this.#sendReq("Page.getOriginTrials", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
     * window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
     * query results).
     */

    setDeviceMetricsOverride: async (
      opts: {
        width: number;
        height: number;
        deviceScaleFactor: number;
        mobile: boolean;
        scale: number;
        screenWidth: number;
        screenHeight: number;
        positionX: number;
        positionY: number;
        dontSetVisibleSize: boolean;
        screenOrientation: Emulation_ScreenOrientation;
        viewport: Page_Viewport;
      },
    ): Promise<any> => {
      return await this.#sendReq("Page.setDeviceMetricsOverride", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Overrides the Device Orientation.
     */

    setDeviceOrientationOverride: async (
      opts: { alpha: number; beta: number; gamma: number },
    ): Promise<any> => {
      return await this.#sendReq("Page.setDeviceOrientationOverride", opts);
    },

    /**
     * @experimental
     * Set generic font families.
     */

    setFontFamilies: async (
      opts: {
        fontFamilies: Page_FontFamilies;
        forScripts: Page_ScriptFontFamilies[];
      },
    ): Promise<any> => {
      return await this.#sendReq("Page.setFontFamilies", opts);
    },

    /**
     * @experimental
     * Set default font sizes.
     */

    setFontSizes: async (opts: { fontSizes: Page_FontSizes }): Promise<any> => {
      return await this.#sendReq("Page.setFontSizes", opts);
    },

    /**
     * Sets given markup as the document's HTML.
     */

    setDocumentContent: async (
      opts: { frameId: Page_FrameId; html: string },
    ): Promise<any> => {
      return await this.#sendReq("Page.setDocumentContent", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Set the behavior when downloading a file.
     */

    setDownloadBehavior: async (
      opts: { behavior: "deny" | "allow" | "default"; downloadPath: string },
    ): Promise<any> => {
      return await this.#sendReq("Page.setDownloadBehavior", opts);
    },

    /**
     * @deprecated
     * Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
     * unavailable.
     */

    setGeolocationOverride: async (
      opts: { latitude: number; longitude: number; accuracy: number },
    ): Promise<any> => {
      return await this.#sendReq("Page.setGeolocationOverride", opts);
    },

    /**
     * @experimental
     * Controls whether page will emit lifecycle events.
     */

    setLifecycleEventsEnabled: async (
      opts: { enabled: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Page.setLifecycleEventsEnabled", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Toggles mouse event-based touch event emulation.
     */

    setTouchEmulationEnabled: async (
      opts: { enabled: boolean; configuration: "mobile" | "desktop" },
    ): Promise<any> => {
      return await this.#sendReq("Page.setTouchEmulationEnabled", opts);
    },

    /**
     * @experimental
     * Starts sending each frame using the `screencastFrame` event.
     */

    startScreencast: async (
      opts: {
        format: "jpeg" | "png";
        quality: number;
        maxWidth: number;
        maxHeight: number;
        everyNthFrame: number;
      },
    ): Promise<any> => {
      return await this.#sendReq("Page.startScreencast", opts);
    },

    /**
     * Force the page stop all navigations and pending resource fetches.
     */

    stopLoading: async (): Promise<any> => {
      return await this.#sendReq("Page.stopLoading");
    },

    /**
     * @experimental
     * Crashes renderer on the IO thread, generates minidumps.
     */

    crash: async (): Promise<any> => {
      return await this.#sendReq("Page.crash");
    },

    /**
     * @experimental
     * Tries to close page, running its beforeunload hooks, if any.
     */

    close: async (): Promise<any> => {
      return await this.#sendReq("Page.close");
    },

    /**
     * @experimental
     * Tries to update the web lifecycle state of the page.
     * It will transition the page to the given state according to:
     * https://github.com/WICG/web-lifecycle/
     */

    setWebLifecycleState: async (
      opts: { state: "frozen" | "active" },
    ): Promise<any> => {
      return await this.#sendReq("Page.setWebLifecycleState", opts);
    },

    /**
     * @experimental
     * Stops sending each frame in the `screencastFrame`.
     */

    stopScreencast: async (): Promise<any> => {
      return await this.#sendReq("Page.stopScreencast");
    },

    /**
     * @experimental
     * Requests backend to produce compilation cache for the specified scripts.
     * `scripts` are appeneded to the list of scripts for which the cache
     * would be produced. The list may be reset during page navigation.
     * When script with a matching URL is encountered, the cache is optionally
     * produced upon backend discretion, based on internal heuristics.
     * See also: `Page.compilationCacheProduced`.
     */

    produceCompilationCache: async (
      opts: { scripts: Page_CompilationCacheParams[] },
    ): Promise<any> => {
      return await this.#sendReq("Page.produceCompilationCache", opts);
    },

    /**
     * @experimental
     * Seeds compilation cache for given url. Compilation cache does not survive
     * cross-process navigation.
     */

    addCompilationCache: async (
      opts: { url: string; data: string },
    ): Promise<any> => {
      return await this.#sendReq("Page.addCompilationCache", opts);
    },

    /**
     * @experimental
     * Clears seeded compilation cache.
     */

    clearCompilationCache: async (): Promise<any> => {
      return await this.#sendReq("Page.clearCompilationCache");
    },

    /**
     * @experimental
     * Sets the Secure Payment Confirmation transaction mode.
     * https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode
     */

    setSPCTransactionMode: async (
      opts: { mode: Page_AutoResponseMode },
    ): Promise<any> => {
      return await this.#sendReq("Page.setSPCTransactionMode", opts);
    },

    /**
     * @experimental
     * Extensions for Custom Handlers API:
     * https://html.spec.whatwg.org/multipage/system-state.html#rph-automation
     */

    setRPHRegistrationMode: async (
      opts: { mode: Page_AutoResponseMode },
    ): Promise<any> => {
      return await this.#sendReq("Page.setRPHRegistrationMode", opts);
    },

    /**
     * @experimental
     * Generates a report for testing.
     */

    generateTestReport: async (
      opts: { message: string; group: string },
    ): Promise<any> => {
      return await this.#sendReq("Page.generateTestReport", opts);
    },

    /**
     * @experimental
     * Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.
     */

    waitForDebugger: async (): Promise<any> => {
      return await this.#sendReq("Page.waitForDebugger");
    },

    /**
     * @experimental
     * Intercept file chooser requests and transfer control to protocol clients.
     * When file chooser interception is enabled, native file chooser dialog is not shown.
     * Instead, a protocol event `Page.fileChooserOpened` is emitted.
     */

    setInterceptFileChooserDialog: async (
      opts: { enabled: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Page.setInterceptFileChooserDialog", opts);
    },

    /**
     * @experimental
     * Enable/disable prerendering manually.
     *
     * This command is a short-term solution for https://crbug.com/1440085.
     * See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
     * for more details.
     *
     * TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets.
     */

    setPrerenderingAllowed: async (
      opts: { isAllowed: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Page.setPrerenderingAllowed", opts);
    },
  };

  Performance = {
    /**
     * Disable collecting and reporting metrics.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Performance.disable");
    },

    /**
     * Enable collecting and reporting metrics.
     */

    enable: async (
      opts: { timeDomain: "timeTicks" | "threadTicks" },
    ): Promise<any> => {
      return await this.#sendReq("Performance.enable", opts);
    },

    /**
     * @experimental
     * @deprecated
     * Sets time domain to use for collecting and reporting duration metrics.
     * Note that this must be called before enabling metrics collection. Calling
     * this method while metrics collection is enabled returns an error.
     */

    setTimeDomain: async (
      opts: { timeDomain: "timeTicks" | "threadTicks" },
    ): Promise<any> => {
      return await this.#sendReq("Performance.setTimeDomain", opts);
    },

    /**
     * Retrieve current values of run-time metrics.
     */

    getMetrics: async (): Promise<any> => {
      return await this.#sendReq("Performance.getMetrics");
    },
  };

  /**
   * @experimental
   * Reporting of performance timeline events, as specified in
   * https://w3c.github.io/performance-timeline/#dom-performanceobserver.
   */
  PerformanceTimeline = {
    /**
     * Previously buffered events would be reported before method returns.
     * See also: timelineEventAdded
     */

    enable: async (opts: { eventTypes: string[] }): Promise<any> => {
      return await this.#sendReq("PerformanceTimeline.enable", opts);
    },
  };

  /**
   * Security
   */
  Security = {
    /**
     * Disables tracking security state changes.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Security.disable");
    },

    /**
     * Enables tracking security state changes.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("Security.enable");
    },

    /**
     * @experimental
     * Enable/disable whether all certificate errors should be ignored.
     */

    setIgnoreCertificateErrors: async (
      opts: { ignore: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Security.setIgnoreCertificateErrors", opts);
    },

    /**
     * @deprecated
     * Handles a certificate error that fired a certificateError event.
     */

    handleCertificateError: async (
      opts: { eventId: number; action: Security_CertificateErrorAction },
    ): Promise<any> => {
      return await this.#sendReq("Security.handleCertificateError", opts);
    },

    /**
     * @deprecated
     * Enable/disable overriding certificate errors. If enabled, all certificate error events need to
     * be handled by the DevTools client and should be answered with `handleCertificateError` commands.
     */

    setOverrideCertificateErrors: async (
      opts: { override: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Security.setOverrideCertificateErrors", opts);
    },
  };

  /**
   * @experimental
   */
  ServiceWorker = {
    deliverPushMessage: async (
      opts: {
        origin: string;
        registrationId: ServiceWorker_RegistrationID;
        data: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("ServiceWorker.deliverPushMessage", opts);
    },

    disable: async (): Promise<any> => {
      return await this.#sendReq("ServiceWorker.disable");
    },

    dispatchSyncEvent: async (
      opts: {
        origin: string;
        registrationId: ServiceWorker_RegistrationID;
        tag: string;
        lastChance: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("ServiceWorker.dispatchSyncEvent", opts);
    },

    dispatchPeriodicSyncEvent: async (
      opts: {
        origin: string;
        registrationId: ServiceWorker_RegistrationID;
        tag: string;
      },
    ): Promise<any> => {
      return await this.#sendReq(
        "ServiceWorker.dispatchPeriodicSyncEvent",
        opts,
      );
    },

    enable: async (): Promise<any> => {
      return await this.#sendReq("ServiceWorker.enable");
    },

    inspectWorker: async (opts: { versionId: string }): Promise<any> => {
      return await this.#sendReq("ServiceWorker.inspectWorker", opts);
    },

    setForceUpdateOnPageLoad: async (
      opts: { forceUpdateOnPageLoad: boolean },
    ): Promise<any> => {
      return await this.#sendReq(
        "ServiceWorker.setForceUpdateOnPageLoad",
        opts,
      );
    },

    skipWaiting: async (opts: { scopeURL: string }): Promise<any> => {
      return await this.#sendReq("ServiceWorker.skipWaiting", opts);
    },

    startWorker: async (opts: { scopeURL: string }): Promise<any> => {
      return await this.#sendReq("ServiceWorker.startWorker", opts);
    },

    stopAllWorkers: async (): Promise<any> => {
      return await this.#sendReq("ServiceWorker.stopAllWorkers");
    },

    stopWorker: async (opts: { versionId: string }): Promise<any> => {
      return await this.#sendReq("ServiceWorker.stopWorker", opts);
    },

    unregister: async (opts: { scopeURL: string }): Promise<any> => {
      return await this.#sendReq("ServiceWorker.unregister", opts);
    },

    updateRegistration: async (opts: { scopeURL: string }): Promise<any> => {
      return await this.#sendReq("ServiceWorker.updateRegistration", opts);
    },
  };

  /**
   * @experimental
   */
  Storage = {
    /**
     * Returns a storage key given a frame id.
     */

    getStorageKeyForFrame: async (
      opts: { frameId: Page_FrameId },
    ): Promise<any> => {
      return await this.#sendReq("Storage.getStorageKeyForFrame", opts);
    },

    /**
     * Clears storage for origin.
     */

    clearDataForOrigin: async (
      opts: { origin: string; storageTypes: string },
    ): Promise<any> => {
      return await this.#sendReq("Storage.clearDataForOrigin", opts);
    },

    /**
     * Clears storage for storage key.
     */

    clearDataForStorageKey: async (
      opts: { storageKey: string; storageTypes: string },
    ): Promise<any> => {
      return await this.#sendReq("Storage.clearDataForStorageKey", opts);
    },

    /**
     * Returns all browser cookies.
     */

    getCookies: async (
      opts: { browserContextId: Browser_BrowserContextID },
    ): Promise<any> => {
      return await this.#sendReq("Storage.getCookies", opts);
    },

    /**
     * Sets given cookies.
     */

    setCookies: async (
      opts: {
        cookies: Network_CookieParam[];
        browserContextId: Browser_BrowserContextID;
      },
    ): Promise<any> => {
      return await this.#sendReq("Storage.setCookies", opts);
    },

    /**
     * Clears cookies.
     */

    clearCookies: async (
      opts: { browserContextId: Browser_BrowserContextID },
    ): Promise<any> => {
      return await this.#sendReq("Storage.clearCookies", opts);
    },

    /**
     * Returns usage and quota in bytes.
     */

    getUsageAndQuota: async (opts: { origin: string }): Promise<any> => {
      return await this.#sendReq("Storage.getUsageAndQuota", opts);
    },

    /**
     * @experimental
     * Override quota for the specified origin
     */

    overrideQuotaForOrigin: async (
      opts: { origin: string; quotaSize: number },
    ): Promise<any> => {
      return await this.#sendReq("Storage.overrideQuotaForOrigin", opts);
    },

    /**
     * Registers origin to be notified when an update occurs to its cache storage list.
     */

    trackCacheStorageForOrigin: async (
      opts: { origin: string },
    ): Promise<any> => {
      return await this.#sendReq("Storage.trackCacheStorageForOrigin", opts);
    },

    /**
     * Registers storage key to be notified when an update occurs to its cache storage list.
     */

    trackCacheStorageForStorageKey: async (
      opts: { storageKey: string },
    ): Promise<any> => {
      return await this.#sendReq(
        "Storage.trackCacheStorageForStorageKey",
        opts,
      );
    },

    /**
     * Registers origin to be notified when an update occurs to its IndexedDB.
     */

    trackIndexedDBForOrigin: async (opts: { origin: string }): Promise<any> => {
      return await this.#sendReq("Storage.trackIndexedDBForOrigin", opts);
    },

    /**
     * Registers storage key to be notified when an update occurs to its IndexedDB.
     */

    trackIndexedDBForStorageKey: async (
      opts: { storageKey: string },
    ): Promise<any> => {
      return await this.#sendReq("Storage.trackIndexedDBForStorageKey", opts);
    },

    /**
     * Unregisters origin from receiving notifications for cache storage.
     */

    untrackCacheStorageForOrigin: async (
      opts: { origin: string },
    ): Promise<any> => {
      return await this.#sendReq("Storage.untrackCacheStorageForOrigin", opts);
    },

    /**
     * Unregisters storage key from receiving notifications for cache storage.
     */

    untrackCacheStorageForStorageKey: async (
      opts: { storageKey: string },
    ): Promise<any> => {
      return await this.#sendReq(
        "Storage.untrackCacheStorageForStorageKey",
        opts,
      );
    },

    /**
     * Unregisters origin from receiving notifications for IndexedDB.
     */

    untrackIndexedDBForOrigin: async (
      opts: { origin: string },
    ): Promise<any> => {
      return await this.#sendReq("Storage.untrackIndexedDBForOrigin", opts);
    },

    /**
     * Unregisters storage key from receiving notifications for IndexedDB.
     */

    untrackIndexedDBForStorageKey: async (
      opts: { storageKey: string },
    ): Promise<any> => {
      return await this.#sendReq("Storage.untrackIndexedDBForStorageKey", opts);
    },

    /**
     * @experimental
     * Returns the number of stored Trust Tokens per issuer for the
     * current browsing context.
     */

    getTrustTokens: async (): Promise<any> => {
      return await this.#sendReq("Storage.getTrustTokens");
    },

    /**
     * @experimental
     * Removes all Trust Tokens issued by the provided issuerOrigin.
     * Leaves other stored data, including the issuer's Redemption Records, intact.
     */

    clearTrustTokens: async (opts: { issuerOrigin: string }): Promise<any> => {
      return await this.#sendReq("Storage.clearTrustTokens", opts);
    },

    /**
     * @experimental
     * Gets details for a named interest group.
     */

    getInterestGroupDetails: async (
      opts: { ownerOrigin: string; name: string },
    ): Promise<any> => {
      return await this.#sendReq("Storage.getInterestGroupDetails", opts);
    },

    /**
     * @experimental
     * Enables/Disables issuing of interestGroupAccessed events.
     */

    setInterestGroupTracking: async (
      opts: { enable: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Storage.setInterestGroupTracking", opts);
    },

    /**
     * @experimental
     * Gets metadata for an origin's shared storage.
     */

    getSharedStorageMetadata: async (
      opts: { ownerOrigin: string },
    ): Promise<any> => {
      return await this.#sendReq("Storage.getSharedStorageMetadata", opts);
    },

    /**
     * @experimental
     * Gets the entries in an given origin's shared storage.
     */

    getSharedStorageEntries: async (
      opts: { ownerOrigin: string },
    ): Promise<any> => {
      return await this.#sendReq("Storage.getSharedStorageEntries", opts);
    },

    /**
     * @experimental
     * Sets entry with `key` and `value` for a given origin's shared storage.
     */

    setSharedStorageEntry: async (
      opts: {
        ownerOrigin: string;
        key: string;
        value: string;
        ignoreIfPresent: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Storage.setSharedStorageEntry", opts);
    },

    /**
     * @experimental
     * Deletes entry for `key` (if it exists) for a given origin's shared storage.
     */

    deleteSharedStorageEntry: async (
      opts: { ownerOrigin: string; key: string },
    ): Promise<any> => {
      return await this.#sendReq("Storage.deleteSharedStorageEntry", opts);
    },

    /**
     * @experimental
     * Clears all entries for a given origin's shared storage.
     */

    clearSharedStorageEntries: async (
      opts: { ownerOrigin: string },
    ): Promise<any> => {
      return await this.#sendReq("Storage.clearSharedStorageEntries", opts);
    },

    /**
     * @experimental
     * Resets the budget for `ownerOrigin` by clearing all budget withdrawals.
     */

    resetSharedStorageBudget: async (
      opts: { ownerOrigin: string },
    ): Promise<any> => {
      return await this.#sendReq("Storage.resetSharedStorageBudget", opts);
    },

    /**
     * @experimental
     * Enables/disables issuing of sharedStorageAccessed events.
     */

    setSharedStorageTracking: async (
      opts: { enable: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Storage.setSharedStorageTracking", opts);
    },

    /**
     * @experimental
     * Set tracking for a storage key's buckets.
     */

    setStorageBucketTracking: async (
      opts: { storageKey: string; enable: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Storage.setStorageBucketTracking", opts);
    },

    /**
     * @experimental
     * Deletes the Storage Bucket with the given storage key and bucket name.
     */

    deleteStorageBucket: async (
      opts: { bucket: Storage_StorageBucket },
    ): Promise<any> => {
      return await this.#sendReq("Storage.deleteStorageBucket", opts);
    },

    /**
     * @experimental
     * Deletes state for sites identified as potential bounce trackers, immediately.
     */

    runBounceTrackingMitigations: async (): Promise<any> => {
      return await this.#sendReq("Storage.runBounceTrackingMitigations");
    },

    /**
     * @experimental
     * https://wicg.github.io/attribution-reporting-api/
     */

    setAttributionReportingLocalTestingMode: async (
      opts: { enabled: boolean },
    ): Promise<any> => {
      return await this.#sendReq(
        "Storage.setAttributionReportingLocalTestingMode",
        opts,
      );
    },

    /**
     * @experimental
     * Enables/disables issuing of Attribution Reporting events.
     */

    setAttributionReportingTracking: async (
      opts: { enable: boolean },
    ): Promise<any> => {
      return await this.#sendReq(
        "Storage.setAttributionReportingTracking",
        opts,
      );
    },
  };

  /**
   * @experimental
   * The SystemInfo domain defines methods and events for querying low-level system information.
   */
  SystemInfo = {
    /**
     * Returns information about the system.
     */

    getInfo: async (): Promise<any> => {
      return await this.#sendReq("SystemInfo.getInfo");
    },

    /**
     * Returns information about the feature state.
     */

    getFeatureState: async (opts: { featureState: string }): Promise<any> => {
      return await this.#sendReq("SystemInfo.getFeatureState", opts);
    },

    /**
     * Returns information about all running processes.
     */

    getProcessInfo: async (): Promise<any> => {
      return await this.#sendReq("SystemInfo.getProcessInfo");
    },
  };

  /**
   * Supports additional targets discovery and allows to attach to them.
   */
  Target = {
    /**
     * Activates (focuses) the target.
     */

    activateTarget: async (
      opts: { targetId: Target_TargetID },
    ): Promise<any> => {
      return await this.#sendReq("Target.activateTarget", opts);
    },

    /**
     * Attaches to the target with given id.
     */

    attachToTarget: async (
      opts: { targetId: Target_TargetID; flatten: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Target.attachToTarget", opts);
    },

    /**
     * @experimental
     * Attaches to the browser target, only uses flat sessionId mode.
     */

    attachToBrowserTarget: async (): Promise<any> => {
      return await this.#sendReq("Target.attachToBrowserTarget");
    },

    /**
     * Closes the target. If the target is a page that gets closed too.
     */

    closeTarget: async (opts: { targetId: Target_TargetID }): Promise<any> => {
      return await this.#sendReq("Target.closeTarget", opts);
    },

    /**
     * @experimental
     * Inject object to the target's main frame that provides a communication
     * channel with browser target.
     *
     * Injected object will be available as `window[bindingName]`.
     *
     * The object has the follwing API:
     * - `binding.send(json)` - a method to send messages over the remote debugging protocol
     * - `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.
     */

    exposeDevToolsProtocol: async (
      opts: { targetId: Target_TargetID; bindingName: string },
    ): Promise<any> => {
      return await this.#sendReq("Target.exposeDevToolsProtocol", opts);
    },

    /**
     * @experimental
     * Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
     * one.
     */

    createBrowserContext: async (
      opts: {
        disposeOnDetach: boolean;
        proxyServer: string;
        proxyBypassList: string;
        originsWithUniversalNetworkAccess: string[];
      },
    ): Promise<any> => {
      return await this.#sendReq("Target.createBrowserContext", opts);
    },

    /**
     * @experimental
     * Returns all browser contexts created with `Target.createBrowserContext` method.
     */

    getBrowserContexts: async (): Promise<any> => {
      return await this.#sendReq("Target.getBrowserContexts");
    },

    /**
     * Creates a new page.
     */

    createTarget: async (
      opts: {
        url: string;
        width: number;
        height: number;
        browserContextId: Browser_BrowserContextID;
        enableBeginFrameControl: boolean;
        newWindow: boolean;
        background: boolean;
        forTab: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Target.createTarget", opts);
    },

    /**
     * Detaches session with given id.
     */

    detachFromTarget: async (
      opts: { sessionId: Target_SessionID; targetId: Target_TargetID },
    ): Promise<any> => {
      return await this.#sendReq("Target.detachFromTarget", opts);
    },

    /**
     * @experimental
     * Deletes a BrowserContext. All the belonging pages will be closed without calling their
     * beforeunload hooks.
     */

    disposeBrowserContext: async (
      opts: { browserContextId: Browser_BrowserContextID },
    ): Promise<any> => {
      return await this.#sendReq("Target.disposeBrowserContext", opts);
    },

    /**
     * @experimental
     * Returns information about a target.
     */

    getTargetInfo: async (
      opts: { targetId: Target_TargetID },
    ): Promise<any> => {
      return await this.#sendReq("Target.getTargetInfo", opts);
    },

    /**
     * Retrieves a list of available targets.
     */

    getTargets: async (opts: { filter: Target_TargetFilter }): Promise<any> => {
      return await this.#sendReq("Target.getTargets", opts);
    },

    /**
     * @deprecated
     * Sends protocol message over session with given id.
     * Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
     * and crbug.com/991325.
     */

    sendMessageToTarget: async (
      opts: {
        message: string;
        sessionId: Target_SessionID;
        targetId: Target_TargetID;
      },
    ): Promise<any> => {
      return await this.#sendReq("Target.sendMessageToTarget", opts);
    },

    /**
     * @experimental
     * Controls whether to automatically attach to new targets which are considered to be related to
     * this one. When turned on, attaches to all existing related targets as well. When turned off,
     * automatically detaches from all currently attached targets.
     * This also clears all targets added by `autoAttachRelated` from the list of targets to watch
     * for creation of related targets.
     */

    setAutoAttach: async (
      opts: {
        autoAttach: boolean;
        waitForDebuggerOnStart: boolean;
        flatten: boolean;
        filter: Target_TargetFilter;
      },
    ): Promise<any> => {
      return await this.#sendReq("Target.setAutoAttach", opts);
    },

    /**
     * @experimental
     * Adds the specified target to the list of targets that will be monitored for any related target
     * creation (such as child frames, child workers and new versions of service worker) and reported
     * through `attachedToTarget`. The specified target is also auto-attached.
     * This cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent
     * `setAutoAttach`. Only available at the Browser target.
     */

    autoAttachRelated: async (
      opts: {
        targetId: Target_TargetID;
        waitForDebuggerOnStart: boolean;
        filter: Target_TargetFilter;
      },
    ): Promise<any> => {
      return await this.#sendReq("Target.autoAttachRelated", opts);
    },

    /**
     * Controls whether to discover available targets and notify via
     * `targetCreated/targetInfoChanged/targetDestroyed` events.
     */

    setDiscoverTargets: async (
      opts: { discover: boolean; filter: Target_TargetFilter },
    ): Promise<any> => {
      return await this.#sendReq("Target.setDiscoverTargets", opts);
    },

    /**
     * @experimental
     * Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
     * `true`.
     */

    setRemoteLocations: async (
      opts: { locations: Target_RemoteLocation[] },
    ): Promise<any> => {
      return await this.#sendReq("Target.setRemoteLocations", opts);
    },
  };

  /**
   * @experimental
   * The Tethering domain defines methods and events for browser port binding.
   */
  Tethering = {
    /**
     * Request browser port binding.
     */

    bind: async (opts: { port: number }): Promise<any> => {
      return await this.#sendReq("Tethering.bind", opts);
    },

    /**
     * Request browser port unbinding.
     */

    unbind: async (opts: { port: number }): Promise<any> => {
      return await this.#sendReq("Tethering.unbind", opts);
    },
  };

  /**
   * @experimental
   */
  Tracing = {
    /**
     * Stop trace events collection.
     */

    end: async (): Promise<any> => {
      return await this.#sendReq("Tracing.end");
    },

    /**
     * Gets supported tracing categories.
     */

    getCategories: async (): Promise<any> => {
      return await this.#sendReq("Tracing.getCategories");
    },

    /**
     * Record a clock sync marker in the trace.
     */

    recordClockSyncMarker: async (opts: { syncId: string }): Promise<any> => {
      return await this.#sendReq("Tracing.recordClockSyncMarker", opts);
    },

    /**
     * Request a global memory dump.
     */

    requestMemoryDump: async (
      opts: {
        deterministic: boolean;
        levelOfDetail: Tracing_MemoryDumpLevelOfDetail;
      },
    ): Promise<any> => {
      return await this.#sendReq("Tracing.requestMemoryDump", opts);
    },

    /**
     * Start trace events collection.
     */

    start: async (
      opts: {
        categories: string;
        options: string;
        bufferUsageReportingInterval: number;
        transferMode: "ReportEvents" | "ReturnAsStream";
        streamFormat: Tracing_StreamFormat;
        streamCompression: Tracing_StreamCompression;
        traceConfig: Tracing_TraceConfig;
        perfettoConfig: string;
        tracingBackend: Tracing_TracingBackend;
      },
    ): Promise<any> => {
      return await this.#sendReq("Tracing.start", opts);
    },
  };

  /**
   * A domain for letting clients substitute browser's network layer with client code.
   */
  Fetch = {
    /**
     * Disables the fetch domain.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Fetch.disable");
    },

    /**
     * Enables issuing of requestPaused events. A request will be paused until client
     * calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.
     */

    enable: async (
      opts: { patterns: Fetch_RequestPattern[]; handleAuthRequests: boolean },
    ): Promise<any> => {
      return await this.#sendReq("Fetch.enable", opts);
    },

    /**
     * Causes the request to fail with specified reason.
     */

    failRequest: async (
      opts: { requestId: Fetch_RequestId; errorReason: Network_ErrorReason },
    ): Promise<any> => {
      return await this.#sendReq("Fetch.failRequest", opts);
    },

    /**
     * Provides response to the request.
     */

    fulfillRequest: async (
      opts: {
        requestId: Fetch_RequestId;
        responseCode: number;
        responseHeaders: Fetch_HeaderEntry[];
        binaryResponseHeaders: string;
        body: string;
        responsePhrase: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("Fetch.fulfillRequest", opts);
    },

    /**
     * Continues the request, optionally modifying some of its parameters.
     */

    continueRequest: async (
      opts: {
        requestId: Fetch_RequestId;
        url: string;
        method: string;
        postData: string;
        headers: Fetch_HeaderEntry[];
        interceptResponse: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Fetch.continueRequest", opts);
    },

    /**
     * Continues a request supplying authChallengeResponse following authRequired event.
     */

    continueWithAuth: async (
      opts: {
        requestId: Fetch_RequestId;
        authChallengeResponse: Fetch_AuthChallengeResponse;
      },
    ): Promise<any> => {
      return await this.#sendReq("Fetch.continueWithAuth", opts);
    },

    /**
     * @experimental
     * Continues loading of the paused response, optionally modifying the
     * response headers. If either responseCode or headers are modified, all of them
     * must be present.
     */

    continueResponse: async (
      opts: {
        requestId: Fetch_RequestId;
        responseCode: number;
        responsePhrase: string;
        responseHeaders: Fetch_HeaderEntry[];
        binaryResponseHeaders: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("Fetch.continueResponse", opts);
    },

    /**
     * Causes the body of the response to be received from the server and
     * returned as a single string. May only be issued for a request that
     * is paused in the Response stage and is mutually exclusive with
     * takeResponseBodyForInterceptionAsStream. Calling other methods that
     * affect the request or disabling fetch domain before body is received
     * results in an undefined behavior.
     * Note that the response body is not available for redirects. Requests
     * paused in the _redirect received_ state may be differentiated by
     * `responseCode` and presence of `location` response header, see
     * comments to `requestPaused` for details.
     */

    getResponseBody: async (
      opts: { requestId: Fetch_RequestId },
    ): Promise<any> => {
      return await this.#sendReq("Fetch.getResponseBody", opts);
    },

    /**
     * Returns a handle to the stream representing the response body.
     * The request must be paused in the HeadersReceived stage.
     * Note that after this command the request can't be continued
     * as is -- client either needs to cancel it or to provide the
     * response body.
     * The stream only supports sequential read, IO.read will fail if the position
     * is specified.
     * This method is mutually exclusive with getResponseBody.
     * Calling other methods that affect the request or disabling fetch
     * domain before body is received results in an undefined behavior.
     */

    takeResponseBodyAsStream: async (
      opts: { requestId: Fetch_RequestId },
    ): Promise<any> => {
      return await this.#sendReq("Fetch.takeResponseBodyAsStream", opts);
    },
  };

  /**
   * @experimental
   * This domain allows inspection of Web Audio API.
   * https://webaudio.github.io/web-audio-api/
   */
  WebAudio = {
    /**
     * Enables the WebAudio domain and starts sending context lifetime events.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("WebAudio.enable");
    },

    /**
     * Disables the WebAudio domain.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("WebAudio.disable");
    },

    /**
     * Fetch the realtime data from the registered contexts.
     */

    getRealtimeData: async (
      opts: { contextId: WebAudio_GraphObjectId },
    ): Promise<any> => {
      return await this.#sendReq("WebAudio.getRealtimeData", opts);
    },
  };

  /**
   * @experimental
   * This domain allows configuring virtual authenticators to test the WebAuthn
   * API.
   */
  WebAuthn = {
    /**
     * Enable the WebAuthn domain and start intercepting credential storage and
     * retrieval with a virtual authenticator.
     */

    enable: async (opts: { enableUI: boolean }): Promise<any> => {
      return await this.#sendReq("WebAuthn.enable", opts);
    },

    /**
     * Disable the WebAuthn domain.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("WebAuthn.disable");
    },

    /**
     * Creates and adds a virtual authenticator.
     */

    addVirtualAuthenticator: async (
      opts: { options: WebAuthn_VirtualAuthenticatorOptions },
    ): Promise<any> => {
      return await this.#sendReq("WebAuthn.addVirtualAuthenticator", opts);
    },

    /**
     * Resets parameters isBogusSignature, isBadUV, isBadUP to false if they are not present.
     */

    setResponseOverrideBits: async (
      opts: {
        authenticatorId: WebAuthn_AuthenticatorId;
        isBogusSignature: boolean;
        isBadUV: boolean;
        isBadUP: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("WebAuthn.setResponseOverrideBits", opts);
    },

    /**
     * Removes the given authenticator.
     */

    removeVirtualAuthenticator: async (
      opts: { authenticatorId: WebAuthn_AuthenticatorId },
    ): Promise<any> => {
      return await this.#sendReq("WebAuthn.removeVirtualAuthenticator", opts);
    },

    /**
     * Adds the credential to the specified authenticator.
     */

    addCredential: async (
      opts: {
        authenticatorId: WebAuthn_AuthenticatorId;
        credential: WebAuthn_Credential;
      },
    ): Promise<any> => {
      return await this.#sendReq("WebAuthn.addCredential", opts);
    },

    /**
     * Returns a single credential stored in the given virtual authenticator that
     * matches the credential ID.
     */

    getCredential: async (
      opts: { authenticatorId: WebAuthn_AuthenticatorId; credentialId: string },
    ): Promise<any> => {
      return await this.#sendReq("WebAuthn.getCredential", opts);
    },

    /**
     * Returns all the credentials stored in the given virtual authenticator.
     */

    getCredentials: async (
      opts: { authenticatorId: WebAuthn_AuthenticatorId },
    ): Promise<any> => {
      return await this.#sendReq("WebAuthn.getCredentials", opts);
    },

    /**
     * Removes a credential from the authenticator.
     */

    removeCredential: async (
      opts: { authenticatorId: WebAuthn_AuthenticatorId; credentialId: string },
    ): Promise<any> => {
      return await this.#sendReq("WebAuthn.removeCredential", opts);
    },

    /**
     * Clears all the credentials from the specified device.
     */

    clearCredentials: async (
      opts: { authenticatorId: WebAuthn_AuthenticatorId },
    ): Promise<any> => {
      return await this.#sendReq("WebAuthn.clearCredentials", opts);
    },

    /**
     * Sets whether User Verification succeeds or fails for an authenticator.
     * The default is true.
     */

    setUserVerified: async (
      opts: {
        authenticatorId: WebAuthn_AuthenticatorId;
        isUserVerified: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("WebAuthn.setUserVerified", opts);
    },

    /**
     * Sets whether tests of user presence will succeed immediately (if true) or fail to resolve (if false) for an authenticator.
     * The default is true.
     */

    setAutomaticPresenceSimulation: async (
      opts: { authenticatorId: WebAuthn_AuthenticatorId; enabled: boolean },
    ): Promise<any> => {
      return await this.#sendReq(
        "WebAuthn.setAutomaticPresenceSimulation",
        opts,
      );
    },
  };

  /**
   * @experimental
   * This domain allows detailed inspection of media elements
   */
  Media = {
    /**
     * Enables the Media domain
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("Media.enable");
    },

    /**
     * Disables the Media domain.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Media.disable");
    },
  };

  /**
   * @experimental
   */
  DeviceAccess = {
    /**
     * Enable events in this domain.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("DeviceAccess.enable");
    },

    /**
     * Disable events in this domain.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("DeviceAccess.disable");
    },

    /**
     * Select a device in response to a DeviceAccess.deviceRequestPrompted event.
     */

    selectPrompt: async (
      opts: { id: DeviceAccess_RequestId; deviceId: DeviceAccess_DeviceId },
    ): Promise<any> => {
      return await this.#sendReq("DeviceAccess.selectPrompt", opts);
    },

    /**
     * Cancel a prompt in response to a DeviceAccess.deviceRequestPrompted event.
     */

    cancelPrompt: async (
      opts: { id: DeviceAccess_RequestId },
    ): Promise<any> => {
      return await this.#sendReq("DeviceAccess.cancelPrompt", opts);
    },
  };

  /**
   * @experimental
   */
  Preload = {
    enable: async (): Promise<any> => {
      return await this.#sendReq("Preload.enable");
    },

    disable: async (): Promise<any> => {
      return await this.#sendReq("Preload.disable");
    },
  };

  /**
   * @experimental
   * This domain allows interacting with the FedCM dialog.
   */
  FedCm = {
    enable: async (opts: { disableRejectionDelay: boolean }): Promise<any> => {
      return await this.#sendReq("FedCm.enable", opts);
    },

    disable: async (): Promise<any> => {
      return await this.#sendReq("FedCm.disable");
    },

    selectAccount: async (
      opts: { dialogId: string; accountIndex: number },
    ): Promise<any> => {
      return await this.#sendReq("FedCm.selectAccount", opts);
    },

    dismissDialog: async (
      opts: { dialogId: string; triggerCooldown: boolean },
    ): Promise<any> => {
      return await this.#sendReq("FedCm.dismissDialog", opts);
    },

    /**
     * Resets the cooldown time, if any, to allow the next FedCM call to show
     * a dialog even if one was recently dismissed by the user.
     */

    resetCooldown: async (): Promise<any> => {
      return await this.#sendReq("FedCm.resetCooldown");
    },
  };

  /**
   * @deprecated
   * This domain is deprecated - use Runtime or Log instead.
   */
  Console = {
    /**
     * Does nothing.
     */

    clearMessages: async (): Promise<any> => {
      return await this.#sendReq("Console.clearMessages");
    },

    /**
     * Disables console domain, prevents further console messages from being reported to the client.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Console.disable");
    },

    /**
     * Enables console domain, sends the messages collected so far to the client by means of the
     * `messageAdded` notification.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("Console.enable");
    },
  };

  /**
   * Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing
   * breakpoints, stepping through execution, exploring stack traces, etc.
   */
  Debugger = {
    /**
     * Continues execution until specific location is reached.
     */

    continueToLocation: async (
      opts: {
        location: Debugger_Location;
        targetCallFrames: "any" | "current";
      },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.continueToLocation", opts);
    },

    /**
     * Disables debugger for given page.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Debugger.disable");
    },

    /**
     * Enables debugger for the given page. Clients should not assume that the debugging has been
     * enabled until the result for this command is received.
     */

    enable: async (opts: { maxScriptsCacheSize: number }): Promise<any> => {
      return await this.#sendReq("Debugger.enable", opts);
    },

    /**
     * Evaluates expression on a given call frame.
     */

    evaluateOnCallFrame: async (
      opts: {
        callFrameId: Debugger_CallFrameId;
        expression: string;
        objectGroup: string;
        includeCommandLineAPI: boolean;
        silent: boolean;
        returnByValue: boolean;
        generatePreview: boolean;
        throwOnSideEffect: boolean;
        timeout: Runtime_TimeDelta;
      },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.evaluateOnCallFrame", opts);
    },

    /**
     * Returns possible locations for breakpoint. scriptId in start and end range locations should be
     * the same.
     */

    getPossibleBreakpoints: async (
      opts: {
        start: Debugger_Location;
        end: Debugger_Location;
        restrictToFunction: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.getPossibleBreakpoints", opts);
    },

    /**
     * Returns source for the script with given id.
     */

    getScriptSource: async (
      opts: { scriptId: Runtime_ScriptId },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.getScriptSource", opts);
    },

    /**
     * @experimental
     */

    disassembleWasmModule: async (
      opts: { scriptId: Runtime_ScriptId },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.disassembleWasmModule", opts);
    },

    /**
     * @experimental
     * Disassemble the next chunk of lines for the module corresponding to the
     * stream. If disassembly is complete, this API will invalidate the streamId
     * and return an empty chunk. Any subsequent calls for the now invalid stream
     * will return errors.
     */

    nextWasmDisassemblyChunk: async (
      opts: { streamId: string },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.nextWasmDisassemblyChunk", opts);
    },

    /**
     * @deprecated
     * This command is deprecated. Use getScriptSource instead.
     */

    getWasmBytecode: async (
      opts: { scriptId: Runtime_ScriptId },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.getWasmBytecode", opts);
    },

    /**
     * @experimental
     * Returns stack trace with given `stackTraceId`.
     */

    getStackTrace: async (
      opts: { stackTraceId: Runtime_StackTraceId },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.getStackTrace", opts);
    },

    /**
     * Stops on the next JavaScript statement.
     */

    pause: async (): Promise<any> => {
      return await this.#sendReq("Debugger.pause");
    },

    /**
     * @experimental
     * @deprecated
     */

    pauseOnAsyncCall: async (
      opts: { parentStackTraceId: Runtime_StackTraceId },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.pauseOnAsyncCall", opts);
    },

    /**
     * Removes JavaScript breakpoint.
     */

    removeBreakpoint: async (
      opts: { breakpointId: Debugger_BreakpointId },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.removeBreakpoint", opts);
    },

    /**
     * Restarts particular call frame from the beginning. The old, deprecated
     * behavior of `restartFrame` is to stay paused and allow further CDP commands
     * after a restart was scheduled. This can cause problems with restarting, so
     * we now continue execution immediatly after it has been scheduled until we
     * reach the beginning of the restarted frame.
     *
     * To stay back-wards compatible, `restartFrame` now expects a `mode`
     * parameter to be present. If the `mode` parameter is missing, `restartFrame`
     * errors out.
     *
     * The various return values are deprecated and `callFrames` is always empty.
     * Use the call frames from the `Debugger#paused` events instead, that fires
     * once V8 pauses at the beginning of the restarted function.
     */

    restartFrame: async (
      opts: { callFrameId: Debugger_CallFrameId; mode: "StepInto" },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.restartFrame", opts);
    },

    /**
     * Resumes JavaScript execution.
     */

    resume: async (opts: { terminateOnResume: boolean }): Promise<any> => {
      return await this.#sendReq("Debugger.resume", opts);
    },

    /**
     * Searches for given string in script content.
     */

    searchInContent: async (
      opts: {
        scriptId: Runtime_ScriptId;
        query: string;
        caseSensitive: boolean;
        isRegex: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.searchInContent", opts);
    },

    /**
     * Enables or disables async call stacks tracking.
     */

    setAsyncCallStackDepth: async (
      opts: { maxDepth: number },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.setAsyncCallStackDepth", opts);
    },

    /**
     * @experimental
     * Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
     * scripts with url matching one of the patterns. VM will try to leave blackboxed script by
     * performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
     */

    setBlackboxPatterns: async (opts: { patterns: string[] }): Promise<any> => {
      return await this.#sendReq("Debugger.setBlackboxPatterns", opts);
    },

    /**
     * @experimental
     * Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
     * scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
     * Positions array contains positions where blackbox state is changed. First interval isn't
     * blackboxed. Array should be sorted.
     */

    setBlackboxedRanges: async (
      opts: {
        scriptId: Runtime_ScriptId;
        positions: Debugger_ScriptPosition[];
      },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.setBlackboxedRanges", opts);
    },

    /**
     * Sets JavaScript breakpoint at a given location.
     */

    setBreakpoint: async (
      opts: { location: Debugger_Location; condition: string },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.setBreakpoint", opts);
    },

    /**
     * Sets instrumentation breakpoint.
     */

    setInstrumentationBreakpoint: async (
      opts: {
        instrumentation:
          | "beforeScriptExecution"
          | "beforeScriptWithSourceMapExecution";
      },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.setInstrumentationBreakpoint", opts);
    },

    /**
     * Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
     * command is issued, all existing parsed scripts will have breakpoints resolved and returned in
     * `locations` property. Further matching script parsing will result in subsequent
     * `breakpointResolved` events issued. This logical breakpoint will survive page reloads.
     */

    setBreakpointByUrl: async (
      opts: {
        lineNumber: number;
        url: string;
        urlRegex: string;
        scriptHash: string;
        columnNumber: number;
        condition: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.setBreakpointByUrl", opts);
    },

    /**
     * @experimental
     * Sets JavaScript breakpoint before each call to the given function.
     * If another function was created from the same source as a given one,
     * calling it will also trigger the breakpoint.
     */

    setBreakpointOnFunctionCall: async (
      opts: { objectId: Runtime_RemoteObjectId; condition: string },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.setBreakpointOnFunctionCall", opts);
    },

    /**
     * Activates / deactivates all breakpoints on the page.
     */

    setBreakpointsActive: async (opts: { active: boolean }): Promise<any> => {
      return await this.#sendReq("Debugger.setBreakpointsActive", opts);
    },

    /**
     * Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
     * or caught exceptions, no exceptions. Initial pause on exceptions state is `none`.
     */

    setPauseOnExceptions: async (
      opts: { state: "none" | "caught" | "uncaught" | "all" },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.setPauseOnExceptions", opts);
    },

    /**
     * @experimental
     * Changes return value in top frame. Available only at return break position.
     */

    setReturnValue: async (
      opts: { newValue: Runtime_CallArgument },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.setReturnValue", opts);
    },

    /**
     * Edits JavaScript source live.
     *
     * In general, functions that are currently on the stack can not be edited with
     * a single exception: If the edited function is the top-most stack frame and
     * that is the only activation of that function on the stack. In this case
     * the live edit will be successful and a `Debugger.restartFrame` for the
     * top-most function is automatically triggered.
     */

    setScriptSource: async (
      opts: {
        scriptId: Runtime_ScriptId;
        scriptSource: string;
        dryRun: boolean;
        allowTopFrameEditing: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.setScriptSource", opts);
    },

    /**
     * Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
     */

    setSkipAllPauses: async (opts: { skip: boolean }): Promise<any> => {
      return await this.#sendReq("Debugger.setSkipAllPauses", opts);
    },

    /**
     * Changes value of variable in a callframe. Object-based scopes are not supported and must be
     * mutated manually.
     */

    setVariableValue: async (
      opts: {
        scopeNumber: number;
        variableName: string;
        newValue: Runtime_CallArgument;
        callFrameId: Debugger_CallFrameId;
      },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.setVariableValue", opts);
    },

    /**
     * Steps into the function call.
     */

    stepInto: async (
      opts: { breakOnAsyncCall: boolean; skipList: Debugger_LocationRange[] },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.stepInto", opts);
    },

    /**
     * Steps out of the function call.
     */

    stepOut: async (): Promise<any> => {
      return await this.#sendReq("Debugger.stepOut");
    },

    /**
     * Steps over the statement.
     */

    stepOver: async (
      opts: { skipList: Debugger_LocationRange[] },
    ): Promise<any> => {
      return await this.#sendReq("Debugger.stepOver", opts);
    },
  };

  /**
   * @experimental
   */
  HeapProfiler = {
    /**
     * Enables console to refer to the node with given id via $x (see Command Line API for more details
     * $x functions).
     */

    addInspectedHeapObject: async (
      opts: { heapObjectId: HeapProfiler_HeapSnapshotObjectId },
    ): Promise<any> => {
      return await this.#sendReq("HeapProfiler.addInspectedHeapObject", opts);
    },

    collectGarbage: async (): Promise<any> => {
      return await this.#sendReq("HeapProfiler.collectGarbage");
    },

    disable: async (): Promise<any> => {
      return await this.#sendReq("HeapProfiler.disable");
    },

    enable: async (): Promise<any> => {
      return await this.#sendReq("HeapProfiler.enable");
    },

    getHeapObjectId: async (
      opts: { objectId: Runtime_RemoteObjectId },
    ): Promise<any> => {
      return await this.#sendReq("HeapProfiler.getHeapObjectId", opts);
    },

    getObjectByHeapObjectId: async (
      opts: {
        objectId: HeapProfiler_HeapSnapshotObjectId;
        objectGroup: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("HeapProfiler.getObjectByHeapObjectId", opts);
    },

    getSamplingProfile: async (): Promise<any> => {
      return await this.#sendReq("HeapProfiler.getSamplingProfile");
    },

    startSampling: async (
      opts: {
        samplingInterval: number;
        includeObjectsCollectedByMajorGC: boolean;
        includeObjectsCollectedByMinorGC: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("HeapProfiler.startSampling", opts);
    },

    startTrackingHeapObjects: async (
      opts: { trackAllocations: boolean },
    ): Promise<any> => {
      return await this.#sendReq("HeapProfiler.startTrackingHeapObjects", opts);
    },

    stopSampling: async (): Promise<any> => {
      return await this.#sendReq("HeapProfiler.stopSampling");
    },

    stopTrackingHeapObjects: async (
      opts: {
        reportProgress: boolean;
        treatGlobalObjectsAsRoots: boolean;
        captureNumericValue: boolean;
        exposeInternals: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("HeapProfiler.stopTrackingHeapObjects", opts);
    },

    takeHeapSnapshot: async (
      opts: {
        reportProgress: boolean;
        treatGlobalObjectsAsRoots: boolean;
        captureNumericValue: boolean;
        exposeInternals: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("HeapProfiler.takeHeapSnapshot", opts);
    },
  };

  Profiler = {
    disable: async (): Promise<any> => {
      return await this.#sendReq("Profiler.disable");
    },

    enable: async (): Promise<any> => {
      return await this.#sendReq("Profiler.enable");
    },

    /**
     * Collect coverage data for the current isolate. The coverage data may be incomplete due to
     * garbage collection.
     */

    getBestEffortCoverage: async (): Promise<any> => {
      return await this.#sendReq("Profiler.getBestEffortCoverage");
    },

    /**
     * Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
     */

    setSamplingInterval: async (opts: { interval: number }): Promise<any> => {
      return await this.#sendReq("Profiler.setSamplingInterval", opts);
    },

    start: async (): Promise<any> => {
      return await this.#sendReq("Profiler.start");
    },

    /**
     * Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
     * coverage may be incomplete. Enabling prevents running optimized code and resets execution
     * counters.
     */

    startPreciseCoverage: async (
      opts: {
        callCount: boolean;
        detailed: boolean;
        allowTriggeredUpdates: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Profiler.startPreciseCoverage", opts);
    },

    stop: async (): Promise<any> => {
      return await this.#sendReq("Profiler.stop");
    },

    /**
     * Disable precise code coverage. Disabling releases unnecessary execution count records and allows
     * executing optimized code.
     */

    stopPreciseCoverage: async (): Promise<any> => {
      return await this.#sendReq("Profiler.stopPreciseCoverage");
    },

    /**
     * Collect coverage data for the current isolate, and resets execution counters. Precise code
     * coverage needs to have started.
     */

    takePreciseCoverage: async (): Promise<any> => {
      return await this.#sendReq("Profiler.takePreciseCoverage");
    },
  };

  /**
   * Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
   * Evaluation results are returned as mirror object that expose object type, string representation
   * and unique identifier that can be used for further object reference. Original objects are
   * maintained in memory unless they are either explicitly released or are released along with the
   * other objects in their object group.
   */
  Runtime = {
    /**
     * Add handler to promise with given promise object id.
     */

    awaitPromise: async (
      opts: {
        promiseObjectId: Runtime_RemoteObjectId;
        returnByValue: boolean;
        generatePreview: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Runtime.awaitPromise", opts);
    },

    /**
     * Calls function with given declaration on the given object. Object group of the result is
     * inherited from the target object.
     */

    callFunctionOn: async (
      opts: {
        functionDeclaration: string;
        objectId: Runtime_RemoteObjectId;
        arguments: Runtime_CallArgument[];
        silent: boolean;
        returnByValue: boolean;
        generatePreview: boolean;
        userGesture: boolean;
        awaitPromise: boolean;
        executionContextId: Runtime_ExecutionContextId;
        objectGroup: string;
        throwOnSideEffect: boolean;
        uniqueContextId: string;
        generateWebDriverValue: boolean;
        serializationOptions: Runtime_SerializationOptions;
      },
    ): Promise<any> => {
      return await this.#sendReq("Runtime.callFunctionOn", opts);
    },

    /**
     * Compiles expression.
     */

    compileScript: async (
      opts: {
        expression: string;
        sourceURL: string;
        persistScript: boolean;
        executionContextId: Runtime_ExecutionContextId;
      },
    ): Promise<any> => {
      return await this.#sendReq("Runtime.compileScript", opts);
    },

    /**
     * Disables reporting of execution contexts creation.
     */

    disable: async (): Promise<any> => {
      return await this.#sendReq("Runtime.disable");
    },

    /**
     * Discards collected exceptions and console API calls.
     */

    discardConsoleEntries: async (): Promise<any> => {
      return await this.#sendReq("Runtime.discardConsoleEntries");
    },

    /**
     * Enables reporting of execution contexts creation by means of `executionContextCreated` event.
     * When the reporting gets enabled the event will be sent immediately for each existing execution
     * context.
     */

    enable: async (): Promise<any> => {
      return await this.#sendReq("Runtime.enable");
    },

    /**
     * Evaluates expression on global object.
     */

    evaluate: async (
      opts: {
        expression: string;
        objectGroup: string;
        includeCommandLineAPI: boolean;
        silent: boolean;
        contextId: Runtime_ExecutionContextId;
        returnByValue: boolean;
        generatePreview: boolean;
        userGesture: boolean;
        awaitPromise: boolean;
        throwOnSideEffect: boolean;
        timeout: Runtime_TimeDelta;
        disableBreaks: boolean;
        replMode: boolean;
        allowUnsafeEvalBlockedByCSP: boolean;
        uniqueContextId: string;
        generateWebDriverValue: boolean;
        serializationOptions: Runtime_SerializationOptions;
      },
    ): Promise<any> => {
      return await this.#sendReq("Runtime.evaluate", opts);
    },

    /**
     * @experimental
     * Returns the isolate id.
     */

    getIsolateId: async (): Promise<any> => {
      return await this.#sendReq("Runtime.getIsolateId");
    },

    /**
     * @experimental
     * Returns the JavaScript heap usage.
     * It is the total usage of the corresponding isolate not scoped to a particular Runtime.
     */

    getHeapUsage: async (): Promise<any> => {
      return await this.#sendReq("Runtime.getHeapUsage");
    },

    /**
     * Returns properties of a given object. Object group of the result is inherited from the target
     * object.
     */

    getProperties: async (
      opts: {
        objectId: Runtime_RemoteObjectId;
        ownProperties: boolean;
        accessorPropertiesOnly: boolean;
        generatePreview: boolean;
        nonIndexedPropertiesOnly: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Runtime.getProperties", opts);
    },

    /**
     * Returns all let, const and class variables from global scope.
     */

    globalLexicalScopeNames: async (
      opts: { executionContextId: Runtime_ExecutionContextId },
    ): Promise<any> => {
      return await this.#sendReq("Runtime.globalLexicalScopeNames", opts);
    },

    queryObjects: async (
      opts: { prototypeObjectId: Runtime_RemoteObjectId; objectGroup: string },
    ): Promise<any> => {
      return await this.#sendReq("Runtime.queryObjects", opts);
    },

    /**
     * Releases remote object with given id.
     */

    releaseObject: async (
      opts: { objectId: Runtime_RemoteObjectId },
    ): Promise<any> => {
      return await this.#sendReq("Runtime.releaseObject", opts);
    },

    /**
     * Releases all remote objects that belong to a given group.
     */

    releaseObjectGroup: async (opts: { objectGroup: string }): Promise<any> => {
      return await this.#sendReq("Runtime.releaseObjectGroup", opts);
    },

    /**
     * Tells inspected instance to run if it was waiting for debugger to attach.
     */

    runIfWaitingForDebugger: async (): Promise<any> => {
      return await this.#sendReq("Runtime.runIfWaitingForDebugger");
    },

    /**
     * Runs script with given id in a given context.
     */

    runScript: async (
      opts: {
        scriptId: Runtime_ScriptId;
        executionContextId: Runtime_ExecutionContextId;
        objectGroup: string;
        silent: boolean;
        includeCommandLineAPI: boolean;
        returnByValue: boolean;
        generatePreview: boolean;
        awaitPromise: boolean;
      },
    ): Promise<any> => {
      return await this.#sendReq("Runtime.runScript", opts);
    },

    /**
     * Enables or disables async call stacks tracking.
     */

    setAsyncCallStackDepth: async (
      opts: { maxDepth: number },
    ): Promise<any> => {
      return await this.#sendReq("Runtime.setAsyncCallStackDepth", opts);
    },

    /**
     * @experimental
     */

    setCustomObjectFormatterEnabled: async (
      opts: { enabled: boolean },
    ): Promise<any> => {
      return await this.#sendReq(
        "Runtime.setCustomObjectFormatterEnabled",
        opts,
      );
    },

    /**
     * @experimental
     */

    setMaxCallStackSizeToCapture: async (
      opts: { size: number },
    ): Promise<any> => {
      return await this.#sendReq("Runtime.setMaxCallStackSizeToCapture", opts);
    },

    /**
     * @experimental
     * Terminate current or next JavaScript execution.
     * Will cancel the termination when the outer-most script execution ends.
     */

    terminateExecution: async (): Promise<any> => {
      return await this.#sendReq("Runtime.terminateExecution");
    },

    /**
     * @experimental
     * If executionContextId is empty, adds binding with the given name on the
     * global objects of all inspected contexts, including those created later,
     * bindings survive reloads.
     * Binding function takes exactly one argument, this argument should be string,
     * in case of any other input, function throws an exception.
     * Each binding function call produces Runtime.bindingCalled notification.
     */

    addBinding: async (
      opts: {
        name: string;
        executionContextId: Runtime_ExecutionContextId;
        executionContextName: string;
      },
    ): Promise<any> => {
      return await this.#sendReq("Runtime.addBinding", opts);
    },

    /**
     * @experimental
     * This method does not remove binding function from global object but
     * unsubscribes current runtime agent from Runtime.bindingCalled notifications.
     */

    removeBinding: async (opts: { name: string }): Promise<any> => {
      return await this.#sendReq("Runtime.removeBinding", opts);
    },

    /**
     * @experimental
     * This method tries to lookup and populate exception details for a
     * JavaScript Error object.
     * Note that the stackTrace portion of the resulting exceptionDetails will
     * only be populated if the Runtime domain was enabled at the time when the
     * Error was thrown.
     */

    getExceptionDetails: async (
      opts: { errorObjectId: Runtime_RemoteObjectId },
    ): Promise<any> => {
      return await this.#sendReq("Runtime.getExceptionDetails", opts);
    },
  };

  /**
   * @deprecated
   * This domain is deprecated.
   */
  Schema = {
    /**
     * Returns supported domains.
     */

    getDomains: async (): Promise<any> => {
      return await this.#sendReq("Schema.getDomains");
    },
  };
}
